[
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/__tests__/accessibility-comprehensive.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 23,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 23,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [998, 1001], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [998, 1001], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'dialog' is assigned a value but never used.",
        "line": 536,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 536,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 701,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 701,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 727,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 727,
        "endColumn": 70
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import './setup-accessibility-tests'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { axe, toHaveNoViolations } from 'jest-axe'\nimport { DashboardLayout } from '../layout/dashboard-layout'\nimport { DashboardCard } from '../cards/dashboard-card'\nimport { DashboardGrid, GridItem } from '../grid/dashboard-grid'\nimport { ChartWrapper } from '../charts/chart-wrapper'\nimport { DashboardThemeProvider } from '../theming/theme-provider'\nimport { FilterProvider } from '../filters/filter-context'\n\n// Extend Jest matchers\nexpect.extend(toHaveNoViolations)\n\n// Mock components that might cause issues in testing\njest.mock('../mobile/touch-interactions', () => ({\n  useIsMobile: jest.fn(() => false),\n  useIsTouchDevice: jest.fn(() => false),\n  TouchInteraction: ({ children }: { children: React.ReactNode }) => <div>{children}</div>\n}))\n\njest.mock('../charts/chart-types/line-chart', () => ({\n  LineChart: ({ data }: any) => (\n    <div \n      data-testid=\"line-chart\"\n      role=\"img\"\n      aria-label={`Line chart with ${data.datasets.length} datasets`}\n    >\n      Line Chart\n    </div>\n  )\n}))\n\ndescribe('Dashboard Accessibility Comprehensive Tests', () => {\n  const mockData = {\n    datasets: [\n      {\n        label: 'Test Data',\n        data: [\n          { x: 'Jan', y: 100 },\n          { x: 'Feb', y: 150 },\n          { x: 'Mar', y: 120 }\n        ]\n      }\n    ]\n  }\n\n  describe('WCAG 2.1 AA Compliance', () => {\n    it('DashboardLayout meets accessibility standards', async () => {\n      const { container } = render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<div>Header Content</div>}\n            sidebar={<nav>Navigation Content</nav>}\n            footer={<div>Footer Content</div>}\n          >\n            <main>Main Content</main>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('DashboardCard meets accessibility standards', async () => {\n      const { container } = render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Accessible Card\"\n            subtitle=\"Card subtitle\"\n            metric={{\n              value: 1234,\n              unit: 'users',\n              trend: 'up',\n              trendValue: '+5%'\n            }}\n          >\n            <div>Card content</div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('DashboardGrid meets accessibility standards', async () => {\n      const { container } = render(\n        <DashboardThemeProvider>\n          <DashboardGrid>\n            <GridItem colSpan={6}>\n              <DashboardCard title=\"Card 1\">Content 1</DashboardCard>\n            </GridItem>\n            <GridItem colSpan={6}>\n              <DashboardCard title=\"Card 2\">Content 2</DashboardCard>\n            </GridItem>\n          </DashboardGrid>\n        </DashboardThemeProvider>\n      )\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('ChartWrapper meets accessibility standards', async () => {\n      const { container } = render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockData}\n            config={{\n              colors: { primary: '#3F51B5' },\n              legend: { show: true, position: 'bottom', align: 'center' }\n            }}\n          />\n        </DashboardThemeProvider>\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n      })\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('Interactive dashboard components meet accessibility standards', async () => {\n      const { container } = render(\n        <DashboardThemeProvider>\n          <FilterProvider>\n            <DashboardLayout\n              header={\n                <header>\n                  <h1>Dashboard</h1>\n                  <button>Settings</button>\n                </header>\n              }\n              sidebar={\n                <nav aria-label=\"Main navigation\">\n                  <ul>\n                    <li><a href=\"#analytics\">Analytics</a></li>\n                    <li><a href=\"#reports\">Reports</a></li>\n                  </ul>\n                </nav>\n              }\n            >\n              <DashboardGrid>\n                <GridItem colSpan={4}>\n                  <DashboardCard\n                    title=\"Interactive Card\"\n                    interactive={true}\n                    onClick={() => {}}\n                  >\n                    <button>Action Button</button>\n                  </DashboardCard>\n                </GridItem>\n                <GridItem colSpan={8}>\n                  <DashboardCard title=\"Chart Card\">\n                    <ChartWrapper\n                      type=\"line\"\n                      data={mockData}\n                      interactive={true}\n                    />\n                  </DashboardCard>\n                </GridItem>\n              </DashboardGrid>\n            </DashboardLayout>\n          </FilterProvider>\n        </DashboardThemeProvider>\n      )\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('Error states meet accessibility standards', async () => {\n      const { container } = render(\n        <DashboardThemeProvider>\n          <DashboardGrid>\n            <GridItem>\n              <DashboardCard\n                title=\"Error Card\"\n                error=\"Failed to load data\"\n              />\n            </GridItem>\n            <GridItem>\n              <DashboardCard title=\"Chart Error\">\n                <ChartWrapper\n                  type=\"line\"\n                  data={mockData}\n                  error=\"Chart failed to render\"\n                />\n              </DashboardCard>\n            </GridItem>\n          </DashboardGrid>\n        </DashboardThemeProvider>\n      )\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('Loading states meet accessibility standards', async () => {\n      const { container } = render(\n        <DashboardThemeProvider>\n          <DashboardGrid>\n            <GridItem>\n              <DashboardCard\n                title=\"Loading Card\"\n                loading={true}\n              />\n            </GridItem>\n            <GridItem>\n              <DashboardCard title=\"Chart Loading\">\n                <ChartWrapper\n                  type=\"line\"\n                  data={mockData}\n                  loading={true}\n                />\n              </DashboardCard>\n            </GridItem>\n          </DashboardGrid>\n        </DashboardThemeProvider>\n      )\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n  })\n\n  describe('Keyboard Navigation', () => {\n    it('supports tab navigation through dashboard layout', async () => {\n      const user = userEvent.setup()\n      \n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={\n              <div>\n                <button>Header Button 1</button>\n                <button>Header Button 2</button>\n              </div>\n            }\n            sidebar={\n              <nav>\n                <a href=\"#link1\">Link 1</a>\n                <a href=\"#link2\">Link 2</a>\n              </nav>\n            }\n          >\n            <main>\n              <button>Main Button</button>\n            </main>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      // Test tab order\n      await user.tab()\n      expect(screen.getByText('Header Button 1')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByText('Header Button 2')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByText('Link 1')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByText('Link 2')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByText('Main Button')).toHaveFocus()\n    })\n\n    it('supports keyboard interaction with interactive cards', async () => {\n      const user = userEvent.setup()\n      const onClick = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Interactive Card\"\n            interactive={true}\n            onClick={onClick}\n          >\n            <div>Card content</div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      const card = screen.getByRole('button', { name: /interactive card/i })\n      \n      // Focus the card\n      await user.tab()\n      expect(card).toHaveFocus()\n\n      // Activate with Enter\n      await user.keyboard('{Enter}')\n      expect(onClick).toHaveBeenCalledTimes(1)\n\n      // Activate with Space\n      await user.keyboard(' ')\n      expect(onClick).toHaveBeenCalledTimes(2)\n    })\n\n    it('supports keyboard navigation in charts', async () => {\n      const user = userEvent.setup()\n      const onDataClick = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockData}\n            interactive={true}\n            onDataClick={onDataClick}\n          />\n        </DashboardThemeProvider>\n      )\n\n      await waitFor(() => {\n        const chartContainer = screen.getByRole('application')\n        expect(chartContainer).toBeInTheDocument()\n      })\n\n      const chartContainer = screen.getByRole('application')\n      \n      // Focus the chart\n      await user.tab()\n      expect(chartContainer).toHaveFocus()\n\n      // Test arrow key navigation (implementation would depend on chart type)\n      await user.keyboard('{ArrowRight}')\n      await user.keyboard('{ArrowLeft}')\n      await user.keyboard('{Enter}')\n    })\n\n    it('provides skip links for efficient navigation', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<div>Header</div>}\n            sidebar={<nav>Sidebar</nav>}\n            footer={<div>Footer</div>}\n          >\n            <main id=\"main-content\">Main Content</main>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      // Skip links should be the first focusable elements\n      await user.tab()\n      \n      // Look for skip link (implementation may vary)\n      const skipLink = document.activeElement\n      expect(skipLink).toHaveAttribute('href', expect.stringContaining('#main-content'))\n    })\n\n    it('manages focus properly when sidebar is toggled', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<div>Header</div>}\n            sidebar={<nav>Sidebar Content</nav>}\n          >\n            <main>Main Content</main>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      // Find and focus the sidebar toggle button\n      const toggleButton = screen.getByRole('button', { name: /sidebar/i })\n      toggleButton.focus()\n      expect(toggleButton).toHaveFocus()\n\n      // Toggle sidebar\n      await user.click(toggleButton)\n\n      // Focus should remain on toggle button\n      expect(toggleButton).toHaveFocus()\n    })\n  })\n\n  describe('Screen Reader Support', () => {\n    it('provides proper ARIA roles and labels', () => {\n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<div>Header Content</div>}\n            sidebar={<nav>Navigation</nav>}\n            footer={<div>Footer Content</div>}\n          >\n            <main>Main Content</main>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      // Check landmark roles\n      expect(screen.getByRole('banner')).toBeInTheDocument()\n      expect(screen.getByRole('navigation')).toBeInTheDocument()\n      expect(screen.getByRole('main')).toBeInTheDocument()\n      expect(screen.getByRole('contentinfo')).toBeInTheDocument()\n    })\n\n    it('announces card state changes', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Dynamic Card\"\n            loading={true}\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Loading state should be announced\n      expect(screen.getByRole('status')).toBeInTheDocument()\n\n      // Change to error state\n      rerender(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Dynamic Card\"\n            error=\"Something went wrong\"\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Error state should be announced\n      expect(screen.getByRole('alert')).toBeInTheDocument()\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument()\n    })\n\n    it('provides descriptive labels for metrics', () => {\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Sales Metrics\"\n            metric={{\n              value: 1234,\n              unit: 'sales',\n              trend: 'up',\n              trendValue: '+12%'\n            }}\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Metric should have proper ARIA labels\n      const metricGroup = screen.getByRole('group')\n      expect(metricGroup).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('1234 sales')\n      )\n\n      // Trend should be properly labeled\n      const trendElement = screen.getByRole('img', { name: /trend/i })\n      expect(trendElement).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('increasing by +12%')\n      )\n    })\n\n    it('provides chart descriptions for screen readers', async () => {\n      render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockData}\n          />\n        </DashboardThemeProvider>\n      )\n\n      await waitFor(() => {\n        const chartContainer = screen.getByRole('application')\n        expect(chartContainer).toBeInTheDocument()\n      })\n\n      const chartContainer = screen.getByRole('application')\n      expect(chartContainer).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('line chart')\n      )\n\n      // Check for descriptive text\n      expect(screen.getByText(/chart with.*dataset/i)).toBeInTheDocument()\n    })\n\n    it('announces filter changes', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <FilterProvider>\n            <DashboardCard\n              title=\"Filterable Card\"\n              onFilter={() => {}}\n            >\n              <button onClick={() => {}}>Apply Filter</button>\n            </DashboardCard>\n          </FilterProvider>\n        </DashboardThemeProvider>\n      )\n\n      const filterButton = screen.getByText('Apply Filter')\n      await user.click(filterButton)\n\n      // Filter changes should be announced (implementation dependent)\n      // This would typically involve a live region update\n    })\n  })\n\n  describe('Focus Management', () => {\n    it('maintains focus within modal dialogs', async () => {\n      const user = userEvent.setup()\n\n      // Mock a modal dialog scenario\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <button>Outside Button</button>\n            <div role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"dialog-title\">\n              <h2 id=\"dialog-title\">Settings Dialog</h2>\n              <button>Dialog Button 1</button>\n              <button>Dialog Button 2</button>\n              <button>Close</button>\n            </div>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      const dialog = screen.getByRole('dialog')\n      const dialogButton1 = screen.getByText('Dialog Button 1')\n      const dialogButton2 = screen.getByText('Dialog Button 2')\n      const closeButton = screen.getByText('Close')\n\n      // Focus should be trapped within dialog\n      dialogButton1.focus()\n      expect(dialogButton1).toHaveFocus()\n\n      await user.tab()\n      expect(dialogButton2).toHaveFocus()\n\n      await user.tab()\n      expect(closeButton).toHaveFocus()\n\n      // Tab from last element should cycle back to first\n      await user.tab()\n      expect(dialogButton1).toHaveFocus()\n    })\n\n    it('restores focus after interactions', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <button>Trigger Button</button>\n            <DashboardCard\n              title=\"Interactive Card\"\n              interactive={true}\n              onClick={() => {}}\n            />\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      const triggerButton = screen.getByText('Trigger Button')\n      const interactiveCard = screen.getByRole('button', { name: /interactive card/i })\n\n      // Focus trigger button\n      triggerButton.focus()\n      expect(triggerButton).toHaveFocus()\n\n      // Tab to interactive card\n      await user.tab()\n      expect(interactiveCard).toHaveFocus()\n\n      // Activate card\n      await user.keyboard('{Enter}')\n\n      // Focus should remain on card after activation\n      expect(interactiveCard).toHaveFocus()\n    })\n\n    it('provides visible focus indicators', () => {\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Focusable Card\"\n            interactive={true}\n            onClick={() => {}}\n          />\n        </DashboardThemeProvider>\n      )\n\n      const card = screen.getByRole('button')\n      card.focus()\n\n      // Card should have focus styles (implementation dependent)\n      expect(card).toHaveClass('focus:outline-none', 'focus:ring-2')\n    })\n  })\n\n  describe('Color Contrast and Visual Accessibility', () => {\n    it('maintains proper contrast in light theme', async () => {\n      const { container } = render(\n        <DashboardThemeProvider defaultTheme=\"light\">\n          <DashboardCard\n            title=\"Light Theme Card\"\n            metric={{\n              value: 100,\n              unit: 'items',\n              trend: 'up',\n              trendValue: '+5%'\n            }}\n          >\n            <p>Card content with text</p>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      // Run accessibility check which includes color contrast\n      const results = await axe(container, {\n        rules: {\n          'color-contrast': { enabled: true }\n        }\n      })\n      expect(results).toHaveNoViolations()\n    })\n\n    it('maintains proper contrast in dark theme', async () => {\n      const { container } = render(\n        <DashboardThemeProvider defaultTheme=\"dark\">\n          <DashboardCard\n            title=\"Dark Theme Card\"\n            metric={{\n              value: 100,\n              unit: 'items',\n              trend: 'down',\n              trendValue: '-3%'\n            }}\n          >\n            <p>Card content with text</p>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      // Run accessibility check which includes color contrast\n      const results = await axe(container, {\n        rules: {\n          'color-contrast': { enabled: true }\n        }\n      })\n      expect(results).toHaveNoViolations()\n    })\n\n    it('provides alternative text for visual elements', () => {\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Visual Card\"\n            icon={({ className }) => (\n              <svg className={className} aria-hidden=\"true\">\n                <circle cx=\"12\" cy=\"12\" r=\"10\" />\n              </svg>\n            )}\n            metric={{\n              value: 75,\n              unit: '%',\n              trend: 'up',\n              trendValue: '+5%'\n            }}\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Icon should be hidden from screen readers\n      const icon = document.querySelector('svg')\n      expect(icon).toHaveAttribute('aria-hidden', 'true')\n\n      // Trend should have descriptive text\n      const trendElement = screen.getByRole('img', { name: /trend/i })\n      expect(trendElement).toHaveAttribute('aria-label', expect.stringContaining('increasing'))\n    })\n  })\n\n  describe('Responsive Accessibility', () => {\n    it('maintains accessibility on mobile layouts', async () => {\n      // Mock mobile viewport\n      Object.defineProperty(window, 'innerWidth', {\n        writable: true,\n        configurable: true,\n        value: 375\n      })\n\n      const { useIsMobile } = require('../mobile/touch-interactions')\n      useIsMobile.mockReturnValue(true)\n\n      const { container } = render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<div>Mobile Header</div>}\n            sidebar={<nav>Mobile Nav</nav>}\n            showMobileNav={true}\n          >\n            <DashboardGrid>\n              <GridItem>\n                <DashboardCard title=\"Mobile Card\">\n                  Mobile content\n                </DashboardCard>\n              </GridItem>\n            </DashboardGrid>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('provides appropriate touch targets on mobile', () => {\n      const { useIsMobile } = require('../mobile/touch-interactions')\n      useIsMobile.mockReturnValue(true)\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Touch Card\"\n            interactive={true}\n            onClick={() => {}}\n          />\n        </DashboardThemeProvider>\n      )\n\n      const card = screen.getByRole('button')\n      \n      // Touch targets should be appropriately sized\n      // This would be tested through computed styles or visual regression testing\n      expect(card).toBeInTheDocument()\n    })\n  })\n\n  describe('Error Accessibility', () => {\n    it('properly announces errors to assistive technology', () => {\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Error Card\"\n            error=\"Network connection failed\"\n          />\n        </DashboardThemeProvider>\n      )\n\n      const errorAlert = screen.getByRole('alert')\n      expect(errorAlert).toBeInTheDocument()\n      expect(errorAlert).toHaveTextContent('Network connection failed')\n    })\n\n    it('provides error recovery options', () => {\n      const onRetry = jest.fn()\n      \n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Recoverable Error\"\n            error=\"Failed to load data\"\n          >\n            <button onClick={onRetry}>Retry</button>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      const retryButton = screen.getByRole('button', { name: /retry/i })\n      expect(retryButton).toBeInTheDocument()\n      expect(retryButton).toBeVisible()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/__tests__/dashboard-infrastructure.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/__tests__/keyboard-navigation-flows.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 499,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 499,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'user' is assigned a value but never used.",
        "line": 560,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 560,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import './setup-accessibility-tests'\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { DashboardLayout } from '../layout/dashboard-layout'\nimport { DashboardCard } from '../cards/dashboard-card'\nimport { DashboardGrid, GridItem } from '../grid/dashboard-grid'\nimport { ChartWrapper } from '../charts/chart-wrapper'\nimport { DashboardThemeProvider } from '../theming/theme-provider'\nimport { FilterProvider } from '../filters/filter-context'\n\n// Mock mobile hooks\njest.mock('../mobile/touch-interactions', () => ({\n  useIsMobile: jest.fn(() => false),\n  useIsTouchDevice: jest.fn(() => false),\n  TouchInteraction: ({ children }: { children: React.ReactNode }) => <div>{children}</div>\n}))\n\ndescribe('Keyboard Navigation Flows', () => {\n  const mockChartData = {\n    datasets: [\n      {\n        label: 'Test Data',\n        data: [\n          { x: 'Jan', y: 100 },\n          { x: 'Feb', y: 150 }\n        ]\n      }\n    ]\n  }\n\n  describe('Dashboard Layout Navigation', () => {\n    it('follows logical tab order through layout regions', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={\n              <div>\n                <button data-testid=\"header-btn-1\">Header Button 1</button>\n                <button data-testid=\"header-btn-2\">Header Button 2</button>\n              </div>\n            }\n            sidebar={\n              <nav>\n                <a href=\"#nav1\" data-testid=\"nav-link-1\">Navigation 1</a>\n                <a href=\"#nav2\" data-testid=\"nav-link-2\">Navigation 2</a>\n              </nav>\n            }\n            footer={\n              <div>\n                <button data-testid=\"footer-btn\">Footer Button</button>\n              </div>\n            }\n          >\n            <main>\n              <button data-testid=\"main-btn\">Main Button</button>\n            </main>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      // Start tabbing through the interface\n      await user.tab()\n      expect(screen.getByTestId('header-btn-1')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('header-btn-2')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('nav-link-1')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('nav-link-2')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('main-btn')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('footer-btn')).toHaveFocus()\n    })\n\n    it('supports reverse tab navigation', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<button data-testid=\"header-btn\">Header</button>}\n            sidebar={<a href=\"#nav\" data-testid=\"nav-link\">Nav</a>}\n          >\n            <button data-testid=\"main-btn\">Main</button>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      // Focus the last element first\n      screen.getByTestId('main-btn').focus()\n      expect(screen.getByTestId('main-btn')).toHaveFocus()\n\n      // Shift+Tab backwards\n      await user.tab({ shift: true })\n      expect(screen.getByTestId('nav-link')).toHaveFocus()\n\n      await user.tab({ shift: true })\n      expect(screen.getByTestId('header-btn')).toHaveFocus()\n    })\n\n    it('handles sidebar toggle with keyboard', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<div>Header</div>}\n            sidebar={<nav data-testid=\"sidebar\">Sidebar Content</nav>}\n          >\n            <main>Main Content</main>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      const toggleButton = screen.getByRole('button', { name: /sidebar/i })\n      \n      // Focus and activate toggle with keyboard\n      toggleButton.focus()\n      expect(toggleButton).toHaveFocus()\n\n      // Toggle with Enter\n      await user.keyboard('{Enter}')\n      expect(toggleButton).toHaveAttribute('aria-expanded', 'false')\n\n      // Toggle with Space\n      await user.keyboard(' ')\n      expect(toggleButton).toHaveAttribute('aria-expanded', 'true')\n    })\n  })\n\n  describe('Card Navigation', () => {\n    it('navigates through multiple cards in grid', async () => {\n      const user = userEvent.setup()\n      const onCard1Click = jest.fn()\n      const onCard2Click = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardGrid>\n            <GridItem>\n              <DashboardCard\n                title=\"Card 1\"\n                interactive={true}\n                onClick={onCard1Click}\n              >\n                <button data-testid=\"card1-btn\">Card 1 Button</button>\n              </DashboardCard>\n            </GridItem>\n            <GridItem>\n              <DashboardCard\n                title=\"Card 2\"\n                interactive={true}\n                onClick={onCard2Click}\n              >\n                <button data-testid=\"card2-btn\">Card 2 Button</button>\n              </DashboardCard>\n            </GridItem>\n          </DashboardGrid>\n        </DashboardThemeProvider>\n      )\n\n      // Tab through cards\n      await user.tab()\n      const card1 = screen.getByRole('button', { name: /card 1/i })\n      expect(card1).toHaveFocus()\n\n      // Activate card 1\n      await user.keyboard('{Enter}')\n      expect(onCard1Click).toHaveBeenCalledTimes(1)\n\n      // Continue to button inside card 1\n      await user.tab()\n      expect(screen.getByTestId('card1-btn')).toHaveFocus()\n\n      // Move to card 2\n      await user.tab()\n      const card2 = screen.getByRole('button', { name: /card 2/i })\n      expect(card2).toHaveFocus()\n\n      // Activate card 2 with Space\n      await user.keyboard(' ')\n      expect(onCard2Click).toHaveBeenCalledTimes(1)\n    })\n\n    it('skips non-interactive cards in tab order', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before\">Before</button>\n            <DashboardCard title=\"Non-interactive Card\">\n              <div>Static content</div>\n            </DashboardCard>\n            <DashboardCard\n              title=\"Interactive Card\"\n              interactive={true}\n              onClick={() => {}}\n            />\n            <button data-testid=\"after\">After</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      await user.tab()\n      expect(screen.getByTestId('before')).toHaveFocus()\n\n      await user.tab()\n      // Should skip non-interactive card and go to interactive card\n      expect(screen.getByRole('button', { name: /interactive card/i })).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('after')).toHaveFocus()\n    })\n\n    it('handles card actions with keyboard', async () => {\n      const user = userEvent.setup()\n      const onAction = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Card with Actions\"\n            actions={\n              <button onClick={onAction} data-testid=\"card-action\">\n                Action\n              </button>\n            }\n          >\n            <div>Card content</div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      // Tab to the action button\n      await user.tab()\n      expect(screen.getByTestId('card-action')).toHaveFocus()\n\n      // Activate action\n      await user.keyboard('{Enter}')\n      expect(onAction).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  describe('Chart Navigation', () => {\n    it('provides keyboard access to chart interactions', async () => {\n      const user = userEvent.setup()\n      const onDataClick = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockChartData}\n            interactive={true}\n            onDataClick={onDataClick}\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Wait for chart to load\n      await user.tab()\n      const chartContainer = screen.getByRole('application')\n      expect(chartContainer).toHaveFocus()\n\n      // Test chart keyboard interactions\n      await user.keyboard('{ArrowRight}')\n      await user.keyboard('{ArrowLeft}')\n      await user.keyboard('{Enter}')\n\n      // Chart should be keyboard accessible\n      expect(chartContainer).toHaveAttribute('tabindex', '0')\n    })\n\n    it('navigates between chart and other elements', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before-chart\">Before Chart</button>\n            <DashboardCard title=\"Chart Card\">\n              <ChartWrapper\n                type=\"line\"\n                data={mockChartData}\n                interactive={true}\n              />\n            </DashboardCard>\n            <button data-testid=\"after-chart\">After Chart</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      await user.tab()\n      expect(screen.getByTestId('before-chart')).toHaveFocus()\n\n      await user.tab()\n      const chartContainer = screen.getByRole('application')\n      expect(chartContainer).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('after-chart')).toHaveFocus()\n    })\n  })\n\n  describe('Filter Navigation', () => {\n    it('navigates through filter controls', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <FilterProvider>\n            <div>\n              <select data-testid=\"filter-select\">\n                <option value=\"all\">All</option>\n                <option value=\"active\">Active</option>\n              </select>\n              <input\n                type=\"text\"\n                placeholder=\"Search...\"\n                data-testid=\"filter-input\"\n              />\n              <button data-testid=\"apply-filter\">Apply</button>\n              <DashboardCard\n                title=\"Filtered Content\"\n                onFilter={() => {}}\n              >\n                <div>Content</div>\n              </DashboardCard>\n            </div>\n          </FilterProvider>\n        </DashboardThemeProvider>\n      )\n\n      // Navigate through filter controls\n      await user.tab()\n      expect(screen.getByTestId('filter-select')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('filter-input')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('apply-filter')).toHaveFocus()\n\n      // Continue to filtered content\n      await user.tab()\n      // Should reach the next focusable element after filters\n    })\n  })\n\n  describe('Error State Navigation', () => {\n    it('maintains keyboard navigation in error states', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before-error\">Before</button>\n            <DashboardCard\n              title=\"Error Card\"\n              error=\"Something went wrong\"\n            >\n              <button data-testid=\"retry-btn\">Retry</button>\n            </DashboardCard>\n            <button data-testid=\"after-error\">After</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      await user.tab()\n      expect(screen.getByTestId('before-error')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('retry-btn')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('after-error')).toHaveFocus()\n    })\n\n    it('announces errors without disrupting navigation', async () => {\n      const user = userEvent.setup()\n\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"focused-btn\">Focused Button</button>\n            <DashboardCard title=\"Dynamic Card\" />\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Focus a button\n      await user.tab()\n      expect(screen.getByTestId('focused-btn')).toHaveFocus()\n\n      // Change card to error state\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"focused-btn\">Focused Button</button>\n            <DashboardCard\n              title=\"Dynamic Card\"\n              error=\"Error occurred\"\n            />\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Focus should remain on the button\n      expect(screen.getByTestId('focused-btn')).toHaveFocus()\n\n      // Error should be announced via alert role\n      expect(screen.getByRole('alert')).toBeInTheDocument()\n    })\n  })\n\n  describe('Loading State Navigation', () => {\n    it('maintains navigation during loading states', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before-loading\">Before</button>\n            <DashboardCard\n              title=\"Loading Card\"\n              loading={true}\n            />\n            <button data-testid=\"after-loading\">After</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      await user.tab()\n      expect(screen.getByTestId('before-loading')).toHaveFocus()\n\n      // Loading card should not be focusable\n      await user.tab()\n      expect(screen.getByTestId('after-loading')).toHaveFocus()\n    })\n\n    it('transitions focus properly when loading completes', async () => {\n      const user = userEvent.setup()\n\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before\">Before</button>\n            <DashboardCard\n              title=\"Transitioning Card\"\n              loading={true}\n            />\n            <button data-testid=\"after\">After</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Focus before element\n      await user.tab()\n      expect(screen.getByTestId('before')).toHaveFocus()\n\n      // Complete loading with interactive card\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before\">Before</button>\n            <DashboardCard\n              title=\"Transitioning Card\"\n              interactive={true}\n              onClick={() => {}}\n            />\n            <button data-testid=\"after\">After</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Now card should be focusable\n      await user.tab()\n      expect(screen.getByRole('button', { name: /transitioning card/i })).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('after')).toHaveFocus()\n    })\n  })\n\n  describe('Responsive Navigation', () => {\n    it('adapts navigation for mobile layout', async () => {\n      const user = userEvent.setup()\n\n      // Mock mobile viewport\n      const { useIsMobile } = require('../mobile/touch-interactions')\n      useIsMobile.mockReturnValue(true)\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardLayout\n            header={<button data-testid=\"mobile-header\">Header</button>}\n            sidebar={<nav>Sidebar</nav>}\n            showMobileNav={true}\n          >\n            <button data-testid=\"mobile-main\">Main</button>\n          </DashboardLayout>\n        </DashboardThemeProvider>\n      )\n\n      // On mobile, sidebar should be hidden, navigation should adapt\n      await user.tab()\n      expect(screen.getByTestId('mobile-header')).toHaveFocus()\n\n      await user.tab()\n      expect(screen.getByTestId('mobile-main')).toHaveFocus()\n\n      // Mobile navigation should be accessible if present\n      // Implementation would depend on mobile navigation structure\n    })\n  })\n\n  describe('Focus Management Edge Cases', () => {\n    it('handles focus when elements are dynamically added/removed', async () => {\n      const user = userEvent.setup()\n\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"persistent\">Persistent Button</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      await user.tab()\n      expect(screen.getByTestId('persistent')).toHaveFocus()\n\n      // Add new focusable element\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"persistent\">Persistent Button</button>\n            <button data-testid=\"new-element\">New Button</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Focus should remain on persistent element\n      expect(screen.getByTestId('persistent')).toHaveFocus()\n\n      // New element should be reachable by tab\n      await user.tab()\n      expect(screen.getByTestId('new-element')).toHaveFocus()\n    })\n\n    it('handles focus when focused element is removed', async () => {\n      const user = userEvent.setup()\n\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before\">Before</button>\n            <button data-testid=\"to-be-removed\">To Be Removed</button>\n            <button data-testid=\"after\">After</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Focus the element that will be removed\n      screen.getByTestId('to-be-removed').focus()\n      expect(screen.getByTestId('to-be-removed')).toHaveFocus()\n\n      // Remove the focused element\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <button data-testid=\"before\">Before</button>\n            <button data-testid=\"after\">After</button>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Focus should move to document body or next logical element\n      // Exact behavior depends on implementation\n      expect(document.activeElement).toBeTruthy()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/__tests__/screen-reader-announcements.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'user' is assigned a value but never used.",
        "line": 141,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 141,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 360,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 360,
        "endColumn": 70
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import './setup-accessibility-tests'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { DashboardCard } from '../cards/dashboard-card'\nimport { ChartWrapper } from '../charts/chart-wrapper'\nimport { DashboardGrid, GridItem } from '../grid/dashboard-grid'\nimport { DashboardThemeProvider } from '../theming/theme-provider'\nimport { FilterProvider } from '../filters/filter-context'\nimport { ScreenReaderAnnouncer } from '../accessibility/screen-reader-announcer'\n\n// Mock mobile hooks\njest.mock('../mobile/touch-interactions', () => ({\n  useIsMobile: jest.fn(() => false),\n  useIsTouchDevice: jest.fn(() => false),\n  TouchInteraction: ({ children }: { children: React.ReactNode }) => <div>{children}</div>\n}))\n\ndescribe('Screen Reader Announcements', () => {\n  const mockChartData = {\n    datasets: [\n      {\n        label: 'Sales Data',\n        data: [\n          { x: 'Jan', y: 100 },\n          { x: 'Feb', y: 150 },\n          { x: 'Mar', y: 120 }\n        ]\n      }\n    ]\n  }\n\n  describe('Card State Announcements', () => {\n    it('announces loading state changes', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <DashboardCard title=\"Dynamic Card\">\n            <div>Initial content</div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      // Change to loading state\n      rerender(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Dynamic Card\"\n            loading={true}\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Loading state should be announced\n      const loadingStatus = screen.getByRole('status')\n      expect(loadingStatus).toBeInTheDocument()\n      expect(loadingStatus).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('Dynamic Card')\n      )\n\n      // Screen reader description should be present\n      const description = screen.getByText(/card is loading/i)\n      expect(description).toBeInTheDocument()\n    })\n\n    it('announces error state changes', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <DashboardCard title=\"Error Card\">\n            <div>Normal content</div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      // Change to error state\n      rerender(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Error Card\"\n            error=\"Network connection failed\"\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Error should be announced via alert role\n      const errorAlert = screen.getByRole('alert')\n      expect(errorAlert).toBeInTheDocument()\n      expect(errorAlert).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('Error Card')\n      )\n\n      // Error description should be present\n      const errorDescription = screen.getByText(/card has an error/i)\n      expect(errorDescription).toBeInTheDocument()\n      expect(screen.getByText('Network connection failed')).toBeInTheDocument()\n    })\n\n    it('announces successful data loading', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Data Card\"\n            loading={true}\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Change to loaded state with data\n      rerender(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Data Card\"\n            metric={{\n              value: 1234,\n              unit: 'users',\n              trend: 'up',\n              trendValue: '+12%'\n            }}\n          >\n            <div>Loaded content</div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      // Metric should have proper ARIA labels\n      const metricGroup = screen.getByRole('group')\n      expect(metricGroup).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('1234 users')\n      )\n\n      // Trend should be announced\n      const trendElement = screen.getByRole('img', { name: /trend/i })\n      expect(trendElement).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('increasing by +12%')\n      )\n    })\n\n    it('provides contextual information for card interactions', async () => {\n      const user = userEvent.setup()\n      const onClick = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Interactive Card\"\n            subtitle=\"Click to view details\"\n            interactive={true}\n            onClick={onClick}\n          >\n            <div>Card content</div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      const card = screen.getByRole('button')\n      \n      // Card should have comprehensive ARIA label\n      expect(card).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('Interactive Card')\n      )\n\n      // Description should explain interactivity\n      const description = screen.getByText(/interactive dashboard card/i)\n      expect(description).toBeInTheDocument()\n\n      // Focus should provide additional context\n      card.focus()\n      expect(card).toHaveFocus()\n    })\n  })\n\n  describe('Chart Announcements', () => {\n    it('provides comprehensive chart descriptions', async () => {\n      render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockChartData}\n          />\n        </DashboardThemeProvider>\n      )\n\n      await waitFor(() => {\n        const chartContainer = screen.getByRole('application')\n        expect(chartContainer).toBeInTheDocument()\n      })\n\n      const chartContainer = screen.getByRole('application')\n      \n      // Chart should have descriptive label\n      expect(chartContainer).toHaveAttribute(\n        'aria-label',\n        expect.stringContaining('line chart showing Sales Data')\n      )\n\n      // Chart description should include data summary\n      const description = screen.getByText(/chart with.*dataset.*data points/i)\n      expect(description).toBeInTheDocument()\n\n      // Instructions for interaction should be provided\n      const instructions = screen.getByText(/interactive chart.*tap.*pinch.*swipe/i)\n      expect(instructions).toBeInTheDocument()\n    })\n\n    it('announces chart data updates', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockChartData}\n          />\n        </DashboardThemeProvider>\n      )\n\n      await waitFor(() => {\n        expect(screen.getByRole('application')).toBeInTheDocument()\n      })\n\n      // Update chart data\n      const updatedData = {\n        datasets: [\n          {\n            label: 'Updated Sales Data',\n            data: [\n              { x: 'Jan', y: 200 },\n              { x: 'Feb', y: 250 },\n              { x: 'Mar', y: 220 },\n              { x: 'Apr', y: 300 }\n            ]\n          }\n        ]\n      }\n\n      rerender(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={updatedData}\n          />\n        </DashboardThemeProvider>\n      )\n\n      await waitFor(() => {\n        const chartContainer = screen.getByRole('application')\n        expect(chartContainer).toHaveAttribute(\n          'aria-label',\n          expect.stringContaining('Updated Sales Data')\n        )\n      })\n\n      // Updated description should reflect new data\n      await waitFor(() => {\n        const description = screen.getByText(/chart with.*dataset.*4 data points/i)\n        expect(description).toBeInTheDocument()\n      })\n    })\n\n    it('announces chart interaction results', async () => {\n      const user = userEvent.setup()\n      const onDataClick = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockChartData}\n            interactive={true}\n            onDataClick={onDataClick}\n          />\n        </DashboardThemeProvider>\n      )\n\n      await waitFor(() => {\n        const chartContainer = screen.getByRole('application')\n        expect(chartContainer).toBeInTheDocument()\n      })\n\n      const chartContainer = screen.getByRole('application')\n      \n      // Focus and interact with chart\n      chartContainer.focus()\n      await user.keyboard('{Enter}')\n\n      // Chart should provide feedback about interactions\n      expect(chartContainer).toHaveAttribute('tabindex', '0')\n    })\n\n    it('handles chart error announcements', async () => {\n      render(\n        <DashboardThemeProvider>\n          <ChartWrapper\n            type=\"line\"\n            data={mockChartData}\n            error=\"Failed to render chart\"\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Error should be announced\n      const errorAlert = screen.getByRole('alert')\n      expect(errorAlert).toBeInTheDocument()\n      expect(errorAlert).toHaveTextContent('Failed to render chart')\n    })\n  })\n\n  describe('Grid and Layout Announcements', () => {\n    it('provides navigation context for grid layouts', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardGrid>\n            <GridItem colSpan={6}>\n              <DashboardCard\n                title=\"Card 1\"\n                interactive={true}\n                onClick={() => {}}\n              />\n            </GridItem>\n            <GridItem colSpan={6}>\n              <DashboardCard\n                title=\"Card 2\"\n                interactive={true}\n                onClick={() => {}}\n              />\n            </GridItem>\n            <GridItem colSpan={12}>\n              <DashboardCard title=\"Full Width Card\" />\n            </GridItem>\n          </DashboardGrid>\n        </DashboardThemeProvider>\n      )\n\n      // Navigate through grid items\n      await user.tab()\n      const card1 = screen.getByRole('button', { name: /card 1/i })\n      expect(card1).toHaveFocus()\n\n      await user.tab()\n      const card2 = screen.getByRole('button', { name: /card 2/i })\n      expect(card2).toHaveFocus()\n\n      // Grid structure should be conveyed through proper markup\n      const grid = screen.getByRole('grid', { hidden: true }) || \n                   document.querySelector('.dashboard-grid')\n      expect(grid).toBeInTheDocument()\n    })\n\n    it('announces responsive layout changes', async () => {\n      // Mock viewport change\n      Object.defineProperty(window, 'innerWidth', {\n        writable: true,\n        configurable: true,\n        value: 600\n      })\n\n      const { useIsMobile } = require('../mobile/touch-interactions')\n      useIsMobile.mockReturnValue(true)\n\n      render(\n        <DashboardThemeProvider>\n          <DashboardGrid>\n            <GridItem colSpan={{ desktop: 4, tablet: 6, mobile: 12 }}>\n              <DashboardCard title=\"Responsive Card\" />\n            </GridItem>\n          </DashboardGrid>\n        </DashboardThemeProvider>\n      )\n\n      // Trigger resize event\n      window.dispatchEvent(new Event('resize'))\n\n      // Layout should adapt and maintain accessibility\n      const card = screen.getByText('Responsive Card')\n      expect(card).toBeInTheDocument()\n    })\n  })\n\n  describe('Filter and Search Announcements', () => {\n    it('announces filter application results', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <FilterProvider>\n            <div>\n              <input\n                type=\"text\"\n                placeholder=\"Search...\"\n                data-testid=\"search-input\"\n                aria-label=\"Search dashboard content\"\n              />\n              <div role=\"region\" aria-live=\"polite\" aria-label=\"Search results\">\n                <DashboardCard title=\"Filtered Result 1\" />\n                <DashboardCard title=\"Filtered Result 2\" />\n              </div>\n            </div>\n          </FilterProvider>\n        </DashboardThemeProvider>\n      )\n\n      const searchInput = screen.getByTestId('search-input')\n      \n      // Type in search\n      await user.type(searchInput, 'result')\n\n      // Results region should be announced\n      const resultsRegion = screen.getByRole('region', { name: /search results/i })\n      expect(resultsRegion).toBeInTheDocument()\n      expect(resultsRegion).toHaveAttribute('aria-live', 'polite')\n    })\n\n    it('announces when no results are found', async () => {\n      const user = userEvent.setup()\n\n      render(\n        <DashboardThemeProvider>\n          <FilterProvider>\n            <div>\n              <input\n                type=\"text\"\n                placeholder=\"Search...\"\n                data-testid=\"search-input\"\n              />\n              <div role=\"region\" aria-live=\"polite\" aria-label=\"Search results\">\n                <p>No results found</p>\n              </div>\n            </div>\n          </FilterProvider>\n        </DashboardThemeProvider>\n      )\n\n      const searchInput = screen.getByTestId('search-input')\n      await user.type(searchInput, 'nonexistent')\n\n      // No results message should be announced\n      const noResults = screen.getByText('No results found')\n      expect(noResults).toBeInTheDocument()\n\n      const resultsRegion = screen.getByRole('region', { name: /search results/i })\n      expect(resultsRegion).toHaveAttribute('aria-live', 'polite')\n    })\n  })\n\n  describe('Status and Progress Announcements', () => {\n    it('announces progress updates', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <div>\n            <div\n              role=\"progressbar\"\n              aria-valuenow={25}\n              aria-valuemin={0}\n              aria-valuemax={100}\n              aria-label=\"Data loading progress\"\n            >\n              25% complete\n            </div>\n            <DashboardCard\n              title=\"Progress Card\"\n              loading={true}\n            />\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Update progress\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <div\n              role=\"progressbar\"\n              aria-valuenow={75}\n              aria-valuemin={0}\n              aria-valuemax={100}\n              aria-label=\"Data loading progress\"\n            >\n              75% complete\n            </div>\n            <DashboardCard\n              title=\"Progress Card\"\n              loading={true}\n            />\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      const progressBar = screen.getByRole('progressbar')\n      expect(progressBar).toHaveAttribute('aria-valuenow', '75')\n      expect(screen.getByText('75% complete')).toBeInTheDocument()\n    })\n\n    it('announces completion status', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Task Card\"\n            loading={true}\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Complete the task\n      rerender(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Task Card\"\n            metric={{\n              value: 'Complete',\n              trend: 'up'\n            }}\n          >\n            <div role=\"status\" aria-live=\"polite\">\n              Task completed successfully\n            </div>\n          </DashboardCard>\n        </DashboardThemeProvider>\n      )\n\n      const completionStatus = screen.getByRole('status')\n      expect(completionStatus).toHaveTextContent('Task completed successfully')\n      expect(completionStatus).toHaveAttribute('aria-live', 'polite')\n    })\n  })\n\n  describe('Dynamic Content Announcements', () => {\n    it('announces when new content is added', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <div>\n            <DashboardCard title=\"Existing Card\" />\n            <div role=\"region\" aria-live=\"polite\" aria-label=\"Dashboard updates\">\n              {/* Updates will be announced here */}\n            </div>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Add new content\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <DashboardCard title=\"Existing Card\" />\n            <DashboardCard title=\"New Card\" />\n            <div role=\"region\" aria-live=\"polite\" aria-label=\"Dashboard updates\">\n              New card added to dashboard\n            </div>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      const updatesRegion = screen.getByRole('region', { name: /dashboard updates/i })\n      expect(updatesRegion).toHaveTextContent('New card added to dashboard')\n    })\n\n    it('announces when content is removed', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <div>\n            <DashboardCard title=\"Card 1\" />\n            <DashboardCard title=\"Card 2\" />\n            <div role=\"region\" aria-live=\"polite\" aria-label=\"Dashboard updates\">\n              {/* Updates will be announced here */}\n            </div>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Remove content\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <DashboardCard title=\"Card 1\" />\n            <div role=\"region\" aria-live=\"polite\" aria-label=\"Dashboard updates\">\n              Card removed from dashboard\n            </div>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      const updatesRegion = screen.getByRole('region', { name: /dashboard updates/i })\n      expect(updatesRegion).toHaveTextContent('Card removed from dashboard')\n    })\n  })\n\n  describe('Error Recovery Announcements', () => {\n    it('announces retry attempts', async () => {\n      const user = userEvent.setup()\n      const onRetry = jest.fn()\n\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <DashboardCard\n              title=\"Failed Card\"\n              error=\"Network error\"\n            >\n              <button onClick={onRetry} data-testid=\"retry-btn\">\n                Retry\n              </button>\n            </DashboardCard>\n            <div role=\"status\" aria-live=\"polite\" aria-label=\"Action feedback\">\n              {/* Retry feedback will be announced here */}\n            </div>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      const retryButton = screen.getByTestId('retry-btn')\n      await user.click(retryButton)\n\n      expect(onRetry).toHaveBeenCalled()\n\n      // Retry attempt should be announced\n      const feedbackRegion = screen.getByRole('status', { name: /action feedback/i })\n      expect(feedbackRegion).toBeInTheDocument()\n    })\n\n    it('announces successful error recovery', async () => {\n      const { rerender } = render(\n        <DashboardThemeProvider>\n          <DashboardCard\n            title=\"Recovery Card\"\n            error=\"Connection failed\"\n          />\n        </DashboardThemeProvider>\n      )\n\n      // Recover from error\n      rerender(\n        <DashboardThemeProvider>\n          <div>\n            <DashboardCard\n              title=\"Recovery Card\"\n              metric={{ value: 'Connected', trend: 'up' }}\n            />\n            <div role=\"status\" aria-live=\"polite\">\n              Connection restored successfully\n            </div>\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      const recoveryStatus = screen.getByRole('status')\n      expect(recoveryStatus).toHaveTextContent('Connection restored successfully')\n    })\n  })\n\n  describe('Screen Reader Announcer Component', () => {\n    it('provides centralized announcement functionality', () => {\n      render(\n        <DashboardThemeProvider>\n          <div>\n            <ScreenReaderAnnouncer />\n            <DashboardCard title=\"Test Card\" />\n          </div>\n        </DashboardThemeProvider>\n      )\n\n      // Screen reader announcer should be present but hidden\n      const announcer = screen.getByRole('status', { hidden: true }) ||\n                       screen.getByRole('log', { hidden: true })\n      expect(announcer).toBeInTheDocument()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/__tests__/setup-accessibility-tests.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/__tests__/aria-labels.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/__tests__/focus-management.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'user' is assigned a value but never used.",
        "line": 204,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 204,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { \n  FocusManagement, \n  useFocusManagement, \n  ModalFocusManager, \n  SkipLinks \n} from '../focus-management'\n\ndescribe('FocusManagement', () => {\n  it('renders children correctly', () => {\n    render(\n      <FocusManagement>\n        <div>Test content</div>\n      </FocusManagement>\n    )\n    \n    expect(screen.getByText('Test content')).toBeInTheDocument()\n  })\n\n  it('sets focus on mount when focusOnMount is true', async () => {\n    render(\n      <FocusManagement focusOnMount>\n        <button>First button</button>\n        <button>Second button</button>\n      </FocusManagement>\n    )\n\n    await waitFor(() => {\n      expect(screen.getByText('First button')).toHaveFocus()\n    })\n  })\n\n  it('sets focus using focusSelector', async () => {\n    render(\n      <FocusManagement focusOnMount focusSelector=\"#target\">\n        <button>First button</button>\n        <button id=\"target\">Target button</button>\n      </FocusManagement>\n    )\n\n    await waitFor(() => {\n      expect(screen.getByText('Target button')).toHaveFocus()\n    })\n  })\n\n  it('sets focus when autoFocus is true', async () => {\n    render(\n      <FocusManagement autoFocus>\n        <input placeholder=\"Test input\" />\n        <button>Test button</button>\n      </FocusManagement>\n    )\n\n    await waitFor(() => {\n      expect(screen.getByPlaceholderText('Test input')).toHaveFocus()\n    })\n  })\n\n  it('restores focus when component unmounts', async () => {\n    const initialButton = document.createElement('button')\n    initialButton.textContent = 'Initial button'\n    document.body.appendChild(initialButton)\n    initialButton.focus()\n\n    const { unmount } = render(\n      <FocusManagement focusOnMount>\n        <button>Test button</button>\n      </FocusManagement>\n    )\n\n    await waitFor(() => {\n      expect(screen.getByText('Test button')).toHaveFocus()\n    })\n\n    unmount()\n    \n    await waitFor(() => {\n      expect(initialButton).toHaveFocus()\n    })\n\n    document.body.removeChild(initialButton)\n  })\n\n  it('ignores disabled elements', async () => {\n    render(\n      <FocusManagement focusOnMount>\n        <button disabled>Disabled button</button>\n        <button>Enabled button</button>\n      </FocusManagement>\n    )\n\n    await waitFor(() => {\n      expect(screen.getByText('Enabled button')).toHaveFocus()\n    })\n  })\n\n  it('ignores hidden elements', async () => {\n    render(\n      <FocusManagement focusOnMount>\n        <button style={{ display: 'none' }}>Hidden button</button>\n        <button>Visible button</button>\n      </FocusManagement>\n    )\n\n    await waitFor(() => {\n      expect(screen.getByText('Visible button')).toHaveFocus()\n    })\n  })\n})\n\ndescribe('useFocusManagement hook', () => {\n  function TestComponent() {\n    const { pushFocus, popFocus, clearFocusHistory, focusFirst, focusLast } = useFocusManagement()\n\n    return (\n      <div>\n        <button onClick={() => pushFocus(document.getElementById('target1') as HTMLElement)}>\n          Push Focus 1\n        </button>\n        <button onClick={() => pushFocus(document.getElementById('target2') as HTMLElement)}>\n          Push Focus 2\n        </button>\n        <button onClick={popFocus}>Pop Focus</button>\n        <button onClick={clearFocusHistory}>Clear History</button>\n        <button onClick={() => focusFirst()}>Focus First</button>\n        <button onClick={() => focusLast()}>Focus Last</button>\n        <button id=\"target1\">Target 1</button>\n        <button id=\"target2\">Target 2</button>\n      </div>\n    )\n  }\n\n  it('pushes and pops focus correctly', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    const pushButton1 = screen.getByText('Push Focus 1')\n    const pushButton2 = screen.getByText('Push Focus 2')\n    const popButton = screen.getByText('Pop Focus')\n    const target1 = screen.getByText('Target 1')\n    const target2 = screen.getByText('Target 2')\n\n    // Push focus to target 1\n    await user.click(pushButton1)\n    expect(target1).toHaveFocus()\n\n    // Push focus to target 2\n    await user.click(pushButton2)\n    expect(target2).toHaveFocus()\n\n    // Pop focus should return to target 1\n    await user.click(popButton)\n    expect(target1).toHaveFocus()\n\n    // Pop focus again should return to push button 2\n    await user.click(popButton)\n    expect(pushButton2).toHaveFocus()\n  })\n\n  it('clears focus history', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    const pushButton1 = screen.getByText('Push Focus 1')\n    const clearButton = screen.getByText('Clear History')\n    const popButton = screen.getByText('Pop Focus')\n    const target1 = screen.getByText('Target 1')\n\n    // Push focus to target 1\n    await user.click(pushButton1)\n    expect(target1).toHaveFocus()\n\n    // Clear history\n    await user.click(clearButton)\n\n    // Pop focus should do nothing since history is cleared\n    await user.click(popButton)\n    expect(clearButton).toHaveFocus() // Should remain on clear button\n  })\n\n  it('focuses first and last elements', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    const focusFirstButton = screen.getByText('Focus First')\n    const focusLastButton = screen.getByText('Focus Last')\n    const firstButton = screen.getByText('Push Focus 1')\n    const lastButton = screen.getByText('Target 2')\n\n    // Focus first element\n    await user.click(focusFirstButton)\n    expect(firstButton).toHaveFocus()\n\n    // Focus last element\n    await user.click(focusLastButton)\n    expect(lastButton).toHaveFocus()\n  })\n})\n\ndescribe('ModalFocusManager', () => {\n  it('manages focus when modal opens and closes', async () => {\n    const user = userEvent.setup()\n    const onClose = jest.fn()\n\n    const initialButton = document.createElement('button')\n    initialButton.textContent = 'Initial button'\n    document.body.appendChild(initialButton)\n    initialButton.focus()\n\n    const { rerender } = render(\n      <ModalFocusManager isOpen={false} onClose={onClose}>\n        <button>Modal button</button>\n      </ModalFocusManager>\n    )\n\n    // Modal should not be rendered when closed\n    expect(screen.queryByText('Modal button')).not.toBeInTheDocument()\n\n    // Open modal\n    rerender(\n      <ModalFocusManager isOpen={true} onClose={onClose}>\n        <button>Modal button</button>\n      </ModalFocusManager>\n    )\n\n    // Modal should be rendered and focused\n    await waitFor(() => {\n      expect(screen.getByText('Modal button')).toHaveFocus()\n    })\n\n    // Close modal\n    rerender(\n      <ModalFocusManager isOpen={false} onClose={onClose}>\n        <button>Modal button</button>\n      </ModalFocusManager>\n    )\n\n    // Focus should be restored to initial button\n    await waitFor(() => {\n      expect(initialButton).toHaveFocus()\n    })\n\n    document.body.removeChild(initialButton)\n  })\n\n  it('calls onClose when escape is pressed', async () => {\n    const user = userEvent.setup()\n    const onClose = jest.fn()\n\n    render(\n      <ModalFocusManager isOpen={true} onClose={onClose}>\n        <button>Modal button</button>\n      </ModalFocusManager>\n    )\n\n    const modalButton = screen.getByText('Modal button')\n    modalButton.focus()\n\n    await user.keyboard('{Escape}')\n    expect(onClose).toHaveBeenCalled()\n  })\n\n  it('sets initial focus using initialFocus selector', async () => {\n    render(\n      <ModalFocusManager isOpen={true} initialFocus=\"#initial\">\n        <button>Other button</button>\n        <button id=\"initial\">Initial button</button>\n      </ModalFocusManager>\n    )\n\n    await waitFor(() => {\n      expect(screen.getByText('Initial button')).toHaveFocus()\n    })\n  })\n\n  it('sets final focus using finalFocus selector', async () => {\n    const finalButton = document.createElement('button')\n    finalButton.id = 'final'\n    finalButton.textContent = 'Final button'\n    document.body.appendChild(finalButton)\n\n    const { rerender } = render(\n      <ModalFocusManager isOpen={true} finalFocus=\"#final\">\n        <button>Modal button</button>\n      </ModalFocusManager>\n    )\n\n    // Close modal\n    rerender(\n      <ModalFocusManager isOpen={false} finalFocus=\"#final\">\n        <button>Modal button</button>\n      </ModalFocusManager>\n    )\n\n    await waitFor(() => {\n      expect(finalButton).toHaveFocus()\n    })\n\n    document.body.removeChild(finalButton)\n  })\n})\n\ndescribe('SkipLinks', () => {\n  it('renders skip links correctly', () => {\n    const links = [\n      { href: '#main', label: 'Skip to main content' },\n      { href: '#nav', label: 'Skip to navigation' }\n    ]\n\n    render(<SkipLinks links={links} />)\n\n    expect(screen.getByText('Skip to main content')).toBeInTheDocument()\n    expect(screen.getByText('Skip to navigation')).toBeInTheDocument()\n  })\n\n  it('handles skip link clicks', async () => {\n    const user = userEvent.setup()\n    \n    // Create target elements\n    const mainElement = document.createElement('main')\n    mainElement.id = 'main'\n    mainElement.tabIndex = -1\n    document.body.appendChild(mainElement)\n\n    const links = [\n      { href: '#main', label: 'Skip to main content' }\n    ]\n\n    render(<SkipLinks links={links} />)\n\n    const skipLink = screen.getByText('Skip to main content')\n    \n    // Mock scrollIntoView\n    const scrollIntoViewMock = jest.fn()\n    mainElement.scrollIntoView = scrollIntoViewMock\n    \n    await user.click(skipLink)\n\n    expect(mainElement).toHaveFocus()\n    expect(scrollIntoViewMock).toHaveBeenCalledWith({ behavior: 'smooth' })\n\n    document.body.removeChild(mainElement)\n  })\n\n  it('applies custom className', () => {\n    const links = [{ href: '#main', label: 'Skip to main' }]\n    \n    render(<SkipLinks links={links} className=\"custom-class\" />)\n    \n    const container = screen.getByText('Skip to main').closest('.skip-links')\n    expect(container).toHaveClass('custom-class')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/__tests__/keyboard-navigation.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'waitFor' is defined but never used.",
        "line": 2,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { KeyboardNavigation, useFocusManagement, FocusTrap } from '../keyboard-navigation'\n\ndescribe('KeyboardNavigation', () => {\n  it('renders children correctly', () => {\n    render(\n      <KeyboardNavigation>\n        <div>Test content</div>\n      </KeyboardNavigation>\n    )\n    \n    expect(screen.getByText('Test content')).toBeInTheDocument()\n  })\n\n  it('renders skip links when provided', () => {\n    const skipLinks = [\n      { href: '#main', label: 'Skip to main content' },\n      { href: '#nav', label: 'Skip to navigation' }\n    ]\n\n    render(\n      <KeyboardNavigation skipLinks={skipLinks}>\n        <div>Content</div>\n      </KeyboardNavigation>\n    )\n\n    // Skip links should be present but visually hidden\n    expect(screen.getByText('Skip to main content')).toBeInTheDocument()\n    expect(screen.getByText('Skip to navigation')).toBeInTheDocument()\n  })\n\n  it('handles escape key when onEscape is provided', async () => {\n    const user = userEvent.setup()\n    const onEscape = jest.fn()\n\n    render(\n      <KeyboardNavigation onEscape={onEscape}>\n        <button>Test button</button>\n      </KeyboardNavigation>\n    )\n\n    const button = screen.getByRole('button')\n    button.focus()\n    \n    await user.keyboard('{Escape}')\n    expect(onEscape).toHaveBeenCalled()\n  })\n\n  it('traps focus when trapFocus is enabled', async () => {\n    const user = userEvent.setup()\n\n    render(\n      <KeyboardNavigation trapFocus>\n        <button>First button</button>\n        <button>Second button</button>\n      </KeyboardNavigation>\n    )\n\n    const firstButton = screen.getByText('First button')\n    const secondButton = screen.getByText('Second button')\n\n    firstButton.focus()\n    expect(firstButton).toHaveFocus()\n\n    // Tab to second button\n    await user.tab()\n    expect(secondButton).toHaveFocus()\n\n    // Tab should wrap to first button\n    await user.tab()\n    expect(firstButton).toHaveFocus()\n\n    // Shift+Tab should go to last button\n    await user.tab({ shift: true })\n    expect(secondButton).toHaveFocus()\n  })\n\n  it('handles chart navigation with arrow keys', async () => {\n    const user = userEvent.setup()\n\n    render(\n      <KeyboardNavigation>\n        <div data-chart-container>\n          <button data-chart-element>Element 1</button>\n          <button data-chart-element>Element 2</button>\n          <button data-chart-element>Element 3</button>\n        </div>\n      </KeyboardNavigation>\n    )\n\n    const firstElement = screen.getByText('Element 1')\n    const secondElement = screen.getByText('Element 2')\n    const thirdElement = screen.getByText('Element 3')\n\n    firstElement.focus()\n    expect(firstElement).toHaveFocus()\n\n    // Arrow right should move to next element\n    await user.keyboard('{ArrowRight}')\n    expect(secondElement).toHaveFocus()\n\n    // Arrow down should also move to next element\n    await user.keyboard('{ArrowDown}')\n    expect(thirdElement).toHaveFocus()\n\n    // Arrow left should move to previous element\n    await user.keyboard('{ArrowLeft}')\n    expect(secondElement).toHaveFocus()\n\n    // Arrow up should also move to previous element\n    await user.keyboard('{ArrowUp}')\n    expect(firstElement).toHaveFocus()\n  })\n\n  it('sets initial focus when initialFocus is provided', () => {\n    render(\n      <KeyboardNavigation initialFocus=\"#target-button\">\n        <button>Other button</button>\n        <button id=\"target-button\">Target button</button>\n      </KeyboardNavigation>\n    )\n\n    expect(screen.getByText('Target button')).toHaveFocus()\n  })\n\n  it('restores focus when restoreFocus is enabled', () => {\n    const initialButton = document.createElement('button')\n    initialButton.textContent = 'Initial button'\n    document.body.appendChild(initialButton)\n    initialButton.focus()\n\n    const { unmount } = render(\n      <KeyboardNavigation restoreFocus>\n        <button>Test button</button>\n      </KeyboardNavigation>\n    )\n\n    // Focus should be on the test button initially\n    expect(screen.getByText('Test button')).toHaveFocus()\n\n    // After unmounting, focus should be restored\n    unmount()\n    expect(initialButton).toHaveFocus()\n\n    document.body.removeChild(initialButton)\n  })\n})\n\ndescribe('useFocusManagement', () => {\n  function TestComponent() {\n    const { setFocus, restoreFocus, moveFocus } = useFocusManagement()\n\n    return (\n      <div>\n        <button onClick={() => setFocus(document.getElementById('target') as HTMLElement)}>\n          Set Focus\n        </button>\n        <button onClick={restoreFocus}>Restore Focus</button>\n        <button onClick={() => moveFocus('next')}>Move Next</button>\n        <button onClick={() => moveFocus('previous')}>Move Previous</button>\n        <button id=\"target\">Target</button>\n      </div>\n    )\n  }\n\n  it('sets focus programmatically', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    const setFocusButton = screen.getByText('Set Focus')\n    const targetButton = screen.getByText('Target')\n\n    await user.click(setFocusButton)\n    expect(targetButton).toHaveFocus()\n  })\n\n  it('moves focus to next element', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    const moveNextButton = screen.getByText('Move Next')\n    const restoreButton = screen.getByText('Restore Focus')\n\n    moveNextButton.focus()\n    await user.click(moveNextButton)\n    expect(restoreButton).toHaveFocus()\n  })\n\n  it('moves focus to previous element', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    const movePreviousButton = screen.getByText('Move Previous')\n    const moveNextButton = screen.getByText('Move Next')\n\n    movePreviousButton.focus()\n    await user.click(movePreviousButton)\n    expect(moveNextButton).toHaveFocus()\n  })\n})\n\ndescribe('FocusTrap', () => {\n  it('traps focus when active', async () => {\n    const user = userEvent.setup()\n\n    render(\n      <FocusTrap active>\n        <button>First</button>\n        <button>Second</button>\n      </FocusTrap>\n    )\n\n    const firstButton = screen.getByText('First')\n    const secondButton = screen.getByText('Second')\n\n    firstButton.focus()\n    expect(firstButton).toHaveFocus()\n\n    await user.tab()\n    expect(secondButton).toHaveFocus()\n\n    await user.tab()\n    expect(firstButton).toHaveFocus()\n  })\n\n  it('does not trap focus when inactive', async () => {\n    const user = userEvent.setup()\n\n    render(\n      <div>\n        <button>Outside</button>\n        <FocusTrap active={false}>\n          <button>Inside</button>\n        </FocusTrap>\n        <button>After</button>\n      </div>\n    )\n\n    const outsideButton = screen.getByText('Outside')\n    const insideButton = screen.getByText('Inside')\n    const afterButton = screen.getByText('After')\n\n    outsideButton.focus()\n    expect(outsideButton).toHaveFocus()\n\n    await user.tab()\n    expect(insideButton).toHaveFocus()\n\n    await user.tab()\n    expect(afterButton).toHaveFocus()\n  })\n\n  it('calls onEscape when escape key is pressed', async () => {\n    const user = userEvent.setup()\n    const onEscape = jest.fn()\n\n    render(\n      <FocusTrap active onEscape={onEscape}>\n        <button>Test</button>\n      </FocusTrap>\n    )\n\n    const button = screen.getByText('Test')\n    button.focus()\n\n    await user.keyboard('{Escape}')\n    expect(onEscape).toHaveBeenCalled()\n  })\n\n  it('sets initial focus when initialFocus is provided', () => {\n    render(\n      <FocusTrap active initialFocus=\"#initial\">\n        <button>Other</button>\n        <button id=\"initial\">Initial</button>\n      </FocusTrap>\n    )\n\n    expect(screen.getByText('Initial')).toHaveFocus()\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/__tests__/screen-reader-announcer.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 17,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 17,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [428, 431], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [428, 431], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 21,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 21,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [513, 516], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [513, 516], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 41,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 41,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1223, 1226], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1223, 1226], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 42,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 42,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1295, 1298], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1295, 1298], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 48,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 48,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1494, 1497], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1494, 1497], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 52,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 52,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1583, 1586], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1583, 1586], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 61,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 61,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1839, 1842], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1839, 1842], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 80,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 80,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2366, 2369], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2366, 2369], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 94,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 94,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2744, 2747], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2744, 2747], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, waitFor, act } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { \n  ScreenReaderAnnouncer, \n  useScreenReaderAnnouncer,\n  DataAnnouncer,\n  ChartAnnouncer,\n  FilterAnnouncer\n} from '../screen-reader-announcer'\n\n// Mock window.announceToScreenReader\nconst mockAnnounce = jest.fn()\n\nbeforeEach(() => {\n  jest.clearAllMocks()\n  ;(window as any).announceToScreenReader = mockAnnounce\n})\n\nafterEach(() => {\n  delete (window as any).announceToScreenReader\n})\n\ndescribe('ScreenReaderAnnouncer', () => {\n  it('renders live regions correctly', () => {\n    render(<ScreenReaderAnnouncer />)\n    \n    // Should have both polite and assertive live regions\n    const politeRegion = document.querySelector('[aria-live=\"polite\"]')\n    const assertiveRegion = document.querySelector('[aria-live=\"assertive\"]')\n    \n    expect(politeRegion).toBeInTheDocument()\n    expect(assertiveRegion).toBeInTheDocument()\n    expect(politeRegion).toHaveAttribute('role', 'status')\n    expect(assertiveRegion).toHaveAttribute('role', 'alert')\n  })\n\n  it('sets up global announce function', () => {\n    render(<ScreenReaderAnnouncer />)\n    \n    expect((window as any).announceToScreenReader).toBeDefined()\n    expect(typeof (window as any).announceToScreenReader).toBe('function')\n  })\n\n  it('cleans up global announce function on unmount', () => {\n    const { unmount } = render(<ScreenReaderAnnouncer />)\n    \n    expect((window as any).announceToScreenReader).toBeDefined()\n    \n    unmount()\n    \n    expect((window as any).announceToScreenReader).toBeUndefined()\n  })\n\n  it('processes announcement queue', async () => {\n    render(<ScreenReaderAnnouncer />)\n    \n    const politeRegion = document.querySelector('[aria-live=\"polite\"]')\n    \n    act(() => {\n      ;(window as any).announceToScreenReader('Test message', 'polite')\n    })\n\n    await waitFor(() => {\n      expect(politeRegion).toHaveTextContent('Test message')\n    })\n\n    // Message should be cleared after processing\n    await waitFor(() => {\n      expect(politeRegion).toHaveTextContent('')\n    }, { timeout: 200 })\n  })\n\n  it('handles assertive announcements', async () => {\n    render(<ScreenReaderAnnouncer />)\n    \n    const assertiveRegion = document.querySelector('[aria-live=\"assertive\"]')\n    \n    act(() => {\n      ;(window as any).announceToScreenReader('Urgent message', 'assertive')\n    })\n\n    await waitFor(() => {\n      expect(assertiveRegion).toHaveTextContent('Urgent message')\n    })\n  })\n\n  it('handles delayed announcements', async () => {\n    render(<ScreenReaderAnnouncer />)\n    \n    const politeRegion = document.querySelector('[aria-live=\"polite\"]')\n    \n    act(() => {\n      ;(window as any).announceToScreenReader('Delayed message', 'polite', 100)\n    })\n\n    // Should not appear immediately\n    expect(politeRegion).toHaveTextContent('')\n\n    // Should appear after delay\n    await waitFor(() => {\n      expect(politeRegion).toHaveTextContent('Delayed message')\n    }, { timeout: 200 })\n  })\n})\n\ndescribe('useScreenReaderAnnouncer', () => {\n  function TestComponent() {\n    const { \n      announce,\n      announcePolite,\n      announceAssertive,\n      announceDataUpdate,\n      announceChartInteraction,\n      announceNavigation,\n      announceFilterChange,\n      announceLoading,\n      announceError\n    } = useScreenReaderAnnouncer()\n\n    return (\n      <div>\n        <button onClick={() => announce('Test message')}>Announce</button>\n        <button onClick={() => announcePolite('Polite message')}>Announce Polite</button>\n        <button onClick={() => announceAssertive('Assertive message')}>Announce Assertive</button>\n        <button onClick={() => announceDataUpdate('chart data', 'updated')}>Data Update</button>\n        <button onClick={() => announceChartInteraction('Selected', 'bar', 100, 'sales chart')}>Chart Interaction</button>\n        <button onClick={() => announceNavigation('dashboard')}>Navigation</button>\n        <button onClick={() => announceFilterChange('status', 'active', 5)}>Filter Change</button>\n        <button onClick={() => announceLoading('data', true)}>Loading</button>\n        <button onClick={() => announceError('Network error', 'API')}>Error</button>\n      </div>\n    )\n  }\n\n  beforeEach(() => {\n    render(<ScreenReaderAnnouncer />)\n  })\n\n  it('announces generic messages', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Announce'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Test message', 'polite', undefined)\n  })\n\n  it('announces polite messages', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Announce Polite'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Polite message', 'polite', undefined)\n  })\n\n  it('announces assertive messages', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Announce Assertive'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Assertive message', 'assertive', undefined)\n  })\n\n  it('announces data updates', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Data Update'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('chart data updated', 'polite')\n  })\n\n  it('announces chart interactions', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Chart Interaction'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Selected bar with value 100 in sales chart', 'polite')\n  })\n\n  it('announces navigation changes', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Navigation'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Navigated to dashboard', 'polite')\n  })\n\n  it('announces filter changes', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Filter Change'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Filter applied: status set to active. Showing 5 results', 'polite')\n  })\n\n  it('announces loading states', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Loading'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Loading data', 'polite')\n  })\n\n  it('announces errors', async () => {\n    const user = userEvent.setup()\n    render(<TestComponent />)\n\n    await user.click(screen.getByText('Error'))\n    \n    expect(mockAnnounce).toHaveBeenCalledWith('Error: Network error in API', 'assertive')\n  })\n})\n\ndescribe('DataAnnouncer', () => {\n  beforeEach(() => {\n    render(<ScreenReaderAnnouncer />)\n  })\n\n  it('announces data loading', () => {\n    const { rerender } = render(\n      <DataAnnouncer data={null} dataType=\"chart\" loading={false}>\n        <div>Content</div>\n      </DataAnnouncer>\n    )\n\n    rerender(\n      <DataAnnouncer data={null} dataType=\"chart\" loading={true}>\n        <div>Content</div>\n      </DataAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('Loading chart', 'polite')\n  })\n\n  it('announces data loaded', () => {\n    const { rerender } = render(\n      <DataAnnouncer data={null} dataType=\"chart\" loading={true}>\n        <div>Content</div>\n      </DataAnnouncer>\n    )\n\n    rerender(\n      <DataAnnouncer data={[1, 2, 3]} dataType=\"chart\" loading={false}>\n        <div>Content</div>\n      </DataAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('chart loaded', 'polite')\n  })\n\n  it('announces data updates', () => {\n    const { rerender } = render(\n      <DataAnnouncer data={[1, 2, 3]} dataType=\"chart\" loading={false}>\n        <div>Content</div>\n      </DataAnnouncer>\n    )\n\n    rerender(\n      <DataAnnouncer data={[1, 2, 3, 4]} dataType=\"chart\" loading={false}>\n        <div>Content</div>\n      </DataAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('chart updated', 'polite')\n  })\n\n  it('announces errors', () => {\n    render(\n      <DataAnnouncer data={null} dataType=\"chart\" error=\"Failed to load\">\n        <div>Content</div>\n      </DataAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('Error: Failed to load in chart', 'assertive')\n  })\n})\n\ndescribe('ChartAnnouncer', () => {\n  beforeEach(() => {\n    render(<ScreenReaderAnnouncer />)\n  })\n\n  it('announces chart element selection', () => {\n    const { rerender } = render(\n      <ChartAnnouncer chartType=\"bar\" data={[]} selectedElement={null}>\n        <div>Chart</div>\n      </ChartAnnouncer>\n    )\n\n    const selectedElement = { type: 'bar', value: 100 }\n    rerender(\n      <ChartAnnouncer chartType=\"bar\" data={[]} selectedElement={selectedElement}>\n        <div>Chart</div>\n      </ChartAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('Selected bar with value 100 in bar chart', 'polite')\n  })\n\n  it('handles different element types', () => {\n    const { rerender } = render(\n      <ChartAnnouncer chartType=\"line\" data={[]} selectedElement={null}>\n        <div>Chart</div>\n      </ChartAnnouncer>\n    )\n\n    const selectedElement = { y: 50, data: 'point data' }\n    rerender(\n      <ChartAnnouncer chartType=\"line\" data={[]} selectedElement={selectedElement}>\n        <div>Chart</div>\n      </ChartAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('Selected element with value 50 in line chart', 'polite')\n  })\n})\n\ndescribe('FilterAnnouncer', () => {\n  beforeEach(() => {\n    render(<ScreenReaderAnnouncer />)\n  })\n\n  it('announces filter changes', () => {\n    const { rerender } = render(\n      <FilterAnnouncer filters={{ status: 'all' }} resultCount={10}>\n        <div>Content</div>\n      </FilterAnnouncer>\n    )\n\n    rerender(\n      <FilterAnnouncer filters={{ status: 'active' }} resultCount={5}>\n        <div>Content</div>\n      </FilterAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('Filter applied: status set to active. Showing 5 results', 'polite')\n  })\n\n  it('handles multiple filter changes', () => {\n    const { rerender } = render(\n      <FilterAnnouncer filters={{ status: 'all', type: 'all' }}>\n        <div>Content</div>\n      </FilterAnnouncer>\n    )\n\n    rerender(\n      <FilterAnnouncer filters={{ status: 'active', type: 'premium' }}>\n        <div>Content</div>\n      </FilterAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('Filter applied: status set to active', 'polite')\n    expect(mockAnnounce).toHaveBeenCalledWith('Filter applied: type set to premium', 'polite')\n  })\n\n  it('announces filter changes without result count', () => {\n    const { rerender } = render(\n      <FilterAnnouncer filters={{ category: 'all' }}>\n        <div>Content</div>\n      </FilterAnnouncer>\n    )\n\n    rerender(\n      <FilterAnnouncer filters={{ category: 'electronics' }}>\n        <div>Content</div>\n      </FilterAnnouncer>\n    )\n\n    expect(mockAnnounce).toHaveBeenCalledWith('Filter applied: category set to electronics', 'polite')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/aria-labels.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 201,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 201,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6098, 6101], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6098, 6101], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 206,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 206,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6232, 6235], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6232, 6235], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 207,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 207,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6288, 6291], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6288, 6291], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 208,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 208,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6368, 6371], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6368, 6371], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 209,
        "column": 80,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 209,
        "endColumn": 83,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6472, 6475], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6472, 6475], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 210,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 210,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6541, 6544], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6541, 6544], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 211,
        "column": 81,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 211,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6632, 6635], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6632, 6635], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 212,
        "column": 81,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 212,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6735, 6738], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6735, 6738], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 213,
        "column": 81,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 213,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6838, 6841], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6838, 6841], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 214,
        "column": 81,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 214,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6941, 6944], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6941, 6944], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 215,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 215,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7041, 7044], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7041, 7044], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 216,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 216,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7140, 7143], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7140, 7143], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 229,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 229,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7435, 7438], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7435, 7438], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useMemo } from 'react'\n\n// Utility functions for generating ARIA labels\nexport const ariaLabels = {\n  // Dashboard card labels\n  card: {\n    interactive: (title: string) => `${title} card, interactive`,\n    loading: (title?: string) => `${title ? `${title} card` : 'Card'} loading`,\n    error: (title?: string, error?: string) => \n      `${title ? `${title} card` : 'Card'} error${error ? `: ${error}` : ''}`,\n    metric: (title: string, value: string | number, unit?: string, trend?: string) => {\n      let label = `${title}: ${value}`\n      if (unit) label += ` ${unit}`\n      if (trend) label += `, trend ${trend}`\n      return label\n    }\n  },\n\n  // Chart labels\n  chart: {\n    container: (type: string, title?: string) => \n      `${type} chart${title ? ` showing ${title}` : ''}`,\n    interactive: (type: string) => \n      `Interactive ${type} chart. Use arrow keys to navigate, Enter to select`,\n    loading: (type: string) => `${type} chart loading`,\n    error: (type: string, error?: string) => \n      `${type} chart error${error ? `: ${error}` : ''}`,\n    noData: (type: string) => `${type} chart with no data available`,\n    element: (type: string, label: string, value: string | number, index: number, total: number) =>\n      `${type} element ${index + 1} of ${total}: ${label}, value ${value}`,\n    legend: (label: string, active: boolean) => \n      `Legend item: ${label}, ${active ? 'active' : 'inactive'}`,\n    axis: (type: 'x' | 'y', label?: string) => \n      `${type.toUpperCase()} axis${label ? `: ${label}` : ''}`\n  },\n\n  // Navigation labels\n  navigation: {\n    main: 'Main navigation',\n    breadcrumb: 'Breadcrumb navigation',\n    pagination: 'Pagination navigation',\n    skip: (target: string) => `Skip to ${target}`,\n    toggle: (expanded: boolean, target: string) => \n      `${expanded ? 'Collapse' : 'Expand'} ${target}`,\n    current: (page: string) => `Current page: ${page}`\n  },\n\n  // Form labels\n  form: {\n    required: (label: string) => `${label}, required`,\n    optional: (label: string) => `${label}, optional`,\n    invalid: (label: string, error: string) => `${label}, invalid: ${error}`,\n    help: (label: string, help: string) => `${label}. ${help}`,\n    search: (placeholder?: string) => \n      `Search${placeholder ? ` ${placeholder}` : ''}`,\n    filter: (type: string, value?: string) => \n      `Filter by ${type}${value ? `, current value: ${value}` : ''}`\n  },\n\n  // Table labels\n  table: {\n    container: (caption?: string, rowCount?: number) => {\n      let label = 'Data table'\n      if (caption) label += `: ${caption}`\n      if (rowCount !== undefined) label += `, ${rowCount} rows`\n      return label\n    },\n    sortable: (column: string, direction?: 'asc' | 'desc') => {\n      let label = `Sort by ${column}`\n      if (direction) {\n        label += `, currently sorted ${direction === 'asc' ? 'ascending' : 'descending'}`\n      }\n      return label\n    },\n    row: (index: number, total: number, selected?: boolean) => {\n      let label = `Row ${index + 1} of ${total}`\n      if (selected) label += ', selected'\n      return label\n    },\n    cell: (content: string, column: string, row: number) => \n      `${column}: ${content}, row ${row + 1}`\n  },\n\n  // Status and feedback labels\n  status: {\n    loading: (content?: string) => `Loading${content ? ` ${content}` : ''}`,\n    success: (message: string) => `Success: ${message}`,\n    error: (message: string) => `Error: ${message}`,\n    warning: (message: string) => `Warning: ${message}`,\n    info: (message: string) => `Information: ${message}`,\n    progress: (current: number, total: number, label?: string) => \n      `${label ? `${label}: ` : ''}${current} of ${total} complete`\n  },\n\n  // Modal and dialog labels\n  modal: {\n    dialog: (title: string) => `${title} dialog`,\n    close: (title?: string) => `Close${title ? ` ${title}` : ''} dialog`,\n    confirm: (action: string) => `Confirm ${action}`,\n    cancel: 'Cancel'\n  },\n\n  // Filter and search labels\n  filter: {\n    applied: (count: number) => `${count} filter${count !== 1 ? 's' : ''} applied`,\n    clear: 'Clear all filters',\n    results: (count: number, total?: number) => {\n      if (total !== undefined) {\n        return `Showing ${count} of ${total} results`\n      }\n      return `${count} result${count !== 1 ? 's' : ''} found`\n    }\n  }\n}\n\n// Hook for generating dynamic ARIA labels\nexport function useAriaLabels() {\n  return useMemo(() => ariaLabels, [])\n}\n\n// Component for providing ARIA descriptions\ninterface AriaDescriptionProps {\n  id: string\n  children: string\n  className?: string\n}\n\nexport function AriaDescription({ id, children, className }: AriaDescriptionProps) {\n  return (\n    <div\n      id={id}\n      className={`sr-only ${className || ''}`}\n      role=\"text\"\n    >\n      {children}\n    </div>\n  )\n}\n\n// Component for live regions\ninterface LiveRegionProps {\n  children: React.ReactNode\n  priority?: 'polite' | 'assertive'\n  atomic?: boolean\n  relevant?: 'additions' | 'removals' | 'text' | 'all'\n  className?: string\n}\n\nexport function LiveRegion({ \n  children, \n  priority = 'polite', \n  atomic = true,\n  relevant = 'all',\n  className \n}: LiveRegionProps) {\n  return (\n    <div\n      className={`sr-only ${className || ''}`}\n      aria-live={priority}\n      aria-atomic={atomic}\n      aria-relevant={relevant}\n      role={priority === 'assertive' ? 'alert' : 'status'}\n    >\n      {children}\n    </div>\n  )\n}\n\n// Component for providing accessible names and descriptions\ninterface AccessibleElementProps {\n  children: React.ReactElement\n  label?: string\n  description?: string\n  labelledBy?: string\n  describedBy?: string\n  role?: string\n  expanded?: boolean\n  selected?: boolean\n  disabled?: boolean\n  required?: boolean\n  invalid?: boolean\n  current?: boolean | 'page' | 'step' | 'location' | 'date' | 'time'\n}\n\nexport function AccessibleElement({\n  children,\n  label,\n  description,\n  labelledBy,\n  describedBy,\n  role,\n  expanded,\n  selected,\n  disabled,\n  required,\n  invalid,\n  current\n}: AccessibleElementProps) {\n  const descriptionId = description ? `${(children.props as any).id || 'element'}-description` : undefined\n\n  return (\n    <>\n      {React.cloneElement(children, {\n        ...(children.props as any),\n        'aria-label': label || (children.props as any)['aria-label'],\n        'aria-labelledby': labelledBy || (children.props as any)['aria-labelledby'],\n        'aria-describedby': describedBy || descriptionId || (children.props as any)['aria-describedby'],\n        'role': role || (children.props as any).role,\n        'aria-expanded': expanded !== undefined ? expanded : (children.props as any)['aria-expanded'],\n        'aria-selected': selected !== undefined ? selected : (children.props as any)['aria-selected'],\n        'aria-disabled': disabled !== undefined ? disabled : (children.props as any)['aria-disabled'],\n        'aria-required': required !== undefined ? required : (children.props as any)['aria-required'],\n        'aria-invalid': invalid !== undefined ? invalid : (children.props as any)['aria-invalid'],\n        'aria-current': current !== undefined ? current : (children.props as any)['aria-current']\n      })}\n      {description && descriptionId && (\n        <AriaDescription id={descriptionId}>\n          {description}\n        </AriaDescription>\n      )}\n    </>\n  )\n}\n\n// Utility for generating chart element ARIA labels\nexport function generateChartAriaLabel(\n  element: any,\n  index: number,\n  total: number,\n  chartType: string\n): string {\n  const { label, value, x, y, data } = element\n  \n  let ariaLabel = `${chartType} element ${index + 1} of ${total}`\n  \n  if (label) {\n    ariaLabel += `: ${label}`\n  }\n  \n  if (value !== undefined) {\n    ariaLabel += `, value ${value}`\n  } else if (y !== undefined) {\n    ariaLabel += `, y value ${y}`\n    if (x !== undefined) {\n      ariaLabel += `, x value ${x}`\n    }\n  } else if (data !== undefined) {\n    ariaLabel += `, data ${data}`\n  }\n  \n  return ariaLabel\n}\n\n// Utility for generating table cell ARIA labels\nexport function generateTableCellAriaLabel(\n  content: string,\n  columnHeader: string,\n  rowIndex: number,\n  columnIndex: number\n): string {\n  return `${columnHeader}: ${content}, row ${rowIndex + 1}, column ${columnIndex + 1}`\n}\n\n// Utility for generating form field ARIA labels\nexport function generateFormFieldAriaLabel(\n  label: string,\n  required?: boolean,\n  invalid?: boolean,\n  errorMessage?: string,\n  helpText?: string\n): string {\n  let ariaLabel = label\n  \n  if (required) {\n    ariaLabel += ', required'\n  }\n  \n  if (invalid && errorMessage) {\n    ariaLabel += `, invalid: ${errorMessage}`\n  }\n  \n  if (helpText) {\n    ariaLabel += `. ${helpText}`\n  }\n  \n  return ariaLabel\n}\n\n// Utility for generating navigation ARIA labels\nexport function generateNavigationAriaLabel(\n  currentPage: string,\n  totalPages?: number,\n  pageIndex?: number\n): string {\n  let ariaLabel = `Current page: ${currentPage}`\n  \n  if (totalPages && pageIndex !== undefined) {\n    ariaLabel += `, page ${pageIndex + 1} of ${totalPages}`\n  }\n  \n  return ariaLabel\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/focus-management.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/keyboard-navigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/accessibility/screen-reader-announcer.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 72,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 72,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2085, 2088], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2085, 2088], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 79,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 79,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2291, 2294], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2291, 2294], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 113,
        "column": 53,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 113,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3160, 3163], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3160, 3163], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 114,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 114,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3209, 3212], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3209, 3212], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 219,
        "column": 9,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 219,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5783, 5786], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5783, 5786], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 266,
        "column": 9,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 266,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6985, 6988], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6985, 6988], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 267,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 267,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7009, 7012], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7009, 7012], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'data' is defined but never used.",
        "line": 273,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 273,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 294,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 294,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7860, 7863], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7860, 7863], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport { useEffect, useRef, useCallback } from 'react'\nimport { cn } from '@/lib/utils'\n\ninterface AnnouncementProps {\n  message: string\n  priority: 'polite' | 'assertive'\n  delay?: number\n}\n\ninterface ScreenReaderAnnouncerProps {\n  className?: string\n}\n\n// Global announcement queue to manage multiple announcements\nconst announcementQueue: AnnouncementProps[] = []\nlet isProcessing = false\n\nexport function ScreenReaderAnnouncer({ className }: ScreenReaderAnnouncerProps) {\n  const politeRef = useRef<HTMLDivElement>(null)\n  const assertiveRef = useRef<HTMLDivElement>(null)\n  const timeoutRef = useRef<NodeJS.Timeout>()\n\n  // Process the announcement queue\n  const processQueue = useCallback(() => {\n    if (isProcessing || announcementQueue.length === 0) return\n\n    isProcessing = true\n    const announcement = announcementQueue.shift()!\n    \n    const targetRef = announcement.priority === 'assertive' ? assertiveRef : politeRef\n    \n    if (targetRef.current) {\n      // Clear previous content\n      targetRef.current.textContent = ''\n      \n      // Add new announcement with optional delay\n      const delay = announcement.delay || 0\n      timeoutRef.current = setTimeout(() => {\n        if (targetRef.current) {\n          targetRef.current.textContent = announcement.message\n          \n          // Clear the message after a short delay to allow for re-announcements\n          setTimeout(() => {\n            if (targetRef.current) {\n              targetRef.current.textContent = ''\n            }\n            isProcessing = false\n            processQueue() // Process next announcement\n          }, 100)\n        }\n      }, delay)\n    } else {\n      isProcessing = false\n      processQueue()\n    }\n  }, [])\n\n  // Set up global announcement function\n  useEffect(() => {\n    // Make announce function globally available\n    const announceFunction = (\n      message: string, \n      priority: 'polite' | 'assertive' = 'polite',\n      delay?: number\n    ) => {\n      announcementQueue.push({ message, priority, delay })\n      processQueue()\n    }\n    \n    ;(window as any).announceToScreenReader = announceFunction\n\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n      // Clean up global function\n      delete (window as any).announceToScreenReader\n    }\n  }, [processQueue])\n\n  return (\n    <div className={cn('screen-reader-announcer', className)}>\n      {/* Polite announcements - won't interrupt current speech */}\n      <div\n        ref={politeRef}\n        className=\"sr-only\"\n        aria-live=\"polite\"\n        aria-atomic=\"true\"\n        role=\"status\"\n      />\n      \n      {/* Assertive announcements - will interrupt current speech */}\n      <div\n        ref={assertiveRef}\n        className=\"sr-only\"\n        aria-live=\"assertive\"\n        aria-atomic=\"true\"\n        role=\"alert\"\n      />\n    </div>\n  )\n}\n\n// Hook for using screen reader announcements\nexport function useScreenReaderAnnouncer() {\n  const announce = useCallback((\n    message: string, \n    priority: 'polite' | 'assertive' = 'polite',\n    delay?: number\n  ) => {\n    if (typeof window !== 'undefined' && (window as any).announceToScreenReader) {\n      ;(window as any).announceToScreenReader(message, priority, delay)\n    }\n  }, [])\n\n  const announcePolite = useCallback((message: string, delay?: number) => {\n    announce(message, 'polite', delay)\n  }, [announce])\n\n  const announceAssertive = useCallback((message: string, delay?: number) => {\n    announce(message, 'assertive', delay)\n  }, [announce])\n\n  // Announce data updates\n  const announceDataUpdate = useCallback((\n    dataType: string, \n    updateType: 'loaded' | 'updated' | 'error' | 'filtered' = 'updated',\n    details?: string\n  ) => {\n    let message = `${dataType} ${updateType}`\n    if (details) {\n      message += `: ${details}`\n    }\n    announce(message, 'polite')\n  }, [announce])\n\n  // Announce chart interactions\n  const announceChartInteraction = useCallback((\n    action: string,\n    element: string,\n    value?: string | number,\n    context?: string\n  ) => {\n    let message = `${action} ${element}`\n    if (value !== undefined) {\n      message += ` with value ${value}`\n    }\n    if (context) {\n      message += ` in ${context}`\n    }\n    announce(message, 'polite')\n  }, [announce])\n\n  // Announce navigation changes\n  const announceNavigation = useCallback((\n    destination: string,\n    context?: string\n  ) => {\n    let message = `Navigated to ${destination}`\n    if (context) {\n      message += ` ${context}`\n    }\n    announce(message, 'polite')\n  }, [announce])\n\n  // Announce filter changes\n  const announceFilterChange = useCallback((\n    filterType: string,\n    filterValue: string,\n    resultCount?: number\n  ) => {\n    let message = `Filter applied: ${filterType} set to ${filterValue}`\n    if (resultCount !== undefined) {\n      message += `. Showing ${resultCount} results`\n    }\n    announce(message, 'polite')\n  }, [announce])\n\n  // Announce loading states\n  const announceLoading = useCallback((\n    content: string,\n    isLoading: boolean\n  ) => {\n    const message = isLoading \n      ? `Loading ${content}` \n      : `${content} loaded`\n    announce(message, 'polite')\n  }, [announce])\n\n  // Announce errors\n  const announceError = useCallback((\n    error: string,\n    context?: string\n  ) => {\n    let message = `Error: ${error}`\n    if (context) {\n      message += ` in ${context}`\n    }\n    announce(message, 'assertive')\n  }, [announce])\n\n  return {\n    announce,\n    announcePolite,\n    announceAssertive,\n    announceDataUpdate,\n    announceChartInteraction,\n    announceNavigation,\n    announceFilterChange,\n    announceLoading,\n    announceError\n  }\n}\n\n// Component for announcing data changes\ninterface DataAnnouncerProps {\n  data: any\n  dataType: string\n  loading?: boolean\n  error?: string\n  children: React.ReactNode\n}\n\nexport function DataAnnouncer({ \n  data, \n  dataType, \n  loading = false, \n  error, \n  children \n}: DataAnnouncerProps) {\n  const { announceDataUpdate, announceLoading, announceError } = useScreenReaderAnnouncer()\n  const previousDataRef = useRef(data)\n  const previousLoadingRef = useRef(loading)\n\n  useEffect(() => {\n    // Announce loading state changes\n    if (loading !== previousLoadingRef.current) {\n      announceLoading(dataType, loading)\n      previousLoadingRef.current = loading\n    }\n\n    // Announce data updates\n    if (!loading && data !== previousDataRef.current) {\n      if (data && !previousDataRef.current) {\n        announceDataUpdate(dataType, 'loaded')\n      } else if (data) {\n        announceDataUpdate(dataType, 'updated')\n      }\n      previousDataRef.current = data\n    }\n\n    // Announce errors\n    if (error) {\n      announceError(error, dataType)\n    }\n  }, [data, dataType, loading, error, announceDataUpdate, announceLoading, announceError])\n\n  return <>{children}</>\n}\n\n// Component for announcing chart interactions\ninterface ChartAnnouncerProps {\n  chartType: string\n  data: any\n  selectedElement?: any\n  children: React.ReactNode\n}\n\nexport function ChartAnnouncer({ \n  chartType, \n  data, \n  selectedElement, \n  children \n}: ChartAnnouncerProps) {\n  const { announceChartInteraction } = useScreenReaderAnnouncer()\n  const previousSelectedRef = useRef(selectedElement)\n\n  useEffect(() => {\n    if (selectedElement && selectedElement !== previousSelectedRef.current) {\n      const elementType = selectedElement.type || 'element'\n      const value = selectedElement.value || selectedElement.y || selectedElement.data\n      announceChartInteraction('Selected', elementType, value, `${chartType} chart`)\n      previousSelectedRef.current = selectedElement\n    }\n  }, [selectedElement, chartType, announceChartInteraction])\n\n  return <>{children}</>\n}\n\n// Component for announcing filter changes\ninterface FilterAnnouncerProps {\n  filters: Record<string, any>\n  resultCount?: number\n  children: React.ReactNode\n}\n\nexport function FilterAnnouncer({ \n  filters, \n  resultCount, \n  children \n}: FilterAnnouncerProps) {\n  const { announceFilterChange } = useScreenReaderAnnouncer()\n  const previousFiltersRef = useRef(filters)\n\n  useEffect(() => {\n    const currentFilters = JSON.stringify(filters)\n    const previousFilters = JSON.stringify(previousFiltersRef.current)\n\n    if (currentFilters !== previousFilters) {\n      // Find which filter changed\n      Object.keys(filters).forEach(key => {\n        if (filters[key] !== previousFiltersRef.current?.[key]) {\n          announceFilterChange(key, String(filters[key]), resultCount)\n        }\n      })\n      previousFiltersRef.current = filters\n    }\n  }, [filters, resultCount, announceFilterChange])\n\n  return <>{children}</>\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/__tests__/chart-card.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 12,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 12,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [461, 464], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [461, 464], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { axe, toHaveNoViolations } from 'jest-axe'\nimport { ChartCard } from '../chart-card'\nimport { BarChart3 } from 'lucide-react'\n\nexpect.extend(toHaveNoViolations)\n\n// Mock ChartWrapper component\njest.mock('../../charts/chart-wrapper', () => ({\n  ChartWrapper: ({ type, data, onDataClick, className }: any) => (\n    <div \n      className={className}\n      data-testid=\"chart-wrapper\"\n      data-chart-type={type}\n      onClick={() => onDataClick?.({ label: 'test-data', x: 1, y: 100 })}\n    >\n      Mock Chart: {type}\n      <div>Data points: {data?.datasets?.[0]?.data?.length || 0}</div>\n    </div>\n  )\n}))\n\ndescribe('ChartCard', () => {\n  const user = userEvent.setup()\n  \n  const mockChartData = {\n    datasets: [\n      {\n        label: 'Test Dataset',\n        data: [\n          { x: 1, y: 100, label: 'Point 1' },\n          { x: 2, y: 200, label: 'Point 2' },\n          { x: 3, y: 150, label: 'Point 3' }\n        ]\n      }\n    ],\n    labels: ['Jan', 'Feb', 'Mar']\n  }\n\n  const mockChartConfig = {\n    colors: {\n      primary: '#3F51B5',\n      secondary: '#B19ADA',\n      accent: '#FF6B35',\n      success: '#10B981',\n      warning: '#F59E0B',\n      error: '#EF4444'\n    },\n    legend: {\n      show: true,\n      position: 'bottom' as const\n    }\n  }\n\n  describe('Basic Rendering', () => {\n    it('renders with title and chart', async () => {\n      render(\n        <ChartCard\n          title=\"Test Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n        />\n      )\n      \n      expect(screen.getByText('Test Chart')).toBeInTheDocument()\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('chart-wrapper')).toBeInTheDocument()\n        expect(screen.getByText('Mock Chart: bar')).toBeInTheDocument()\n      })\n    })\n\n    it('renders with subtitle and icon', async () => {\n      render(\n        <ChartCard\n          title=\"Chart with Icon\"\n          subtitle=\"Test subtitle\"\n          icon={BarChart3}\n          chartType=\"line\"\n          data={mockChartData}\n        />\n      )\n      \n      expect(screen.getByText('Chart with Icon')).toBeInTheDocument()\n      expect(screen.getByText('Test subtitle')).toBeInTheDocument()\n      \n      const icon = document.querySelector('[aria-hidden=\"true\"]')\n      expect(icon).toBeInTheDocument()\n    })\n\n    it('passes chart configuration correctly', async () => {\n      render(\n        <ChartCard\n          title=\"Configured Chart\"\n          chartType=\"pie\"\n          data={mockChartData}\n          chartConfig={mockChartConfig}\n        />\n      )\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('chart-wrapper')).toBeInTheDocument()\n        expect(screen.getByText('Mock Chart: pie')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Actions', () => {\n    it('renders filter button when filterable', () => {\n      render(\n        <ChartCard\n          title=\"Filterable Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          filterable\n        />\n      )\n      \n      const filterButton = screen.getByLabelText('Filter chart data')\n      expect(filterButton).toBeInTheDocument()\n    })\n\n    it('renders export dropdown when exportable', async () => {\n      render(\n        <ChartCard\n          title=\"Exportable Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          exportable\n        />\n      )\n      \n      const exportButton = screen.getByLabelText('Export chart')\n      expect(exportButton).toBeInTheDocument()\n      \n      await user.click(exportButton)\n      \n      expect(screen.getByText('Export as PNG')).toBeInTheDocument()\n      expect(screen.getByText('Export as SVG')).toBeInTheDocument()\n      expect(screen.getByText('Export as PDF')).toBeInTheDocument()\n    })\n\n    it('handles filter button click', async () => {\n      const mockOnFilter = jest.fn()\n      \n      render(\n        <ChartCard\n          title=\"Filterable Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          filterable\n          onFilter={mockOnFilter}\n        />\n      )\n      \n      const filterButton = screen.getByLabelText('Filter chart data')\n      await user.click(filterButton)\n      \n      expect(mockOnFilter).toHaveBeenCalledWith({\n        type: 'string',\n        value: 'chart-filter',\n        operator: 'equals'\n      })\n    })\n\n    it('handles export menu clicks', async () => {\n      const consoleSpy = jest.spyOn(console, 'log').mockImplementation()\n      \n      render(\n        <ChartCard\n          title=\"Exportable Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          exportable\n        />\n      )\n      \n      const exportButton = screen.getByLabelText('Export chart')\n      await user.click(exportButton)\n      \n      const pngOption = screen.getByText('Export as PNG')\n      await user.click(pngOption)\n      \n      expect(consoleSpy).toHaveBeenCalledWith('Exporting chart as png')\n      \n      consoleSpy.mockRestore()\n    })\n\n    it('renders custom actions alongside chart actions', () => {\n      render(\n        <ChartCard\n          title=\"Chart with Actions\"\n          chartType=\"bar\"\n          data={mockChartData}\n          filterable\n          exportable\n          actions={<button>Custom Action</button>}\n        />\n      )\n      \n      expect(screen.getByLabelText('Filter chart data')).toBeInTheDocument()\n      expect(screen.getByLabelText('Export chart')).toBeInTheDocument()\n      expect(screen.getByRole('button', { name: 'Custom Action' })).toBeInTheDocument()\n    })\n  })\n\n  describe('Loading and Error States', () => {\n    it('renders loading skeleton', () => {\n      render(\n        <ChartCard\n          title=\"Loading Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          loading\n        />\n      )\n      \n      // Should show skeleton elements\n      const skeletons = document.querySelectorAll('.animate-pulse')\n      expect(skeletons.length).toBeGreaterThan(0)\n      \n      // Should not show chart\n      expect(screen.queryByTestId('chart-wrapper')).not.toBeInTheDocument()\n    })\n\n    it('renders error state', () => {\n      render(\n        <ChartCard\n          title=\"Error Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          error=\"Failed to load chart data\"\n        />\n      )\n      \n      expect(screen.getByText('Unable to load chart')).toBeInTheDocument()\n      expect(screen.getByText('Failed to load chart data')).toBeInTheDocument()\n      \n      // Should not show chart\n      expect(screen.queryByTestId('chart-wrapper')).not.toBeInTheDocument()\n    })\n\n    it('shows loading spinner while chart component loads', () => {\n      render(\n        <ChartCard\n          title=\"Loading Chart Component\"\n          chartType=\"bar\"\n          data={mockChartData}\n        />\n      )\n      \n      // Chart should be rendered (mocked)\n      expect(screen.getByText('Loading Chart Component')).toBeInTheDocument()\n    })\n  })\n\n  describe('Chart Interaction', () => {\n    it('handles chart data clicks for filtering', async () => {\n      const mockOnFilter = jest.fn()\n      \n      render(\n        <ChartCard\n          title=\"Interactive Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          interactive\n          onFilter={mockOnFilter}\n        />\n      )\n      \n      await waitFor(() => {\n        const chart = screen.getByTestId('chart-wrapper')\n        fireEvent.click(chart)\n      })\n      \n      expect(mockOnFilter).toHaveBeenCalledWith({\n        type: 'string',\n        value: 'test-data',\n        operator: 'equals'\n      })\n    })\n\n    it('does not handle clicks when not interactive', async () => {\n      const mockOnFilter = jest.fn()\n      \n      render(\n        <ChartCard\n          title=\"Non-interactive Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          onFilter={mockOnFilter}\n        />\n      )\n      \n      await waitFor(() => {\n        const chart = screen.getByTestId('chart-wrapper')\n        fireEvent.click(chart)\n      })\n      \n      // onFilter should still be called because chart wrapper handles it\n      expect(mockOnFilter).toHaveBeenCalled()\n    })\n  })\n\n  describe('Chart Types', () => {\n    const chartTypes = ['line', 'bar', 'pie', 'heatmap', 'area', 'scatter'] as const\n    \n    chartTypes.forEach(chartType => {\n      it(`renders ${chartType} chart correctly`, async () => {\n        render(\n          <ChartCard\n            title={`${chartType} Chart`}\n            chartType={chartType}\n            data={mockChartData}\n          />\n        )\n        \n        await waitFor(() => {\n          expect(screen.getByTestId('chart-wrapper')).toHaveAttribute('data-chart-type', chartType)\n          expect(screen.getByText(`Mock Chart: ${chartType}`)).toBeInTheDocument()\n        })\n      })\n    })\n  })\n\n  describe('Custom Content', () => {\n    it('renders additional children content', async () => {\n      render(\n        <ChartCard\n          title=\"Chart with Content\"\n          chartType=\"bar\"\n          data={mockChartData}\n        >\n          <div>Additional chart content</div>\n        </ChartCard>\n      )\n      \n      expect(screen.getByText('Additional chart content')).toBeInTheDocument()\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('meets WCAG accessibility standards', async () => {\n      const { container } = render(\n        <ChartCard\n          title=\"Accessible Chart\"\n          subtitle=\"Chart subtitle\"\n          icon={BarChart3}\n          chartType=\"bar\"\n          data={mockChartData}\n          filterable\n          exportable\n        />\n      )\n      \n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('provides proper ARIA labels for action buttons', () => {\n      render(\n        <ChartCard\n          title=\"Chart with Actions\"\n          chartType=\"bar\"\n          data={mockChartData}\n          filterable\n          exportable\n        />\n      )\n      \n      expect(screen.getByLabelText('Filter chart data')).toBeInTheDocument()\n      expect(screen.getByLabelText('Export chart')).toBeInTheDocument()\n    })\n  })\n\n  describe('Responsive Behavior', () => {\n    it('handles empty data gracefully', async () => {\n      const emptyData = {\n        datasets: [],\n        labels: []\n      }\n      \n      render(\n        <ChartCard\n          title=\"Empty Chart\"\n          chartType=\"bar\"\n          data={emptyData}\n        />\n      )\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('chart-wrapper')).toBeInTheDocument()\n        expect(screen.getByText('Data points: 0')).toBeInTheDocument()\n      })\n    })\n\n    it('applies custom className', () => {\n      render(\n        <ChartCard\n          title=\"Custom Chart\"\n          chartType=\"bar\"\n          data={mockChartData}\n          className=\"custom-chart-class\"\n        />\n      )\n      \n      const card = document.querySelector('.chart-card')\n      expect(card).toHaveClass('custom-chart-class')\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/__tests__/dashboard-card-comprehensive.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/__tests__/dashboard-card.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'waitFor' is defined but never used.",
        "line": 2,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 432,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 432,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12605, 12608], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12605, 12608], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { axe, toHaveNoViolations } from 'jest-axe'\nimport { DashboardCard } from '../dashboard-card'\nimport { Activity, Users } from 'lucide-react'\n\nexpect.extend(toHaveNoViolations)\n\ndescribe('DashboardCard', () => {\n  const user = userEvent.setup()\n\n  describe('Basic Rendering', () => {\n    it('renders with title and subtitle', () => {\n      render(\n        <DashboardCard\n          title=\"Test Card\"\n          subtitle=\"Test subtitle\"\n        />\n      )\n      \n      expect(screen.getByText('Test Card')).toBeInTheDocument()\n      expect(screen.getByText('Test subtitle')).toBeInTheDocument()\n    })\n\n    it('renders with icon', () => {\n      render(\n        <DashboardCard\n          title=\"Test Card\"\n          icon={Activity}\n        />\n      )\n      \n      expect(screen.getByText('Test Card')).toBeInTheDocument()\n      // Icon should be present but hidden from screen readers\n      const icon = document.querySelector('[aria-hidden=\"true\"]')\n      expect(icon).toBeInTheDocument()\n    })\n\n    it('renders with metric data', () => {\n      render(\n        <DashboardCard\n          title=\"Test Card\"\n          metric={{\n            value: 1234,\n            unit: 'users',\n            trend: 'up',\n            trendValue: '+12%'\n          }}\n        />\n      )\n      \n      expect(screen.getByText('1234')).toBeInTheDocument()\n      expect(screen.getByText('users')).toBeInTheDocument()\n      expect(screen.getByText('+12%')).toBeInTheDocument()\n      expect(screen.getByLabelText('Trend: up, +12%')).toBeInTheDocument()\n    })\n\n    it('renders with children content', () => {\n      render(\n        <DashboardCard title=\"Test Card\">\n          <div>Custom content</div>\n        </DashboardCard>\n      )\n      \n      expect(screen.getByText('Custom content')).toBeInTheDocument()\n    })\n\n    it('renders with actions', () => {\n      render(\n        <DashboardCard\n          title=\"Test Card\"\n          actions={<button>Action</button>}\n        />\n      )\n      \n      expect(screen.getByRole('button', { name: 'Action' })).toBeInTheDocument()\n    })\n  })\n\n  describe('Size Variants', () => {\n    it('applies correct size classes', () => {\n      const { rerender } = render(<DashboardCard size=\"sm\" title=\"Small Card\" />)\n      expect(document.querySelector('.dashboard-card-sm')).toBeInTheDocument()\n\n      rerender(<DashboardCard size=\"md\" title=\"Medium Card\" />)\n      expect(document.querySelector('.dashboard-card-md')).toBeInTheDocument()\n\n      rerender(<DashboardCard size=\"lg\" title=\"Large Card\" />)\n      expect(document.querySelector('.dashboard-card-lg')).toBeInTheDocument()\n\n      rerender(<DashboardCard size=\"xl\" title=\"Extra Large Card\" />)\n      expect(document.querySelector('.dashboard-card-xl')).toBeInTheDocument()\n    })\n  })\n\n  describe('Priority Variants', () => {\n    it('applies correct priority classes', () => {\n      const { rerender } = render(<DashboardCard priority=\"low\" title=\"Low Priority\" />)\n      expect(document.querySelector('.dashboard-card-priority-low')).toBeInTheDocument()\n\n      rerender(<DashboardCard priority=\"medium\" title=\"Medium Priority\" />)\n      expect(document.querySelector('.dashboard-card-priority-medium')).toBeInTheDocument()\n\n      rerender(<DashboardCard priority=\"high\" title=\"High Priority\" />)\n      expect(document.querySelector('.dashboard-card-priority-high')).toBeInTheDocument()\n\n      rerender(<DashboardCard priority=\"critical\" title=\"Critical Priority\" />)\n      expect(document.querySelector('.dashboard-card-priority-critical')).toBeInTheDocument()\n    })\n  })\n\n  describe('Loading State', () => {\n    it('renders loading skeleton', () => {\n      render(<DashboardCard loading title=\"Loading Card\" />)\n      \n      expect(screen.getByRole('status')).toBeInTheDocument()\n      expect(screen.getByLabelText('Loading card content')).toBeInTheDocument()\n      \n      // Should show skeleton elements\n      const skeletons = document.querySelectorAll('.animate-pulse')\n      expect(skeletons.length).toBeGreaterThan(0)\n    })\n\n    it('does not render content when loading', () => {\n      render(\n        <DashboardCard\n          loading\n          title=\"Loading Card\"\n          metric={{ value: 100, unit: 'items' }}\n        >\n          <div>Content</div>\n        </DashboardCard>\n      )\n      \n      expect(screen.queryByText('Loading Card')).not.toBeInTheDocument()\n      expect(screen.queryByText('100')).not.toBeInTheDocument()\n      expect(screen.queryByText('Content')).not.toBeInTheDocument()\n    })\n  })\n\n  describe('Error State', () => {\n    it('renders error message', () => {\n      render(<DashboardCard error=\"Something went wrong\" />)\n      \n      expect(screen.getByRole('alert')).toBeInTheDocument()\n      expect(screen.getByLabelText('Card error')).toBeInTheDocument()\n      expect(screen.getByText('Error')).toBeInTheDocument()\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument()\n    })\n\n    it('does not render content when error', () => {\n      render(\n        <DashboardCard\n          error=\"Error occurred\"\n          title=\"Error Card\"\n          metric={{ value: 100, unit: 'items' }}\n        >\n          <div>Content</div>\n        </DashboardCard>\n      )\n      \n      expect(screen.queryByText('Error Card')).not.toBeInTheDocument()\n      expect(screen.queryByText('100')).not.toBeInTheDocument()\n      expect(screen.queryByText('Content')).not.toBeInTheDocument()\n    })\n  })\n\n  describe('Interactive Features', () => {\n    it('handles click events when interactive', async () => {\n      const handleClick = jest.fn()\n      render(\n        <DashboardCard\n          title=\"Interactive Card\"\n          interactive\n          onClick={handleClick}\n        />\n      )\n      \n      const card = screen.getByRole('button')\n      expect(card).toBeInTheDocument()\n      expect(card).toHaveAttribute('aria-label', 'Interactive Card card')\n      \n      await user.click(card)\n      expect(handleClick).toHaveBeenCalledTimes(1)\n    })\n\n    it('handles keyboard navigation when interactive', async () => {\n      const handleClick = jest.fn()\n      render(\n        <DashboardCard\n          title=\"Interactive Card\"\n          interactive\n          onClick={handleClick}\n        />\n      )\n      \n      const card = screen.getByRole('button')\n      \n      // Test Enter key\n      card.focus()\n      await user.keyboard('{Enter}')\n      expect(handleClick).toHaveBeenCalledTimes(1)\n      \n      // Test Space key\n      await user.keyboard(' ')\n      expect(handleClick).toHaveBeenCalledTimes(2)\n    })\n\n    it('does not handle clicks when not interactive', async () => {\n      const handleClick = jest.fn()\n      render(\n        <DashboardCard\n          title=\"Non-interactive Card\"\n          onClick={handleClick}\n        />\n      )\n      \n      const card = document.querySelector('.dashboard-card')\n      expect(card).not.toHaveAttribute('role', 'button')\n      expect(card).not.toHaveAttribute('tabindex')\n      \n      if (card) {\n        await user.click(card)\n      }\n      expect(handleClick).not.toHaveBeenCalled()\n    })\n\n    it('applies interactive styles when interactive', () => {\n      render(\n        <DashboardCard\n          title=\"Interactive Card\"\n          interactive\n          onClick={() => {}}\n        />\n      )\n      \n      const card = screen.getByRole('button')\n      expect(card).toHaveClass('cursor-pointer')\n    })\n  })\n\n  describe('Trend Indicators', () => {\n    it('renders up trend with correct styling', () => {\n      render(\n        <DashboardCard\n          metric={{\n            value: 100,\n            trend: 'up',\n            trendValue: '+5%'\n          }}\n        />\n      )\n      \n      const trendElement = screen.getByLabelText('Trend: up, +5%')\n      expect(trendElement).toHaveClass('bg-green-100', 'text-green-800')\n    })\n\n    it('renders down trend with correct styling', () => {\n      render(\n        <DashboardCard\n          metric={{\n            value: 100,\n            trend: 'down',\n            trendValue: '-3%'\n          }}\n        />\n      )\n      \n      const trendElement = screen.getByLabelText('Trend: down, -3%')\n      expect(trendElement).toHaveClass('bg-red-100', 'text-red-800')\n    })\n\n    it('renders neutral trend with correct styling', () => {\n      render(\n        <DashboardCard\n          metric={{\n            value: 100,\n            trend: 'neutral',\n            trendValue: '0%'\n          }}\n        />\n      )\n      \n      const trendElement = screen.getByLabelText('Trend: neutral, 0%')\n      expect(trendElement).toHaveClass('bg-gray-100', 'text-gray-800')\n    })\n  })\n\n  describe('Custom Styling', () => {\n    it('applies custom className', () => {\n      render(\n        <DashboardCard\n          title=\"Custom Card\"\n          className=\"custom-class\"\n        />\n      )\n      \n      const card = document.querySelector('.dashboard-card')\n      expect(card).toHaveClass('custom-class')\n    })\n\n    it('combines default and custom classes correctly', () => {\n      render(\n        <DashboardCard\n          title=\"Custom Card\"\n          size=\"lg\"\n          priority=\"high\"\n          className=\"custom-class\"\n        />\n      )\n      \n      const card = document.querySelector('.dashboard-card')\n      expect(card).toHaveClass(\n        'dashboard-card',\n        'dashboard-card-lg',\n        'dashboard-card-priority-high',\n        'custom-class'\n      )\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('meets WCAG accessibility standards', async () => {\n      const { container } = render(\n        <DashboardCard\n          title=\"Accessible Card\"\n          subtitle=\"Card subtitle\"\n          icon={Users}\n          metric={{\n            value: 1234,\n            unit: 'users',\n            trend: 'up',\n            trendValue: '+12%'\n          }}\n          interactive\n          onClick={() => {}}\n        >\n          <div>Card content</div>\n        </DashboardCard>\n      )\n      \n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('provides proper ARIA labels for interactive cards', () => {\n      render(\n        <DashboardCard\n          title=\"Interactive Card\"\n          interactive\n          onClick={() => {}}\n        />\n      )\n      \n      const card = screen.getByRole('button')\n      expect(card).toHaveAttribute('aria-label', 'Interactive Card card')\n    })\n\n    it('provides proper ARIA labels for loading state', () => {\n      render(<DashboardCard loading />)\n      \n      expect(screen.getByRole('status')).toBeInTheDocument()\n      expect(screen.getByLabelText('Loading card content')).toBeInTheDocument()\n    })\n\n    it('provides proper ARIA labels for error state', () => {\n      render(<DashboardCard error=\"Test error\" />)\n      \n      expect(screen.getByRole('alert')).toBeInTheDocument()\n      expect(screen.getByLabelText('Card error')).toBeInTheDocument()\n    })\n\n    it('hides decorative icons from screen readers', () => {\n      render(\n        <DashboardCard\n          title=\"Card with Icon\"\n          icon={Activity}\n        />\n      )\n      \n      const icon = document.querySelector('[aria-hidden=\"true\"]')\n      expect(icon).toBeInTheDocument()\n    })\n  })\n\n  describe('Responsive Behavior', () => {\n    it('handles long titles gracefully', () => {\n      render(\n        <DashboardCard\n          title=\"This is a very long title that should be handled gracefully by the component\"\n          subtitle=\"This is also a long subtitle that should truncate properly\"\n        />\n      )\n      \n      const title = screen.getByText(/This is a very long title/)\n      const subtitle = screen.getByText(/This is also a long subtitle/)\n      \n      expect(title).toBeInTheDocument()\n      expect(subtitle).toBeInTheDocument()\n      expect(subtitle).toHaveClass('truncate')\n    })\n\n    it('handles metric values with different types', () => {\n      const { rerender } = render(\n        <DashboardCard\n          metric={{ value: 1234 }}\n        />\n      )\n      expect(screen.getByText('1234')).toBeInTheDocument()\n\n      rerender(\n        <DashboardCard\n          metric={{ value: '1.2K' }}\n        />\n      )\n      expect(screen.getByText('1.2K')).toBeInTheDocument()\n\n      rerender(\n        <DashboardCard\n          metric={{ value: 0 }}\n        />\n      )\n      expect(screen.getByText('0')).toBeInTheDocument()\n    })\n  })\n\n  describe('Performance', () => {\n    it('renders efficiently with minimal re-renders', () => {\n      const renderSpy = jest.fn()\n      \n      function TestCard(props: any) {\n        renderSpy()\n        return <DashboardCard {...props} />\n      }\n      \n      const { rerender } = render(\n        <TestCard title=\"Test Card\" />\n      )\n      \n      expect(renderSpy).toHaveBeenCalledTimes(1)\n      \n      // Re-render with same props should not cause additional renders\n      rerender(<TestCard title=\"Test Card\" />)\n      expect(renderSpy).toHaveBeenCalledTimes(2)\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/__tests__/data-table-card.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'waitFor' is defined but never used.",
        "line": 2,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 27,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 27,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [848, 851], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [848, 851], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 44,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 44,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1356, 1359], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1356, 1359], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 44,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 44,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1366, 1369], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1366, 1369], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { axe, toHaveNoViolations } from 'jest-axe'\nimport { DataTableCard } from '../data-table-card'\nimport { Table } from 'lucide-react'\n\nexpect.extend(toHaveNoViolations)\n\n// Mock URL.createObjectURL and URL.revokeObjectURL for export tests\nglobal.URL.createObjectURL = jest.fn(() => 'mock-url')\nglobal.URL.revokeObjectURL = jest.fn()\n\n// Mock document.createElement for export tests\nconst mockClick = jest.fn()\nconst mockAnchor = {\n  href: '',\n  download: '',\n  click: mockClick\n}\n\n// Store original createElement\nconst originalCreateElement = document.createElement\n\njest.spyOn(document, 'createElement').mockImplementation((tagName) => {\n  if (tagName === 'a') {\n    return mockAnchor as any\n  }\n  return originalCreateElement.call(document, tagName)\n})\n\ndescribe('DataTableCard', () => {\n  const user = userEvent.setup()\n  \n  const mockColumns = [\n    { key: 'id', label: 'ID', sortable: true },\n    { key: 'name', label: 'Name', sortable: true, searchable: true },\n    { key: 'email', label: 'Email', sortable: true, searchable: true },\n    { key: 'status', label: 'Status', sortable: false },\n    { \n      key: 'actions', \n      label: 'Actions', \n      sortable: false,\n      render: (value: any, row: any) => (\n        <button data-testid={`action-${row.id}`}>Edit</button>\n      )\n    }\n  ]\n\n  const mockData = [\n    { id: 1, name: 'John Doe', email: 'john@example.com', status: 'Active' },\n    { id: 2, name: 'Jane Smith', email: 'jane@example.com', status: 'Inactive' },\n    { id: 3, name: 'Bob Johnson', email: 'bob@example.com', status: 'Active' },\n    { id: 4, name: 'Alice Brown', email: 'alice@example.com', status: 'Pending' },\n    { id: 5, name: 'Charlie Wilson', email: 'charlie@example.com', status: 'Active' }\n  ]\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('Basic Rendering', () => {\n    it('renders with title and table data', () => {\n      render(\n        <DataTableCard\n          title=\"User Table\"\n          columns={mockColumns}\n          data={mockData}\n        />\n      )\n      \n      expect(screen.getByText('User Table')).toBeInTheDocument()\n      expect(screen.getByText('John Doe')).toBeInTheDocument()\n      expect(screen.getByText('jane@example.com')).toBeInTheDocument()\n      expect(screen.getByText('Active')).toBeInTheDocument()\n    })\n\n    it('renders with subtitle and icon', () => {\n      render(\n        <DataTableCard\n          title=\"Data Table\"\n          subtitle=\"User management\"\n          icon={Table}\n          columns={mockColumns}\n          data={mockData}\n        />\n      )\n      \n      expect(screen.getByText('Data Table')).toBeInTheDocument()\n      expect(screen.getByText('User management')).toBeInTheDocument()\n      \n      const icon = document.querySelector('[aria-hidden=\"true\"]')\n      expect(icon).toBeInTheDocument()\n    })\n\n    it('renders column headers correctly', () => {\n      render(\n        <DataTableCard\n          title=\"Table Headers\"\n          columns={mockColumns}\n          data={mockData}\n        />\n      )\n      \n      expect(screen.getByText('ID')).toBeInTheDocument()\n      expect(screen.getByText('Name')).toBeInTheDocument()\n      expect(screen.getByText('Email')).toBeInTheDocument()\n      expect(screen.getByText('Status')).toBeInTheDocument()\n      expect(screen.getByText('Actions')).toBeInTheDocument()\n    })\n\n    it('renders custom cell content using render function', () => {\n      render(\n        <DataTableCard\n          title=\"Custom Cells\"\n          columns={mockColumns}\n          data={mockData}\n        />\n      )\n      \n      expect(screen.getByTestId('action-1')).toBeInTheDocument()\n      expect(screen.getByTestId('action-2')).toBeInTheDocument()\n    })\n  })\n\n  describe('Search Functionality', () => {\n    it('renders search input when searchable', () => {\n      render(\n        <DataTableCard\n          title=\"Searchable Table\"\n          columns={mockColumns}\n          data={mockData}\n          searchable\n        />\n      )\n      \n      const searchInput = screen.getByPlaceholderText('Search...')\n      expect(searchInput).toBeInTheDocument()\n    })\n\n    it('filters data based on search term', async () => {\n      render(\n        <DataTableCard\n          title=\"Searchable Table\"\n          columns={mockColumns}\n          data={mockData}\n          searchable\n        />\n      )\n      \n      const searchInput = screen.getByPlaceholderText('Search...')\n      await user.type(searchInput, 'john')\n      \n      expect(screen.getByText('John Doe')).toBeInTheDocument()\n      expect(screen.getByText('Bob Johnson')).toBeInTheDocument()\n      expect(screen.queryByText('Jane Smith')).not.toBeInTheDocument()\n    })\n\n    it('searches across searchable columns only', async () => {\n      render(\n        <DataTableCard\n          title=\"Searchable Table\"\n          columns={mockColumns}\n          data={mockData}\n          searchable\n        />\n      )\n      \n      const searchInput = screen.getByPlaceholderText('Search...')\n      await user.type(searchInput, 'Active')\n      \n      // Should not find results since 'status' column is not marked as searchable\n      expect(screen.getByText('No data available')).toBeInTheDocument()\n    })\n\n    it('does not render search when searchable is false', () => {\n      render(\n        <DataTableCard\n          title=\"Non-searchable Table\"\n          columns={mockColumns}\n          data={mockData}\n          searchable={false}\n        />\n      )\n      \n      expect(screen.queryByPlaceholderText('Search...')).not.toBeInTheDocument()\n    })\n  })\n\n  describe('Sorting Functionality', () => {\n    it('renders sort indicators for sortable columns', () => {\n      render(\n        <DataTableCard\n          title=\"Sortable Table\"\n          columns={mockColumns}\n          data={mockData}\n          sortable\n        />\n      )\n      \n      // Check for sort icons in sortable columns\n      const nameHeader = screen.getByText('Name').closest('th')\n      expect(nameHeader).toHaveClass('cursor-pointer')\n    })\n\n    it('sorts data when column header is clicked', async () => {\n      render(\n        <DataTableCard\n          title=\"Sortable Table\"\n          columns={mockColumns}\n          data={mockData}\n          sortable\n        />\n      )\n      \n      const nameHeader = screen.getByText('Name').closest('th')\n      await user.click(nameHeader!)\n      \n      // Should sort alphabetically - Alice should be first\n      const rows = screen.getAllByRole('row')\n      expect(rows[1]).toHaveTextContent('Alice Brown')\n    })\n\n    it('toggles sort direction on repeated clicks', async () => {\n      render(\n        <DataTableCard\n          title=\"Sortable Table\"\n          columns={mockColumns}\n          data={mockData}\n          sortable\n        />\n      )\n      \n      const nameHeader = screen.getByText('Name').closest('th')\n      \n      // First click - ascending\n      await user.click(nameHeader!)\n      let rows = screen.getAllByRole('row')\n      expect(rows[1]).toHaveTextContent('Alice Brown')\n      \n      // Second click - descending\n      await user.click(nameHeader!)\n      rows = screen.getAllByRole('row')\n      expect(rows[1]).toHaveTextContent('John Doe')\n      \n      // Third click - no sort\n      await user.click(nameHeader!)\n      rows = screen.getAllByRole('row')\n      expect(rows[1]).toHaveTextContent('John Doe') // Back to original order\n    })\n\n    it('does not sort non-sortable columns', async () => {\n      render(\n        <DataTableCard\n          title=\"Mixed Sortable Table\"\n          columns={mockColumns}\n          data={mockData}\n          sortable\n        />\n      )\n      \n      const statusHeader = screen.getByText('Status').closest('th')\n      expect(statusHeader).not.toHaveClass('cursor-pointer')\n    })\n  })\n\n  describe('Pagination', () => {\n    const largeDataset = Array.from({ length: 25 }, (_, i) => ({\n      id: i + 1,\n      name: `User ${i + 1}`,\n      email: `user${i + 1}@example.com`,\n      status: i % 2 === 0 ? 'Active' : 'Inactive'\n    }))\n\n    it('paginates data when dataset is large', () => {\n      render(\n        <DataTableCard\n          title=\"Paginated Table\"\n          columns={mockColumns}\n          data={largeDataset}\n          pageSize={10}\n        />\n      )\n      \n      expect(screen.getByText('User 1')).toBeInTheDocument()\n      expect(screen.getByText('User 10')).toBeInTheDocument()\n      expect(screen.queryByText('User 11')).not.toBeInTheDocument()\n      \n      expect(screen.getByText('Showing 1 to 10 of 25 entries')).toBeInTheDocument()\n      expect(screen.getByText('Page 1 of 3')).toBeInTheDocument()\n    })\n\n    it('navigates between pages', async () => {\n      render(\n        <DataTableCard\n          title=\"Paginated Table\"\n          columns={mockColumns}\n          data={largeDataset}\n          pageSize={10}\n        />\n      )\n      \n      const nextButton = screen.getByText('Next')\n      await user.click(nextButton)\n      \n      expect(screen.getByText('User 11')).toBeInTheDocument()\n      expect(screen.getByText('User 20')).toBeInTheDocument()\n      expect(screen.queryByText('User 1')).not.toBeInTheDocument()\n      \n      expect(screen.getByText('Showing 11 to 20 of 25 entries')).toBeInTheDocument()\n      expect(screen.getByText('Page 2 of 3')).toBeInTheDocument()\n    })\n\n    it('disables navigation buttons appropriately', async () => {\n      render(\n        <DataTableCard\n          title=\"Paginated Table\"\n          columns={mockColumns}\n          data={largeDataset}\n          pageSize={10}\n        />\n      )\n      \n      const prevButton = screen.getByText('Previous')\n      const nextButton = screen.getByText('Next')\n      \n      expect(prevButton).toBeDisabled()\n      expect(nextButton).not.toBeDisabled()\n      \n      // Go to last page\n      await user.click(nextButton)\n      await user.click(nextButton)\n      \n      expect(prevButton).not.toBeDisabled()\n      expect(nextButton).toBeDisabled()\n    })\n  })\n\n  describe('Export Functionality', () => {\n    it('renders export button when exportable', () => {\n      render(\n        <DataTableCard\n          title=\"Exportable Table\"\n          columns={mockColumns}\n          data={mockData}\n          exportable\n        />\n      )\n      \n      const exportButton = screen.getByLabelText('Export table data')\n      expect(exportButton).toBeInTheDocument()\n    })\n\n    it('shows export options when clicked', async () => {\n      render(\n        <DataTableCard\n          title=\"Exportable Table\"\n          columns={mockColumns}\n          data={mockData}\n          exportable\n        />\n      )\n      \n      const exportButton = screen.getByLabelText('Export table data')\n      await user.click(exportButton)\n      \n      expect(screen.getByText('Export as CSV')).toBeInTheDocument()\n      expect(screen.getByText('Export as JSON')).toBeInTheDocument()\n    })\n\n    it('handles CSV export', async () => {\n      render(\n        <DataTableCard\n          title=\"Exportable Table\"\n          columns={mockColumns}\n          data={mockData}\n          exportable\n        />\n      )\n      \n      const exportButton = screen.getByLabelText('Export table data')\n      await user.click(exportButton)\n      \n      const csvOption = screen.getByText('Export as CSV')\n      await user.click(csvOption)\n      \n      expect(mockClick).toHaveBeenCalled()\n      expect(mockAnchor.download).toBe('exportable_table.csv')\n    })\n\n    it('handles JSON export', async () => {\n      render(\n        <DataTableCard\n          title=\"Exportable Table\"\n          columns={mockColumns}\n          data={mockData}\n          exportable\n        />\n      )\n      \n      const exportButton = screen.getByLabelText('Export table data')\n      await user.click(exportButton)\n      \n      const jsonOption = screen.getByText('Export as JSON')\n      await user.click(jsonOption)\n      \n      expect(mockClick).toHaveBeenCalled()\n      expect(mockAnchor.download).toBe('exportable_table.json')\n    })\n\n    it('calls custom export handler when provided', async () => {\n      const mockOnExport = jest.fn()\n      \n      render(\n        <DataTableCard\n          title=\"Custom Export Table\"\n          columns={mockColumns}\n          data={mockData}\n          exportable\n          onExport={mockOnExport}\n        />\n      )\n      \n      const exportButton = screen.getByLabelText('Export table data')\n      await user.click(exportButton)\n      \n      const csvOption = screen.getByText('Export as CSV')\n      await user.click(csvOption)\n      \n      expect(mockOnExport).toHaveBeenCalledWith('csv')\n    })\n  })\n\n  describe('Row Interaction', () => {\n    it('handles row clicks when onRowClick is provided', async () => {\n      const mockOnRowClick = jest.fn()\n      \n      render(\n        <DataTableCard\n          title=\"Interactive Table\"\n          columns={mockColumns}\n          data={mockData}\n          onRowClick={mockOnRowClick}\n        />\n      )\n      \n      const firstRow = screen.getAllByRole('row')[1] // Skip header row\n      await user.click(firstRow)\n      \n      expect(mockOnRowClick).toHaveBeenCalledWith(mockData[0])\n    })\n\n    it('applies hover styles to clickable rows', () => {\n      render(\n        <DataTableCard\n          title=\"Interactive Table\"\n          columns={mockColumns}\n          data={mockData}\n          onRowClick={() => {}}\n        />\n      )\n      \n      const firstRow = screen.getAllByRole('row')[1]\n      expect(firstRow).toHaveClass('cursor-pointer')\n    })\n  })\n\n  describe('Loading and Error States', () => {\n    it('renders loading skeleton', () => {\n      render(\n        <DataTableCard\n          title=\"Loading Table\"\n          columns={mockColumns}\n          data={mockData}\n          loading\n        />\n      )\n      \n      const skeletons = document.querySelectorAll('.animate-pulse')\n      expect(skeletons.length).toBeGreaterThan(0)\n      \n      expect(screen.queryByText('John Doe')).not.toBeInTheDocument()\n    })\n\n    it('renders error state', () => {\n      render(\n        <DataTableCard\n          title=\"Error Table\"\n          columns={mockColumns}\n          data={mockData}\n          error=\"Failed to load table data\"\n        />\n      )\n      \n      expect(screen.getByText('Unable to load table data')).toBeInTheDocument()\n      expect(screen.getByText('Failed to load table data')).toBeInTheDocument()\n      \n      expect(screen.queryByText('John Doe')).not.toBeInTheDocument()\n    })\n\n    it('renders empty state when no data', () => {\n      render(\n        <DataTableCard\n          title=\"Empty Table\"\n          columns={mockColumns}\n          data={[]}\n          emptyMessage=\"No users found\"\n        />\n      )\n      \n      expect(screen.getByText('No users found')).toBeInTheDocument()\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('meets WCAG accessibility standards', async () => {\n      const { container } = render(\n        <DataTableCard\n          title=\"Accessible Table\"\n          subtitle=\"User data\"\n          icon={Table}\n          columns={mockColumns}\n          data={mockData}\n          searchable\n          sortable\n          exportable\n        />\n      )\n      \n      const results = await axe(container)\n      expect(results).toHaveNoViolations()\n    })\n\n    it('provides proper ARIA labels for interactive elements', () => {\n      render(\n        <DataTableCard\n          title=\"Accessible Table\"\n          columns={mockColumns}\n          data={mockData}\n          searchable\n          exportable\n        />\n      )\n      \n      expect(screen.getByLabelText('Export table data')).toBeInTheDocument()\n      expect(screen.getByPlaceholderText('Search...')).toBeInTheDocument()\n    })\n  })\n\n  describe('Custom Styling', () => {\n    it('applies custom className', () => {\n      render(\n        <DataTableCard\n          title=\"Custom Table\"\n          columns={mockColumns}\n          data={mockData}\n          className=\"custom-table-class\"\n        />\n      )\n      \n      const card = document.querySelector('.data-table-card')\n      expect(card).toHaveClass('custom-table-class')\n    })\n\n    it('applies column-specific classes', () => {\n      const columnsWithClasses = [\n        { key: 'id', label: 'ID', className: 'text-center' },\n        { key: 'name', label: 'Name', className: 'font-bold' }\n      ]\n      \n      render(\n        <DataTableCard\n          title=\"Styled Columns\"\n          columns={columnsWithClasses}\n          data={mockData}\n        />\n      )\n      \n      const idHeader = screen.getByText('ID').closest('th')\n      const nameHeader = screen.getByText('Name').closest('th')\n      \n      expect(idHeader).toHaveClass('text-center')\n      expect(nameHeader).toHaveClass('font-bold')\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/__tests__/metric-card.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/chart-card.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/chart-card.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'useCrossCardFiltering' is defined but never used.",
        "line": 6,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'MoreHorizontal' is defined but never used.",
        "line": 7,
        "column": 28,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'DropdownMenuSeparator' is defined but never used.",
        "line": 13,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 13,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { Suspense, useCallback } from 'react'\nimport { cn } from '@/lib/utils'\nimport { DashboardCard } from './dashboard-card'\nimport { FilterableChart } from '../filters/filterable-chart'\nimport { ChartWrapper } from '../charts/chart-wrapper'\nimport { useCrossCardFiltering } from '../filters/filter-synchronizer'\nimport { Download, Filter, MoreHorizontal } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport type { ChartCardProps, ChartDataPoint, LegendItem, FilterValue } from '@/types/dashboard'\n\ninterface EnhancedChartCardProps extends ChartCardProps {\n  // Enhanced filtering props\n  enableCrossCardFiltering?: boolean\n  filterMappings?: {\n    dataClick?: (dataPoint: ChartDataPoint) => Record<string, FilterValue>\n    legendClick?: (legendItem: LegendItem) => Record<string, FilterValue>\n  }\n  // Export props\n  exportFilename?: string\n  onExportStart?: (format: string) => void\n  onExportComplete?: (format: string) => void\n  onExportError?: (error: Error, format: string) => void\n}\n\nexport function ChartCard({\n  title,\n  subtitle,\n  icon,\n  chartType,\n  data,\n  chartConfig,\n  exportable = false,\n  filterable = false,\n  enableCrossCardFiltering = true,\n  filterMappings,\n  exportFilename,\n  onExportStart,\n  onExportComplete,\n  onExportError,\n  children,\n  actions,\n  loading = false,\n  error,\n  className,\n  size = 'md',\n  priority = 'medium',\n  interactive = true,\n  onClick,\n  onFilter,\n}: EnhancedChartCardProps) {\n  // Handle chart data clicks for filtering\n  const handleDataClick = useCallback((dataPoint: ChartDataPoint) => {\n    if (onFilter) {\n      // Create a filter based on the clicked data point\n      const filterValue: FilterValue = {\n        type: 'string',\n        value: dataPoint.label || dataPoint.x?.toString() || '',\n        operator: 'equals'\n      }\n      onFilter(filterValue)\n    }\n  }, [onFilter])\n\n  // Handle legend clicks for filtering\n  const handleLegendClick = useCallback((legendItem: LegendItem) => {\n    if (onFilter) {\n      // Create a filter based on the clicked legend item\n      const filterValue: FilterValue = {\n        type: 'string',\n        value: legendItem.label,\n        operator: 'equals'\n      }\n      onFilter(filterValue)\n    }\n  }, [onFilter])\n\n  const handleExport = (format: 'png' | 'svg' | 'pdf') => {\n    onExportStart?.(format)\n    // TODO: Implement chart export functionality\n    console.log(`Exporting chart as ${format}`)\n    onExportComplete?.(format)\n  }\n\n  const handleFilter = () => {\n    if (onFilter) {\n      // Create a generic filter for the chart\n      onFilter({\n        type: 'string',\n        value: title || 'chart',\n        operator: 'equals'\n      })\n    }\n  }\n\n  const renderChartActions = () => {\n    if (!exportable && !filterable && !actions) return null\n\n    const chartActions = (\n      <div className=\"flex items-center space-x-2\">\n        {filterable && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={handleFilter}\n            className=\"h-8 w-8 p-0\"\n            aria-label=\"Filter chart data\"\n          >\n            <Filter className=\"h-4 w-4\" />\n          </Button>\n        )}\n        \n        {exportable && (\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-8 w-8 p-0\"\n                aria-label=\"Export chart\"\n              >\n                <Download className=\"h-4 w-4\" />\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\">\n              <DropdownMenuItem onClick={() => handleExport('png')}>\n                Export as PNG\n              </DropdownMenuItem>\n              <DropdownMenuItem onClick={() => handleExport('svg')}>\n                Export as SVG\n              </DropdownMenuItem>\n              <DropdownMenuItem onClick={() => handleExport('pdf')}>\n                Export as PDF\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n        )}\n        \n        {actions && (\n          <>\n            {(exportable || filterable) && (\n              <div className=\"w-px h-4 bg-border\" />\n            )}\n            {actions}\n          </>\n        )}\n      </div>\n    )\n\n    return chartActions\n  }\n\n  const renderChart = () => {\n    if (loading) {\n      return (\n        <div className=\"space-y-3\">\n          <Skeleton className=\"h-4 w-full\" />\n          <Skeleton className=\"h-32 w-full\" />\n          <div className=\"flex justify-center space-x-4\">\n            <Skeleton className=\"h-3 w-16\" />\n            <Skeleton className=\"h-3 w-16\" />\n            <Skeleton className=\"h-3 w-16\" />\n          </div>\n        </div>\n      )\n    }\n\n    if (error) {\n      return (\n        <div className=\"flex items-center justify-center h-32 text-muted-foreground\">\n          <div className=\"text-center\">\n            <p className=\"text-sm font-medium\">Unable to load chart</p>\n            <p className=\"text-xs mt-1\">{error}</p>\n          </div>\n        </div>\n      )\n    }\n\n    return (\n      <Suspense\n        fallback={\n          <div className=\"flex items-center justify-center h-32\">\n            <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\"></div>\n          </div>\n        }\n      >\n        {enableCrossCardFiltering ? (\n          <FilterableChart\n            type={chartType}\n            data={data}\n            config={chartConfig}\n            className=\"chart-card-wrapper\"\n            interactive={interactive}\n            exportable={exportable}\n            exportFilename={exportFilename || title || 'chart'}\n            enableFiltering={filterable}\n            filterMappings={filterMappings}\n            onDataClick={handleDataClick}\n            onLegendClick={handleLegendClick}\n            onExportStart={onExportStart}\n            onExportComplete={onExportComplete}\n            onExportError={onExportError}\n          />\n        ) : (\n          <ChartWrapper\n            type={chartType}\n            data={data}\n            config={chartConfig}\n            className=\"chart-card-wrapper\"\n            interactive={interactive}\n            exportable={exportable}\n            exportFilename={exportFilename || title || 'chart'}\n            onDataClick={handleDataClick}\n            onLegendClick={handleLegendClick}\n            onExportStart={onExportStart}\n            onExportComplete={onExportComplete}\n            onExportError={onExportError}\n          />\n        )}\n      </Suspense>\n    )\n  }\n\n  return (\n    <DashboardCard\n      title={title}\n      subtitle={subtitle}\n      icon={icon}\n      actions={renderChartActions()}\n      loading={false} // Handle loading internally\n      error={undefined} // Handle error internally\n      className={cn('chart-card', className)}\n      size={size}\n      priority={priority}\n      interactive={false} // Chart handles its own interactivity\n      onClick={onClick}\n      onFilter={onFilter}\n    >\n      <div className=\"chart-card-content\">\n        {renderChart()}\n        {children}\n      </div>\n    </DashboardCard>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/dashboard-card.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/dashboard-card.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'MobileTooltip' is defined but never used.",
        "line": 9,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'FilterValue' is defined but never used.",
        "line": 10,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 10,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'event' is defined but never used.",
        "line": 75,
        "column": 39,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 75,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'event' is defined but never used.",
        "line": 81,
        "column": 45,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 81,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useCallback } from 'react'\nimport { cn } from '@/lib/utils'\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { AlertCircle, TrendingUp, TrendingDown, Minus } from 'lucide-react'\nimport { useAriaLabels, AriaDescription } from '../accessibility/aria-labels'\nimport { useScreenReaderAnnouncer } from '../accessibility/screen-reader-announcer'\nimport { TouchInteraction, useIsTouchDevice, useIsMobile } from '../mobile/touch-interactions'\nimport { MobileTooltip } from '../mobile/mobile-tooltip'\nimport type { DashboardCardProps, FilterValue } from '@/types/dashboard'\n\nexport function DashboardCard({\n  title,\n  subtitle,\n  icon: Icon,\n  metric,\n  children,\n  actions,\n  loading = false,\n  error,\n  className,\n  size = 'md',\n  priority = 'medium',\n  interactive = false,\n  onClick,\n  onFilter,\n}: DashboardCardProps) {\n  const ariaLabels = useAriaLabels()\n  const { announceError } = useScreenReaderAnnouncer()\n  const isTouchDevice = useIsTouchDevice()\n  const isMobile = useIsMobile()\n  \n  // Generate unique IDs for ARIA relationships\n  const cardId = React.useId()\n  const titleId = `${cardId}-title`\n  const subtitleId = `${cardId}-subtitle`\n  const metricId = `${cardId}-metric`\n  const errorId = `${cardId}-error`\n  const descriptionId = `${cardId}-description`\n  const cardSizeClasses = {\n    sm: 'dashboard-card-sm',\n    md: 'dashboard-card-md',\n    lg: 'dashboard-card-lg',\n    xl: 'dashboard-card-xl',\n  }\n\n  const priorityClasses = {\n    low: 'dashboard-card-priority-low',\n    medium: 'dashboard-card-priority-medium',\n    high: 'dashboard-card-priority-high',\n    critical: 'dashboard-card-priority-critical',\n  }\n\n  const getTrendIcon = (trend: 'up' | 'down' | 'neutral') => {\n    switch (trend) {\n      case 'up':\n        return <TrendingUp className=\"h-3 w-3\" />\n      case 'down':\n        return <TrendingDown className=\"h-3 w-3\" />\n      case 'neutral':\n        return <Minus className=\"h-3 w-3\" />\n      default:\n        return null\n    }\n  }\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (interactive && (event.key === 'Enter' || event.key === ' ')) {\n      event.preventDefault()\n      onClick?.()\n    }\n  }\n\n  // Handle touch interactions\n  const handleTouchTap = useCallback((event: TouchEvent) => {\n    if (interactive && onClick) {\n      onClick()\n    }\n  }, [interactive, onClick])\n\n  const handleTouchLongPress = useCallback((event: TouchEvent) => {\n    if (interactive && onFilter) {\n      // Long press could trigger filter options\n      onFilter({ type: 'string', value: title || 'card' })\n    }\n  }, [interactive, onFilter, title])\n\n  // Generate comprehensive ARIA label\n  const getAriaLabel = () => {\n    if (loading) {\n      return ariaLabels.card.loading(title)\n    }\n    \n    if (error) {\n      return ariaLabels.card.error(title, error)\n    }\n    \n    if (interactive && title) {\n      return ariaLabels.card.interactive(title)\n    }\n    \n    if (metric && title) {\n      return ariaLabels.card.metric(\n        title, \n        metric.value, \n        metric.unit, \n        metric.trend\n      )\n    }\n    \n    return title || 'Dashboard card'\n  }\n\n  // Announce errors to screen readers\n  React.useEffect(() => {\n    if (error) {\n      announceError(error, title ? `${title} card` : 'Dashboard card')\n    }\n  }, [error, title, announceError])\n\n  if (loading) {\n    return (\n      <Card \n        className={cn('dashboard-card', cardSizeClasses[size], className)}\n        role=\"status\"\n        aria-label={getAriaLabel()}\n        aria-describedby={descriptionId}\n      >\n        <AriaDescription id={descriptionId}>\n          {title ? `${title} card is loading` : 'Card content is loading'}\n        </AriaDescription>\n        <CardHeader className=\"dashboard-card-header\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center space-x-2\">\n              <Skeleton className=\"h-5 w-5 rounded\" />\n              <div className=\"space-y-2\">\n                <Skeleton className=\"h-4 w-24\" />\n                <Skeleton className=\"h-3 w-16\" />\n              </div>\n            </div>\n            <Skeleton className=\"h-8 w-8 rounded\" />\n          </div>\n        </CardHeader>\n        <CardContent className=\"dashboard-card-content\">\n          <div className=\"space-y-3\">\n            <div className=\"flex items-baseline space-x-2\">\n              <Skeleton className=\"h-8 w-16\" />\n              <Skeleton className=\"h-4 w-8\" />\n              <Skeleton className=\"h-6 w-12 rounded-full\" />\n            </div>\n            <Skeleton className=\"h-20 w-full rounded\" />\n          </div>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  if (error) {\n    return (\n      <Card \n        className={cn(\n          'dashboard-card border-red-200 bg-red-50 dark:bg-red-950/20', \n          cardSizeClasses[size], \n          className\n        )}\n        role=\"alert\"\n        aria-label={getAriaLabel()}\n        aria-describedby={errorId}\n      >\n        <AriaDescription id={errorId}>\n          {title ? `${title} card has an error: ${error}` : `Card error: ${error}`}\n        </AriaDescription>\n        <CardContent className=\"dashboard-card-content\">\n          <div className=\"flex items-center space-x-2 text-red-600 dark:text-red-400\">\n            <AlertCircle className=\"h-4 w-4 flex-shrink-0\" />\n            <span className=\"text-sm font-medium\">Error</span>\n          </div>\n          <p className=\"text-sm text-red-600 dark:text-red-400 mt-2\">{error}</p>\n        </CardContent>\n      </Card>\n    )\n  }\n\n  const cardContent = (\n    <Card\n      className={cn(\n        'dashboard-card',\n        cardSizeClasses[size],\n        priorityClasses[priority],\n        interactive && [\n          'cursor-pointer hover:shadow-md focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2',\n          'transition-all duration-200 ease-out',\n          // Adjust hover effects for touch devices\n          !isTouchDevice && 'hover:scale-[1.02]',\n          // Touch-specific styles\n          isTouchDevice && 'active:scale-[0.98] active:shadow-lg',\n        ],\n        // Mobile-specific optimizations\n        isMobile && [\n          'mb-4', // Add bottom margin for mobile stacking\n          'mx-2', // Add horizontal margin for mobile\n        ],\n        className\n      )}\n      onClick={interactive && !isTouchDevice ? onClick : undefined}\n      onKeyDown={interactive ? handleKeyDown : undefined}\n      tabIndex={interactive ? 0 : undefined}\n      role={interactive ? 'button' : 'region'}\n      aria-label={getAriaLabel()}\n      aria-labelledby={title ? titleId : undefined}\n      aria-describedby={subtitle ? subtitleId : descriptionId}\n    >\n      <AriaDescription id={descriptionId}>\n        {interactive \n          ? 'Interactive dashboard card. Press Enter or Space to activate.'\n          : 'Dashboard card with information display.'\n        }\n      </AriaDescription>\n      {(title || subtitle || Icon || actions) && (\n        <CardHeader className=\"dashboard-card-header\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center space-x-2\">\n              {Icon && (\n                <Icon \n                  className=\"h-5 w-5 text-muted-foreground flex-shrink-0\" \n                  aria-hidden=\"true\"\n                />\n              )}\n              <div className=\"min-w-0 flex-1\">\n                {title && (\n                  <CardTitle \n                    id={titleId}\n                    className=\"dashboard-card-title text-base font-semibold leading-tight\"\n                  >\n                    {title}\n                  </CardTitle>\n                )}\n                {subtitle && (\n                  <p \n                    id={subtitleId}\n                    className=\"dashboard-card-subtitle text-sm text-muted-foreground mt-1 truncate\"\n                  >\n                    {subtitle}\n                  </p>\n                )}\n              </div>\n            </div>\n            {actions && (\n              <div className=\"dashboard-card-actions flex-shrink-0\">\n                {actions}\n              </div>\n            )}\n          </div>\n        </CardHeader>\n      )}\n      \n      <CardContent className=\"dashboard-card-content\">\n        {metric && (\n          <div \n            id={metricId}\n            className=\"dashboard-card-metric mb-4\"\n            role=\"group\"\n            aria-label={ariaLabels.card.metric(\n              title || 'Metric', \n              metric.value, \n              metric.unit, \n              metric.trend\n            )}\n          >\n            <div className=\"flex items-baseline space-x-2 flex-wrap\">\n              <span \n                className=\"text-2xl font-bold text-foreground\"\n                aria-label={`Value: ${metric.value}${metric.unit ? ` ${metric.unit}` : ''}`}\n              >\n                {metric.value}\n              </span>\n              {metric.unit && (\n                <span \n                  className=\"text-sm text-muted-foreground\"\n                  aria-label={`Unit: ${metric.unit}`}\n                >\n                  {metric.unit}\n                </span>\n              )}\n              {metric.trend && metric.trendValue && (\n                <span\n                  className={cn(\n                    'inline-flex items-center gap-1 text-xs px-2 py-1 rounded-full font-medium',\n                    metric.trend === 'up' && 'bg-green-100 text-green-800 dark:bg-green-900/20 dark:text-green-400',\n                    metric.trend === 'down' && 'bg-red-100 text-red-800 dark:bg-red-900/20 dark:text-red-400',\n                    metric.trend === 'neutral' && 'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300'\n                  )}\n                  role=\"img\"\n                  aria-label={`Trend: ${metric.trend === 'up' ? 'increasing' : metric.trend === 'down' ? 'decreasing' : 'stable'} by ${metric.trendValue}`}\n                >\n                  {getTrendIcon(metric.trend)}\n                  <span aria-hidden=\"true\">{metric.trendValue}</span>\n                </span>\n              )}\n            </div>\n          </div>\n        )}\n        {children}\n      </CardContent>\n    </Card>\n  )\n\n  // Wrap with touch interactions for touch devices\n  if (interactive && isTouchDevice) {\n    return (\n      <TouchInteraction\n        onTap={handleTouchTap}\n        onLongPress={handleTouchLongPress}\n        className=\"dashboard-card-touch-wrapper\"\n      >\n        {cardContent}\n      </TouchInteraction>\n    )\n  }\n\n  return cardContent\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/data-table-card.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'DropdownMenuSeparator' is defined but never used.",
        "line": 18,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 18,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'MoreHorizontal' is defined but never used.",
        "line": 26,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 26,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 37,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 37,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [843, 846], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [843, 846], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 37,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 37,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [853, 856], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [853, 856], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 43,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 43,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [965, 968], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [965, 968], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useMemo } from 'react'\nimport { cn } from '@/lib/utils'\nimport { DashboardCard } from './dashboard-card'\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table'\nimport { Button } from '@/components/ui/button'\nimport { Input } from '@/components/ui/input'\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu'\nimport {\n  ChevronUp,\n  ChevronDown,\n  Search,\n  Download,\n  MoreHorizontal,\n  ArrowUpDown,\n} from 'lucide-react'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport type { DashboardCardProps } from '@/types/dashboard'\n\ninterface DataTableColumn {\n  key: string\n  label: string\n  sortable?: boolean\n  searchable?: boolean\n  render?: (value: any, row: any) => React.ReactNode\n  className?: string\n}\n\ninterface DataTableRow {\n  id: string | number\n  [key: string]: any\n}\n\ninterface DataTableCardProps extends Omit<DashboardCardProps, 'metric'> {\n  columns: DataTableColumn[]\n  data: DataTableRow[]\n  searchable?: boolean\n  sortable?: boolean\n  exportable?: boolean\n  pageSize?: number\n  emptyMessage?: string\n  onRowClick?: (row: DataTableRow) => void\n  onExport?: (format: 'csv' | 'json') => void\n}\n\ntype SortDirection = 'asc' | 'desc' | null\n\nexport function DataTableCard({\n  title,\n  subtitle,\n  icon,\n  columns,\n  data,\n  searchable = true,\n  sortable = true,\n  exportable = false,\n  pageSize = 10,\n  emptyMessage = 'No data available',\n  children,\n  actions,\n  loading = false,\n  error,\n  className,\n  size = 'md',\n  priority = 'medium',\n  interactive = false,\n  onClick,\n  onFilter,\n  onRowClick,\n  onExport,\n}: DataTableCardProps) {\n  const [searchTerm, setSearchTerm] = useState('')\n  const [sortColumn, setSortColumn] = useState<string | null>(null)\n  const [sortDirection, setSortDirection] = useState<SortDirection>(null)\n  const [currentPage, setCurrentPage] = useState(1)\n\n  // Filter and sort data\n  const processedData = useMemo(() => {\n    let filtered = data\n\n    // Apply search filter\n    if (searchTerm && searchable) {\n      const searchableColumns = columns.filter(col => col.searchable !== false)\n      filtered = data.filter(row =>\n        searchableColumns.some(col =>\n          String(row[col.key]).toLowerCase().includes(searchTerm.toLowerCase())\n        )\n      )\n    }\n\n    // Apply sorting\n    if (sortColumn && sortDirection && sortable) {\n      filtered = [...filtered].sort((a, b) => {\n        const aValue = a[sortColumn]\n        const bValue = b[sortColumn]\n        \n        if (aValue === bValue) return 0\n        \n        const comparison = aValue < bValue ? -1 : 1\n        return sortDirection === 'asc' ? comparison : -comparison\n      })\n    }\n\n    return filtered\n  }, [data, searchTerm, sortColumn, sortDirection, columns, searchable, sortable])\n\n  // Paginate data\n  const paginatedData = useMemo(() => {\n    const startIndex = (currentPage - 1) * pageSize\n    return processedData.slice(startIndex, startIndex + pageSize)\n  }, [processedData, currentPage, pageSize])\n\n  const totalPages = Math.ceil(processedData.length / pageSize)\n\n  const handleSort = (columnKey: string) => {\n    if (!sortable) return\n    \n    const column = columns.find(col => col.key === columnKey)\n    if (!column?.sortable) return\n\n    if (sortColumn === columnKey) {\n      setSortDirection(prev => \n        prev === 'asc' ? 'desc' : prev === 'desc' ? null : 'asc'\n      )\n      if (sortDirection === 'desc') {\n        setSortColumn(null)\n      }\n    } else {\n      setSortColumn(columnKey)\n      setSortDirection('asc')\n    }\n  }\n\n  const handleExport = (format: 'csv' | 'json') => {\n    if (onExport) {\n      onExport(format)\n    } else {\n      // Default export implementation\n      const dataToExport = processedData\n      const filename = `${title?.replace(/\\s+/g, '_').toLowerCase() || 'data'}.${format}`\n      \n      if (format === 'csv') {\n        const headers = columns.map(col => col.label).join(',')\n        const rows = dataToExport.map(row =>\n          columns.map(col => `\"${row[col.key] || ''}\"`).join(',')\n        ).join('\\n')\n        const csv = `${headers}\\n${rows}`\n        \n        const blob = new Blob([csv], { type: 'text/csv' })\n        const url = URL.createObjectURL(blob)\n        const a = document.createElement('a')\n        a.href = url\n        a.download = filename\n        a.click()\n        URL.revokeObjectURL(url)\n      } else if (format === 'json') {\n        const json = JSON.stringify(dataToExport, null, 2)\n        const blob = new Blob([json], { type: 'application/json' })\n        const url = URL.createObjectURL(blob)\n        const a = document.createElement('a')\n        a.href = url\n        a.download = filename\n        a.click()\n        URL.revokeObjectURL(url)\n      }\n    }\n  }\n\n  const renderTableActions = () => {\n    const tableActions = (\n      <div className=\"flex items-center space-x-2\">\n        {searchable && (\n          <div className=\"relative\">\n            <Search className=\"absolute left-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n            <Input\n              placeholder=\"Search...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              className=\"pl-8 h-8 w-32\"\n            />\n          </div>\n        )}\n        \n        {exportable && (\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-8 w-8 p-0\"\n                aria-label=\"Export table data\"\n              >\n                <Download className=\"h-4 w-4\" />\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\">\n              <DropdownMenuItem onClick={() => handleExport('csv')}>\n                Export as CSV\n              </DropdownMenuItem>\n              <DropdownMenuItem onClick={() => handleExport('json')}>\n                Export as JSON\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n        )}\n        \n        {actions && (\n          <>\n            {(searchable || exportable) && (\n              <div className=\"w-px h-4 bg-border\" />\n            )}\n            {actions}\n          </>\n        )}\n      </div>\n    )\n\n    return tableActions\n  }\n\n  const renderTable = () => {\n    if (loading) {\n      return (\n        <div className=\"space-y-3\">\n          <div className=\"flex space-x-4\">\n            {columns.map((col, index) => (\n              <Skeleton key={index} className=\"h-4 flex-1\" />\n            ))}\n          </div>\n          {Array.from({ length: 5 }).map((_, index) => (\n            <div key={index} className=\"flex space-x-4\">\n              {columns.map((col, colIndex) => (\n                <Skeleton key={colIndex} className=\"h-4 flex-1\" />\n              ))}\n            </div>\n          ))}\n        </div>\n      )\n    }\n\n    if (error) {\n      return (\n        <div className=\"flex items-center justify-center h-32 text-muted-foreground\">\n          <div className=\"text-center\">\n            <p className=\"text-sm font-medium\">Unable to load table data</p>\n            <p className=\"text-xs mt-1\">{error}</p>\n          </div>\n        </div>\n      )\n    }\n\n    if (paginatedData.length === 0) {\n      return (\n        <div className=\"flex items-center justify-center h-32 text-muted-foreground\">\n          <p className=\"text-sm\">{emptyMessage}</p>\n        </div>\n      )\n    }\n\n    return (\n      <div className=\"space-y-4\">\n        <div className=\"rounded-md border\">\n          <Table>\n            <TableHeader>\n              <TableRow>\n                {columns.map((column) => (\n                  <TableHead\n                    key={column.key}\n                    className={cn(\n                      column.className,\n                      sortable && column.sortable !== false && 'cursor-pointer hover:bg-muted/50'\n                    )}\n                    onClick={() => handleSort(column.key)}\n                  >\n                    <div className=\"flex items-center space-x-1\">\n                      <span>{column.label}</span>\n                      {sortable && column.sortable !== false && (\n                        <div className=\"flex flex-col\">\n                          {sortColumn === column.key ? (\n                            sortDirection === 'asc' ? (\n                              <ChevronUp className=\"h-3 w-3\" />\n                            ) : sortDirection === 'desc' ? (\n                              <ChevronDown className=\"h-3 w-3\" />\n                            ) : (\n                              <ArrowUpDown className=\"h-3 w-3 opacity-50\" />\n                            )\n                          ) : (\n                            <ArrowUpDown className=\"h-3 w-3 opacity-50\" />\n                          )}\n                        </div>\n                      )}\n                    </div>\n                  </TableHead>\n                ))}\n              </TableRow>\n            </TableHeader>\n            <TableBody>\n              {paginatedData.map((row) => (\n                <TableRow\n                  key={row.id}\n                  className={cn(\n                    onRowClick && 'cursor-pointer hover:bg-muted/50'\n                  )}\n                  onClick={() => onRowClick?.(row)}\n                >\n                  {columns.map((column) => (\n                    <TableCell\n                      key={column.key}\n                      className={column.className}\n                    >\n                      {column.render\n                        ? column.render(row[column.key], row)\n                        : row[column.key]\n                      }\n                    </TableCell>\n                  ))}\n                </TableRow>\n              ))}\n            </TableBody>\n          </Table>\n        </div>\n\n        {totalPages > 1 && (\n          <div className=\"flex items-center justify-between\">\n            <p className=\"text-sm text-muted-foreground\">\n              Showing {((currentPage - 1) * pageSize) + 1} to{' '}\n              {Math.min(currentPage * pageSize, processedData.length)} of{' '}\n              {processedData.length} entries\n            </p>\n            <div className=\"flex items-center space-x-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}\n                disabled={currentPage === 1}\n              >\n                Previous\n              </Button>\n              <span className=\"text-sm\">\n                Page {currentPage} of {totalPages}\n              </span>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}\n                disabled={currentPage === totalPages}\n              >\n                Next\n              </Button>\n            </div>\n          </div>\n        )}\n      </div>\n    )\n  }\n\n  return (\n    <DashboardCard\n      title={title}\n      subtitle={subtitle}\n      icon={icon}\n      actions={renderTableActions()}\n      loading={false} // Handle loading internally\n      error={undefined} // Handle error internally\n      className={cn('data-table-card', className)}\n      size={size}\n      priority={priority}\n      interactive={interactive}\n      onClick={onClick}\n      onFilter={onFilter}\n    >\n      <div className=\"data-table-content\">\n        {renderTable()}\n        {children}\n      </div>\n    </DashboardCard>\n  )\n}\n\nexport type { DataTableColumn, DataTableRow, DataTableCardProps }",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/metric-card.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/cards/metric-card.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/__tests__/chart-config-system.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 121,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 121,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3838, 3841], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3838, 3841], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { renderHook, act } from '@testing-library/react'\nimport {\n  ChartConfigBuilder,\n  ChartConfigUtils,\n  useChartConfig,\n  CHART_THEMES,\n  CHART_PRESETS,\n} from '../chart-config-system'\n\ndescribe('ChartConfigBuilder', () => {\n  it('creates a builder with default configuration', () => {\n    const builder = new ChartConfigBuilder()\n    const config = builder.build()\n\n    expect(config.colors.primary).toBe('#3F51B5')\n    expect(config.legend.show).toBe(true)\n    expect(config.tooltip.show).toBe(true)\n    expect(config.animations.enabled).toBe(true)\n  })\n\n  it('creates a builder with base configuration', () => {\n    const baseConfig = {\n      colors: { primary: '#FF0000' },\n      legend: { show: false },\n    }\n\n    const builder = new ChartConfigBuilder(baseConfig)\n    const config = builder.build()\n\n    expect(config.colors.primary).toBe('#FF0000')\n    expect(config.legend.show).toBe(false)\n  })\n\n  it('applies theme correctly', () => {\n    const builder = new ChartConfigBuilder()\n    const config = builder.withTheme('dark').build()\n\n    expect(config.colors.primary).toBe(CHART_THEMES.dark.colors.primary)\n    expect(config.colors.secondary).toBe(CHART_THEMES.dark.colors.secondary)\n  })\n\n  it('applies preset correctly', () => {\n    const builder = new ChartConfigBuilder()\n    const config = builder.withPreset('pie').build()\n\n    expect(config.legend.position).toBe('right')\n    expect(config.animations.duration).toBe(500)\n  })\n\n  it('chains configuration methods', () => {\n    const builder = new ChartConfigBuilder()\n    const config = builder\n      .withTheme('vibrant')\n      .withPreset('bar')\n      .withColors({ primary: '#CUSTOM' })\n      .withLegend({ show: false })\n      .withTooltip({ show: false })\n      .withAxes({ x: { show: false } })\n      .withAnimations({ enabled: false })\n      .build()\n\n    expect(config.colors.primary).toBe('#CUSTOM')\n    expect(config.legend.show).toBe(false)\n    expect(config.tooltip.show).toBe(false)\n    expect(config.axes.x.show).toBe(false)\n    expect(config.animations.enabled).toBe(false)\n  })\n\n  it('preserves colors when applying preset', () => {\n    const builder = new ChartConfigBuilder()\n    const config = builder\n      .withTheme('dark')\n      .withPreset('line')\n      .build()\n\n    expect(config.colors.primary).toBe(CHART_THEMES.dark.colors.primary)\n    expect(config.legend.position).toBe('bottom') // From preset\n  })\n})\n\ndescribe('ChartConfigUtils', () => {\n  it('creates a builder', () => {\n    const builder = ChartConfigUtils.builder()\n    expect(builder).toBeInstanceOf(ChartConfigBuilder)\n  })\n\n  it('gets theme palette', () => {\n    const palette = ChartConfigUtils.getThemePalette('vibrant')\n    expect(palette).toEqual(CHART_THEMES.vibrant.palette)\n  })\n\n  it('creates quick configuration', () => {\n    const config = ChartConfigUtils.quickConfig('pie', 'minimal')\n    \n    expect(config.colors.primary).toBe(CHART_THEMES.minimal.colors.primary)\n    expect(config.legend.position).toBe('right') // From pie preset\n    expect(config.animations.duration).toBe(500) // From pie preset\n  })\n\n  it('merges multiple configurations', () => {\n    const config1 = { colors: { primary: '#FF0000' } }\n    const config2 = { legend: { show: false } }\n    const config3 = { tooltip: { show: false } }\n\n    const merged = ChartConfigUtils.merge(config1, config2, config3)\n\n    expect(merged.colors.primary).toBe('#FF0000')\n    expect(merged.legend.show).toBe(false)\n    expect(merged.tooltip.show).toBe(false)\n  })\n\n  it('validates configuration', () => {\n    const validConfig = ChartConfigUtils.quickConfig('line')\n    const validation = ChartConfigUtils.validate(validConfig)\n\n    expect(validation.valid).toBe(true)\n    expect(validation.errors).toHaveLength(0)\n  })\n\n  it('validates incomplete configuration', () => {\n    const incompleteConfig = {} as any\n    const validation = ChartConfigUtils.validate(incompleteConfig)\n\n    expect(validation.valid).toBe(false)\n    expect(validation.errors.length).toBeGreaterThan(0)\n    expect(validation.errors).toContain('Colors configuration is required')\n  })\n})\n\ndescribe('useChartConfig', () => {\n  it('initializes with default configuration', () => {\n    const { result } = renderHook(() => useChartConfig())\n\n    expect(result.current.config.colors.primary).toBe('#3F51B5')\n    expect(result.current.config.legend.show).toBe(true)\n  })\n\n  it('initializes with custom configuration', () => {\n    const initialConfig = {\n      colors: { primary: '#FF0000' },\n      legend: { show: false },\n    }\n\n    const { result } = renderHook(() => useChartConfig(initialConfig))\n\n    expect(result.current.config.colors.primary).toBe('#FF0000')\n    expect(result.current.config.legend.show).toBe(false)\n  })\n\n  it('updates configuration', () => {\n    const { result } = renderHook(() => useChartConfig())\n\n    act(() => {\n      result.current.updateConfig({\n        colors: { primary: '#00FF00' },\n        legend: { show: false },\n      })\n    })\n\n    expect(result.current.config.colors.primary).toBe('#00FF00')\n    expect(result.current.config.legend.show).toBe(false)\n  })\n\n  it('resets configuration', () => {\n    const initialConfig = {\n      colors: { primary: '#FF0000' },\n    }\n\n    const { result } = renderHook(() => useChartConfig(initialConfig))\n\n    act(() => {\n      result.current.updateConfig({\n        colors: { primary: '#00FF00' },\n      })\n    })\n\n    expect(result.current.config.colors.primary).toBe('#00FF00')\n\n    act(() => {\n      result.current.resetConfig()\n    })\n\n    expect(result.current.config.colors.primary).toBe('#FF0000')\n  })\n\n  it('applies theme', () => {\n    const { result } = renderHook(() => useChartConfig())\n\n    act(() => {\n      result.current.applyTheme('dark')\n    })\n\n    expect(result.current.config.colors.primary).toBe(CHART_THEMES.dark.colors.primary)\n  })\n\n  it('applies preset', () => {\n    const { result } = renderHook(() => useChartConfig())\n\n    act(() => {\n      result.current.applyPreset('pie')\n    })\n\n    expect(result.current.config.legend.position).toBe('right')\n    expect(result.current.config.animations.duration).toBe(500)\n  })\n\n  it('preserves custom colors when applying preset', () => {\n    const { result } = renderHook(() => useChartConfig())\n\n    act(() => {\n      result.current.updateConfig({\n        colors: { primary: '#CUSTOM' },\n      })\n    })\n\n    act(() => {\n      result.current.applyPreset('bar')\n    })\n\n    expect(result.current.config.colors.primary).toBe('#CUSTOM')\n    expect(result.current.config.animations.duration).toBe(400) // From bar preset\n  })\n})\n\ndescribe('CHART_THEMES', () => {\n  it('contains all required themes', () => {\n    expect(CHART_THEMES.default).toBeDefined()\n    expect(CHART_THEMES.dark).toBeDefined()\n    expect(CHART_THEMES.minimal).toBeDefined()\n    expect(CHART_THEMES.vibrant).toBeDefined()\n  })\n\n  it('has consistent structure for all themes', () => {\n    Object.values(CHART_THEMES).forEach(theme => {\n      expect(theme.colors).toBeDefined()\n      expect(theme.palette).toBeDefined()\n      expect(Array.isArray(theme.palette)).toBe(true)\n      expect(theme.palette.length).toBeGreaterThan(0)\n    })\n  })\n})\n\ndescribe('CHART_PRESETS', () => {\n  it('contains all required presets', () => {\n    expect(CHART_PRESETS.line).toBeDefined()\n    expect(CHART_PRESETS.bar).toBeDefined()\n    expect(CHART_PRESETS.pie).toBeDefined()\n    expect(CHART_PRESETS.heatmap).toBeDefined()\n  })\n\n  it('has consistent structure for all presets', () => {\n    Object.values(CHART_PRESETS).forEach(preset => {\n      expect(preset.legend).toBeDefined()\n      expect(preset.animations).toBeDefined()\n      expect(typeof preset.legend.show).toBe('boolean')\n      expect(typeof preset.animations.enabled).toBe('boolean')\n    })\n  })\n\n  it('has different configurations for different chart types', () => {\n    expect(CHART_PRESETS.pie.legend.position).toBe('right')\n    expect(CHART_PRESETS.line.legend.position).toBe('bottom')\n    expect(CHART_PRESETS.heatmap.animations.enabled).toBe(false)\n    expect(CHART_PRESETS.bar.animations.enabled).toBe(true)\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/__tests__/chart-export.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'React' is defined but never used.",
        "line": 3,
        "column": 8,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'originalWindow' is assigned a value but never used.",
        "line": 7,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 117,
        "column": 10,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 117,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2556, 2559], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2556, 2559], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 163,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 163,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 181,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 181,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4480, 4483], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4480, 4483], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 190,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 190,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4756, 4759], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4756, 4759], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 201,
        "column": 27,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 201,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 215,
        "column": 27,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 215,
        "endColumn": 49
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ChartExporter, useChartExport } from '../chart-export'\nimport { renderHook, act } from '@testing-library/react'\nimport React from 'react'\n\n// Setup test environment\nconst originalDocument = global.document\nconst originalWindow = global.window\n\nbeforeAll(() => {\n  // Mock document and window for React testing\n  Object.defineProperty(global, 'document', {\n    value: {\n      ...originalDocument,\n      createElement: jest.fn((tagName) => {\n        if (tagName === 'a') {\n          return mockLink\n        }\n        return {\n          querySelector: jest.fn(),\n          innerHTML: '',\n        }\n      }),\n      body: {\n        appendChild: jest.fn(),\n        removeChild: jest.fn(),\n      },\n    },\n    writable: true,\n  })\n})\n\n// Mock html2canvas\njest.mock('html2canvas', () => {\n  return jest.fn(() => Promise.resolve({\n    toDataURL: jest.fn(() => 'data:image/png;base64,mock-image-data'),\n    width: 800,\n    height: 600,\n  }))\n})\n\n// Mock jsPDF\njest.mock('jspdf', () => {\n  return jest.fn().mockImplementation(() => ({\n    addImage: jest.fn(),\n    save: jest.fn(),\n  }))\n})\n\n// Mock DOM methods\nObject.defineProperty(global, 'XMLSerializer', {\n  writable: true,\n  value: jest.fn().mockImplementation(() => ({\n    serializeToString: jest.fn(() => '<svg>mock svg content</svg>'),\n  })),\n})\n\nObject.defineProperty(global, 'URL', {\n  writable: true,\n  value: {\n    createObjectURL: jest.fn(() => 'blob:mock-url'),\n    revokeObjectURL: jest.fn(),\n  },\n})\n\nObject.defineProperty(global, 'Blob', {\n  writable: true,\n  value: jest.fn().mockImplementation((content, options) => ({\n    content,\n    options,\n  })),\n})\n\n// Mock document methods\nconst mockLink = {\n  click: jest.fn(),\n  download: '',\n  href: '',\n}\n\nObject.defineProperty(document, 'createElement', {\n  writable: true,\n  value: jest.fn((tagName) => {\n    if (tagName === 'a') {\n      return mockLink\n    }\n    return {}\n  }),\n})\n\nObject.defineProperty(document.body, 'appendChild', {\n  writable: true,\n  value: jest.fn(),\n})\n\nObject.defineProperty(document.body, 'removeChild', {\n  writable: true,\n  value: jest.fn(),\n})\n\ndescribe('ChartExporter', () => {\n  let mockElement: HTMLElement\n\n  beforeEach(() => {\n    // Create a proper mock element with querySelector\n    mockElement = {\n      querySelector: jest.fn((selector) => {\n        if (selector === 'svg') {\n          return {\n            cloneNode: jest.fn(() => ({\n              setAttribute: jest.fn(),\n              getAttribute: jest.fn(() => null),\n            })),\n          }\n        }\n        return null\n      }),\n    } as any\n    \n    // Reset mocks\n    jest.clearAllMocks()\n  })\n\n  describe('isExportSupported', () => {\n    it('returns true when export is supported', () => {\n      expect(ChartExporter.isExportSupported()).toBe(true)\n    })\n  })\n\n  describe('getAvailableFormats', () => {\n    it('returns available export formats', () => {\n      const formats = ChartExporter.getAvailableFormats()\n      expect(formats).toContain('png')\n      expect(formats).toContain('svg')\n      expect(formats).toContain('pdf')\n    })\n  })\n\n  describe('exportChart', () => {\n    it('exports chart as PNG', async () => {\n      await ChartExporter.exportChart(mockElement, {\n        format: 'png',\n        filename: 'test-chart',\n      })\n\n      expect(mockLink.download).toBe('test-chart.png')\n      expect(mockLink.href).toBe('data:image/png;base64,mock-image-data')\n      expect(mockLink.click).toHaveBeenCalled()\n    })\n\n    it('exports chart as SVG', async () => {\n      await ChartExporter.exportChart(mockElement, {\n        format: 'svg',\n        filename: 'test-chart',\n      })\n\n      expect(mockLink.download).toBe('test-chart.svg')\n      expect(mockLink.click).toHaveBeenCalled()\n      expect(global.URL.createObjectURL).toHaveBeenCalled()\n      expect(global.URL.revokeObjectURL).toHaveBeenCalled()\n    })\n\n    it('exports chart as PDF', async () => {\n      const jsPDF = require('jspdf')\n\n      await ChartExporter.exportChart(mockElement, {\n        format: 'pdf',\n        filename: 'test-chart',\n      })\n\n      expect(jsPDF).toHaveBeenCalled()\n      \n      // Get the mock instance\n      const mockPdfInstance = jsPDF.mock.results[0].value\n      expect(mockPdfInstance.addImage).toHaveBeenCalled()\n      expect(mockPdfInstance.save).toHaveBeenCalledWith('test-chart.pdf')\n    })\n\n    it('throws error for unsupported format', async () => {\n      await expect(\n        ChartExporter.exportChart(mockElement, {\n          format: 'unsupported' as any,\n          filename: 'test-chart',\n        })\n      ).rejects.toThrow('Failed to export chart as UNSUPPORTED')\n    })\n\n    it('throws error when SVG element not found', async () => {\n      const elementWithoutSvg = {\n        querySelector: jest.fn(() => null),\n      } as any\n\n      await expect(\n        ChartExporter.exportChart(elementWithoutSvg, {\n          format: 'svg',\n          filename: 'test-chart',\n        })\n      ).rejects.toThrow('No SVG element found in chart')\n    })\n\n    it('applies custom quality for PNG export', async () => {\n      const html2canvas = require('html2canvas')\n\n      await ChartExporter.exportChart(mockElement, {\n        format: 'png',\n        filename: 'test-chart',\n        quality: 2.0,\n      })\n\n      expect(html2canvas).toHaveBeenCalledWith(mockElement, expect.objectContaining({\n        scale: 2.0,\n      }))\n    })\n\n    it('applies custom background color', async () => {\n      const html2canvas = require('html2canvas')\n\n      await ChartExporter.exportChart(mockElement, {\n        format: 'png',\n        filename: 'test-chart',\n        backgroundColor: '#ff0000',\n      })\n\n      expect(html2canvas).toHaveBeenCalledWith(mockElement, expect.objectContaining({\n        backgroundColor: '#ff0000',\n      }))\n    })\n  })\n})\n\ndescribe('useChartExport', () => {\n  it('provides export functionality', () => {\n    const { result } = renderHook(() => useChartExport())\n\n    expect(result.current.isSupported).toBe(true)\n    expect(result.current.availableFormats).toContain('png')\n    expect(result.current.availableFormats).toContain('svg')\n    expect(result.current.availableFormats).toContain('pdf')\n    expect(typeof result.current.exportChart).toBe('function')\n  })\n\n  it('exports chart using ref', async () => {\n    const { result } = renderHook(() => useChartExport())\n    const mockRef = { current: mockElement }\n\n    await act(async () => {\n      await result.current.exportChart(mockRef, {\n        format: 'png',\n        filename: 'hook-test',\n      })\n    })\n\n    expect(mockLink.download).toBe('hook-test.png')\n    expect(mockLink.click).toHaveBeenCalled()\n  })\n\n  it('throws error when element ref is null', async () => {\n    const { result } = renderHook(() => useChartExport())\n    const mockRef = { current: null }\n\n    await expect(\n      result.current.exportChart(mockRef, {\n        format: 'png',\n        filename: 'test',\n      })\n    ).rejects.toThrow('Chart element not found')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/__tests__/chart-integration-comprehensive.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'userEvent' is defined but never used.",
        "line": 2,
        "column": 8,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ChartCard' is defined but never used.",
        "line": 4,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [388, 391], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [388, 391], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 14,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 14,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [559, 562], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [559, 562], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 19,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 19,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [729, 732], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [729, 732], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 24,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 24,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [872, 875], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [872, 875], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 25,
        "column": 16,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 25,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [934, 937], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [934, 937], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 26,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 26,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [996, 999], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [996, 999], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 27,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 27,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1060, 1063], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1060, 1063], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 28,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 28,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1126, 1129], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1126, 1129], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 29,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 29,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1200, 1203], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1200, 1203], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 30,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 30,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1276, 1279], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1276, 1279], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 31,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 31,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1344, 1347], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1344, 1347], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 32,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 32,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1441, 1444], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1441, 1444], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'config' is defined but never used.",
        "line": 41,
        "column": 23,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 41,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 41,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 41,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1661, 1664], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1661, 1664], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'config' is defined but never used.",
        "line": 52,
        "column": 22,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 52,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 52,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 52,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1943, 1946], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1943, 1946], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'config' is defined but never used.",
        "line": 60,
        "column": 22,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 60,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 60,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 60,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2144, 2147], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2144, 2147], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'config' is defined but never used.",
        "line": 68,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 68,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 68,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 68,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2353, 2356], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2353, 2356], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 526,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 526,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13551, 13554], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13551, 13554], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 23,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { ChartWrapper } from '../chart-wrapper'\nimport { ChartCard } from '../chart-card'\nimport { ChartData, ChartConfiguration } from '@/types/dashboard'\n\n// Mock Recharts components\njest.mock('recharts', () => ({\n  LineChart: ({ children, data, ...props }: any) => (\n    <div data-testid=\"line-chart\" data-chart-data={JSON.stringify(data)} {...props}>\n      {children}\n    </div>\n  ),\n  BarChart: ({ children, data, ...props }: any) => (\n    <div data-testid=\"bar-chart\" data-chart-data={JSON.stringify(data)} {...props}>\n      {children}\n    </div>\n  ),\n  PieChart: ({ children, data, ...props }: any) => (\n    <div data-testid=\"pie-chart\" data-chart-data={JSON.stringify(data)} {...props}>\n      {children}\n    </div>\n  ),\n  Line: (props: any) => <div data-testid=\"line\" {...props} />,\n  Bar: (props: any) => <div data-testid=\"bar\" {...props} />,\n  Cell: (props: any) => <div data-testid=\"cell\" {...props} />,\n  XAxis: (props: any) => <div data-testid=\"x-axis\" {...props} />,\n  YAxis: (props: any) => <div data-testid=\"y-axis\" {...props} />,\n  CartesianGrid: (props: any) => <div data-testid=\"cartesian-grid\" {...props} />,\n  Tooltip: (props: any) => <div data-testid=\"tooltip\" {...props} />,\n  Legend: (props: any) => <div data-testid=\"legend\" {...props} />,\n  ResponsiveContainer: ({ children, ...props }: any) => (\n    <div data-testid=\"responsive-container\" {...props}>\n      {children}\n    </div>\n  )\n}))\n\n// Mock dynamic imports\njest.mock('../chart-types/line-chart', () => ({\n  LineChart: ({ data, config, onDataClick }: any) => (\n    <div \n      data-testid=\"line-chart-component\"\n      onClick={() => onDataClick && onDataClick({ x: 1, y: 100 })}\n    >\n      Line Chart: {data.datasets.length} datasets\n    </div>\n  )\n}))\n\njest.mock('../chart-types/bar-chart', () => ({\n  BarChart: ({ data, config }: any) => (\n    <div data-testid=\"bar-chart-component\">\n      Bar Chart: {data.datasets.length} datasets\n    </div>\n  )\n}))\n\njest.mock('../chart-types/pie-chart', () => ({\n  PieChart: ({ data, config }: any) => (\n    <div data-testid=\"pie-chart-component\">\n      Pie Chart: {data.datasets.length} datasets\n    </div>\n  )\n}))\n\njest.mock('../chart-types/heatmap-chart', () => ({\n  HeatmapChart: ({ data, config }: any) => (\n    <div data-testid=\"heatmap-chart-component\">\n      Heatmap Chart: {data.datasets.length} datasets\n    </div>\n  )\n}))\n\ndescribe('Chart Integration Comprehensive Tests', () => {\n  const mockLineData: ChartData = {\n    datasets: [\n      {\n        label: 'Sales',\n        data: [\n          { x: 'Jan', y: 100 },\n          { x: 'Feb', y: 150 },\n          { x: 'Mar', y: 120 }\n        ],\n        color: '#3F51B5'\n      }\n    ],\n    labels: ['Jan', 'Feb', 'Mar']\n  }\n\n  const mockBarData: ChartData = {\n    datasets: [\n      {\n        label: 'Revenue',\n        data: [\n          { x: 'Q1', y: 10000 },\n          { x: 'Q2', y: 15000 },\n          { x: 'Q3', y: 12000 },\n          { x: 'Q4', y: 18000 }\n        ],\n        color: '#B19ADA'\n      }\n    ]\n  }\n\n  const mockPieData: ChartData = {\n    datasets: [\n      {\n        label: 'Distribution',\n        data: [\n          { label: 'Desktop', value: 60 },\n          { label: 'Mobile', value: 30 },\n          { label: 'Tablet', value: 10 }\n        ]\n      }\n    ]\n  }\n\n  const mockConfig: ChartConfiguration = {\n    colors: {\n      primary: '#3F51B5',\n      secondary: '#B19ADA',\n      accent: '#FF6B35',\n      success: '#10B981',\n      warning: '#F59E0B',\n      error: '#EF4444'\n    },\n    legend: {\n      show: true,\n      position: 'bottom',\n      align: 'center'\n    },\n    tooltip: {\n      show: true\n    },\n    animations: {\n      enabled: true,\n      duration: 300,\n      easing: 'ease-out'\n    }\n  }\n\n  describe('ChartWrapper Component', () => {\n    it('renders line chart with correct data', async () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={mockConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n        expect(screen.getByText('Line Chart: 1 datasets')).toBeInTheDocument()\n      })\n    })\n\n    it('renders bar chart with correct data', async () => {\n      render(\n        <ChartWrapper\n          type=\"bar\"\n          data={mockBarData}\n          config={mockConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('bar-chart-component')).toBeInTheDocument()\n        expect(screen.getByText('Bar Chart: 1 datasets')).toBeInTheDocument()\n      })\n    })\n\n    it('renders pie chart with correct data', async () => {\n      render(\n        <ChartWrapper\n          type=\"pie\"\n          data={mockPieData}\n          config={mockConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('pie-chart-component')).toBeInTheDocument()\n        expect(screen.getByText('Pie Chart: 1 datasets')).toBeInTheDocument()\n      })\n    })\n\n    it('renders heatmap chart with correct data', async () => {\n      render(\n        <ChartWrapper\n          type=\"heatmap\"\n          data={mockLineData}\n          config={mockConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('heatmap-chart-component')).toBeInTheDocument()\n        expect(screen.getByText('Heatmap Chart: 1 datasets')).toBeInTheDocument()\n      })\n    })\n\n    it('shows loading state', () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          loading={true}\n        />\n      )\n\n      expect(screen.getByText(/loading chart/i)).toBeInTheDocument()\n      expect(screen.queryByTestId('line-chart-component')).not.toBeInTheDocument()\n    })\n\n    it('shows error state', () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          error=\"Failed to load chart data\"\n        />\n      )\n\n      expect(screen.getByText('Failed to load chart data')).toBeInTheDocument()\n      expect(screen.queryByTestId('line-chart-component')).not.toBeInTheDocument()\n    })\n\n    it('handles data click events', async () => {\n      const onDataClick = jest.fn()\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          onDataClick={onDataClick}\n          interactive={true}\n        />\n      )\n\n      await waitFor(() => {\n        const chart = screen.getByTestId('line-chart-component')\n        fireEvent.click(chart)\n      })\n\n      expect(onDataClick).toHaveBeenCalledWith({ x: 1, y: 100 })\n    })\n\n    it('handles legend click events', async () => {\n      const onLegendClick = jest.fn()\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          onLegendClick={onLegendClick}\n          config={{\n            ...mockConfig,\n            legend: { show: true, position: 'bottom', align: 'center' }\n          }}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n\n      // Simulate legend click (implementation would depend on chart component)\n      // This is a placeholder for the expected behavior\n    })\n\n    it('applies responsive configuration', () => {\n      const responsiveConfig: ChartConfiguration = {\n        ...mockConfig,\n        responsive: {\n          breakpoints: {\n            mobile: {\n              legend: { show: false },\n              tooltip: { show: true }\n            },\n            tablet: {\n              legend: { show: true, position: 'right' }\n            }\n          }\n        }\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={responsiveConfig}\n          responsive={true}\n        />\n      )\n\n      // Test that responsive config is applied\n      // Implementation would depend on how responsive config is handled\n    })\n\n    it('accepts height prop', () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          height={400}\n        />\n      )\n\n      // Height prop is accepted without error\n      expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n    })\n\n    it('enables export functionality when exportable is true', async () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          exportable={true}\n        />\n      )\n\n      await waitFor(() => {\n        const exportButton = screen.queryByRole('button', { name: /export/i })\n        expect(exportButton).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Data Visualization Accuracy', () => {\n    it('correctly processes line chart data', async () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n        />\n      )\n\n      await waitFor(() => {\n        const chart = screen.getByTestId('line-chart-component')\n        expect(chart).toBeInTheDocument()\n      })\n\n      // Verify data is passed correctly\n      expect(screen.getByText('Line Chart: 1 datasets')).toBeInTheDocument()\n    })\n\n    it('correctly processes bar chart data with multiple datasets', async () => {\n      const multiDatasetBarData: ChartData = {\n        datasets: [\n          {\n            label: 'Revenue',\n            data: [{ x: 'Q1', y: 10000 }, { x: 'Q2', y: 15000 }],\n            color: '#3F51B5'\n          },\n          {\n            label: 'Profit',\n            data: [{ x: 'Q1', y: 2000 }, { x: 'Q2', y: 3000 }],\n            color: '#B19ADA'\n          }\n        ]\n      }\n\n      render(\n        <ChartWrapper\n          type=\"bar\"\n          data={multiDatasetBarData}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByText('Bar Chart: 2 datasets')).toBeInTheDocument()\n      })\n    })\n\n    it('correctly processes pie chart data with percentages', async () => {\n      const pieDataWithPercentages: ChartData = {\n        datasets: [\n          {\n            label: 'Usage',\n            data: [\n              { label: 'Desktop', value: 60, metadata: { percentage: '60%' } },\n              { label: 'Mobile', value: 30, metadata: { percentage: '30%' } },\n              { label: 'Tablet', value: 10, metadata: { percentage: '10%' } }\n            ]\n          }\n        ]\n      }\n\n      render(\n        <ChartWrapper\n          type=\"pie\"\n          data={pieDataWithPercentages}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('pie-chart-component')).toBeInTheDocument()\n      })\n    })\n\n    it('handles empty datasets gracefully', async () => {\n      const emptyData: ChartData = {\n        datasets: []\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={emptyData}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByText(/no data available/i)).toBeInTheDocument()\n      })\n    })\n\n    it('handles malformed data gracefully', async () => {\n      const malformedData: ChartData = {\n        datasets: [\n          {\n            label: 'Invalid',\n            data: [\n              { x: null, y: undefined },\n              { x: 'valid', y: 100 }\n            ]\n          }\n        ]\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={malformedData}\n        />\n      )\n\n      await waitFor(() => {\n        // Should render without crashing and show valid data\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n\n    it('validates data types and formats', async () => {\n      const mixedTypeData: ChartData = {\n        datasets: [\n          {\n            label: 'Mixed',\n            data: [\n              { x: 'Jan', y: 100 },\n              { x: 'Feb', y: '150' }, // String number\n              { x: 'Mar', y: 120 }\n            ]\n          }\n        ]\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mixedTypeData}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Chart Configuration', () => {\n    it('applies color configuration correctly', async () => {\n      const colorConfig: ChartConfiguration = {\n        colors: {\n          primary: '#FF0000',\n          secondary: '#00FF00',\n          accent: '#0000FF',\n          success: '#00FFFF',\n          warning: '#FFFF00',\n          error: '#FF00FF'\n        }\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={colorConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n\n      // Configuration should be passed to chart component\n      // Actual color application would be tested in individual chart component tests\n    })\n\n    it('configures legend display and positioning', async () => {\n      const legendConfig: ChartConfiguration = {\n        legend: {\n          show: true,\n          position: 'top',\n          align: 'start'\n        }\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={legendConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n\n    it('configures tooltip behavior', async () => {\n      const tooltipConfig: ChartConfiguration = {\n        tooltip: {\n          show: true,\n          format: (value: any) => `$${value.toLocaleString()}`\n        }\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={tooltipConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n\n    it('configures animation settings', async () => {\n      const animationConfig: ChartConfiguration = {\n        animations: {\n          enabled: true,\n          duration: 500,\n          easing: 'ease-in-out'\n        }\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={animationConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n\n    it('disables animations when specified', async () => {\n      const noAnimationConfig: ChartConfiguration = {\n        animations: {\n          enabled: false,\n          duration: 0,\n          easing: 'linear'\n        }\n      }\n\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={noAnimationConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Performance and Lazy Loading', () => {\n    it('lazy loads chart components', async () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n        />\n      )\n\n      // Chart loads dynamically\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n\n    it('memoizes chart data to prevent unnecessary re-renders', async () => {\n      const { rerender } = render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={mockConfig}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n\n      // Re-render with same data\n      rerender(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={mockConfig}\n        />\n      )\n\n      // Chart should not re-render if data hasn't changed\n      expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n    })\n\n    it('handles large datasets efficiently', async () => {\n      const largeDataset: ChartData = {\n        datasets: [\n          {\n            label: 'Large Dataset',\n            data: Array.from({ length: 1000 }, (_, i) => ({\n              x: i,\n              y: Math.random() * 100\n            }))\n          }\n        ]\n      }\n\n      const startTime = performance.now()\n      \n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={largeDataset}\n        />\n      )\n\n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n\n      const endTime = performance.now()\n      const renderTime = endTime - startTime\n\n      // Should render within reasonable time (adjust threshold as needed)\n      expect(renderTime).toBeLessThan(1000) // 1 second\n    })\n  })\n\n  describe('Accessibility', () => {\n    it('provides proper ARIA labels for charts', async () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          config={mockConfig}\n        />\n      )\n\n      await waitFor(() => {\n        const chartContainer = screen.getByRole('application')\n        expect(chartContainer).toHaveAttribute(\n          'aria-label',\n          expect.stringContaining('line chart')\n        )\n      })\n    })\n\n    it('provides keyboard navigation for interactive charts', async () => {\n      render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n          interactive={true}\n        />\n      )\n\n      await waitFor(() => {\n        const chartContainer = screen.getByRole('application')\n        expect(chartContainer).toHaveAttribute('tabindex', '0')\n      })\n    })\n\n    it('announces data updates to screen readers', async () => {\n      const { rerender } = render(\n        <ChartWrapper\n          type=\"line\"\n          data={mockLineData}\n        />\n      )\n\n      const updatedData: ChartData = {\n        ...mockLineData,\n        datasets: [\n          {\n            ...mockLineData.datasets[0],\n            data: [\n              { x: 'Jan', y: 200 },\n              { x: 'Feb', y: 250 },\n              { x: 'Mar', y: 220 }\n            ]\n          }\n        ]\n      }\n\n      rerender(\n        <ChartWrapper\n          type=\"line\"\n          data={updatedData}\n        />\n      )\n\n      await waitFor(() => {\n        // Chart should re-render with updated data\n        expect(screen.getByTestId('line-chart-component')).toBeInTheDocument()\n      })\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/__tests__/chart-wrapper.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [401, 404], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [401, 404], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 17,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 17,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [642, 645], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [642, 645], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 25,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 25,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [881, 884], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [881, 884], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 33,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 33,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1128, 1131], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1128, 1131], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 178,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 178,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4404, 4407], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4404, 4407], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { ChartWrapper } from '../chart-wrapper'\nimport type { ChartData } from '@/types/dashboard'\n\n// Mock the chart components to avoid Recharts rendering issues in tests\njest.mock('../chart-types/line-chart', () => ({\n  LineChart: ({ data, onDataClick }: any) => (\n    <div data-testid=\"line-chart\" onClick={() => onDataClick?.({ x: 1, y: 100 })}>\n      Line Chart: {data.datasets[0]?.label}\n    </div>\n  ),\n}))\n\njest.mock('../chart-types/bar-chart', () => ({\n  BarChart: ({ data, onDataClick }: any) => (\n    <div data-testid=\"bar-chart\" onClick={() => onDataClick?.({ x: 1, y: 100 })}>\n      Bar Chart: {data.datasets[0]?.label}\n    </div>\n  ),\n}))\n\njest.mock('../chart-types/pie-chart', () => ({\n  PieChart: ({ data, onDataClick }: any) => (\n    <div data-testid=\"pie-chart\" onClick={() => onDataClick?.({ x: 1, y: 100 })}>\n      Pie Chart: {data.datasets[0]?.label}\n    </div>\n  ),\n}))\n\njest.mock('../chart-types/heatmap-chart', () => ({\n  HeatmapChart: ({ data, onDataClick }: any) => (\n    <div data-testid=\"heatmap-chart\" onClick={() => onDataClick?.({ x: 1, y: 100 })}>\n      Heatmap Chart: {data.datasets[0]?.label}\n    </div>\n  ),\n}))\n\nconst mockData: ChartData = {\n  datasets: [\n    {\n      label: 'Test Dataset',\n      data: [\n        { x: 'Jan', y: 100 },\n        { x: 'Feb', y: 200 },\n        { x: 'Mar', y: 150 },\n      ],\n    },\n  ],\n}\n\ndescribe('ChartWrapper', () => {\n  it('renders loading state', () => {\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        loading={true}\n      />\n    )\n\n    expect(screen.getByText('Loading chart...')).toBeInTheDocument()\n    expect(screen.getByRole('status')).toBeInTheDocument()\n  })\n\n  it('renders error state', () => {\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        error=\"Failed to load chart\"\n      />\n    )\n\n    expect(screen.getByText('Failed to load chart')).toBeInTheDocument()\n    expect(screen.getByRole('alert')).toBeInTheDocument()\n  })\n\n  it('renders empty state when no data', () => {\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={{ datasets: [] }}\n      />\n    )\n\n    expect(screen.getByText('No data available')).toBeInTheDocument()\n  })\n\n  it('renders line chart', async () => {\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n    expect(screen.getByText('Line Chart: Test Dataset')).toBeInTheDocument()\n  })\n\n  it('renders bar chart', async () => {\n    render(\n      <ChartWrapper\n        type=\"bar\"\n        data={mockData}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('bar-chart')).toBeInTheDocument()\n    })\n    expect(screen.getByText('Bar Chart: Test Dataset')).toBeInTheDocument()\n  })\n\n  it('renders pie chart', async () => {\n    render(\n      <ChartWrapper\n        type=\"pie\"\n        data={mockData}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('pie-chart')).toBeInTheDocument()\n    })\n    expect(screen.getByText('Pie Chart: Test Dataset')).toBeInTheDocument()\n  })\n\n  it('renders heatmap chart', async () => {\n    render(\n      <ChartWrapper\n        type=\"heatmap\"\n        data={mockData}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('heatmap-chart')).toBeInTheDocument()\n    })\n    expect(screen.getByText('Heatmap Chart: Test Dataset')).toBeInTheDocument()\n  })\n\n  it('renders area chart (line chart variant)', async () => {\n    render(\n      <ChartWrapper\n        type=\"area\"\n        data={mockData}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n    expect(screen.getByText('Line Chart: Test Dataset')).toBeInTheDocument()\n  })\n\n  it('renders scatter chart (line chart variant)', async () => {\n    render(\n      <ChartWrapper\n        type=\"scatter\"\n        data={mockData}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n    expect(screen.getByText('Line Chart: Test Dataset')).toBeInTheDocument()\n  })\n\n  it('handles unsupported chart type', () => {\n    render(\n      <ChartWrapper\n        type={'unsupported' as any}\n        data={mockData}\n      />\n    )\n\n    expect(screen.getByText('Unsupported chart type: unsupported')).toBeInTheDocument()\n  })\n\n  it('handles data click events', async () => {\n    const user = userEvent.setup()\n    const onDataClick = jest.fn()\n\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        onDataClick={onDataClick}\n        interactive={true}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n\n    await user.click(screen.getByTestId('line-chart'))\n    expect(onDataClick).toHaveBeenCalledWith({ x: 1, y: 100 })\n  })\n\n  it('applies custom configuration', async () => {\n    const customConfig = {\n      colors: {\n        primary: '#FF0000',\n        secondary: '#00FF00',\n        accent: '#0000FF',\n        success: '#00FFFF',\n        warning: '#FFFF00',\n        error: '#FF00FF',\n      },\n      legend: {\n        show: false,\n        position: 'top' as const,\n        align: 'start' as const,\n      },\n      tooltip: {\n        show: false,\n      },\n      animations: {\n        enabled: false,\n        duration: 0,\n        easing: 'linear',\n      },\n    }\n\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        config={customConfig}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n  })\n\n  it('applies responsive height', async () => {\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        height={400}\n        responsive={true}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n\n    const wrapper = screen.getByTestId('line-chart').closest('.chart-wrapper')\n    expect(wrapper).toHaveStyle({ height: 'auto' })\n  })\n\n  it('applies fixed height when not responsive', () => {\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        height={400}\n        responsive={false}\n        loading={true}\n      />\n    )\n\n    const wrapper = screen.getByText('Loading chart...').closest('.chart-wrapper')\n    expect(wrapper).toHaveStyle({ height: '400px' })\n  })\n\n  it('applies custom className', () => {\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        className=\"custom-chart-class\"\n        loading={true}\n      />\n    )\n\n    const wrapper = screen.getByText('Loading chart...').closest('.chart-wrapper')\n    expect(wrapper).toHaveClass('custom-chart-class')\n  })\n\n  it('merges default colors with custom colors', async () => {\n    const customConfig = {\n      colors: {\n        primary: '#FF0000',\n        // Other colors should use defaults\n      },\n    }\n\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={mockData}\n        config={customConfig}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n\n    // The component should merge custom colors with defaults\n    // This is tested implicitly through the component rendering without errors\n  })\n\n  it('generates chart colors from data', async () => {\n    const multiDatasetData: ChartData = {\n      datasets: [\n        {\n          label: 'Dataset 1',\n          data: [{ x: 'A', y: 100 }],\n          color: '#FF0000',\n        },\n        {\n          label: 'Dataset 2',\n          data: [{ x: 'A', y: 200 }],\n          // No color specified, should use default palette\n        },\n      ],\n    }\n\n    render(\n      <ChartWrapper\n        type=\"line\"\n        data={multiDatasetData}\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-config-system.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-examples.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 95,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 95,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2149, 2152], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2149, 2152], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { ChartWrapper } from './chart-wrapper'\nimport { ChartConfigUtils } from './chart-config-system'\nimport type { ChartData } from '@/types/dashboard'\n\n// Example data for different chart types\nconst lineChartData: ChartData = {\n  datasets: [\n    {\n      label: 'Revenue',\n      data: [\n        { x: 'Jan', y: 4000 },\n        { x: 'Feb', y: 3000 },\n        { x: 'Mar', y: 5000 },\n        { x: 'Apr', y: 4500 },\n        { x: 'May', y: 6000 },\n        { x: 'Jun', y: 5500 },\n      ],\n    },\n    {\n      label: 'Expenses',\n      data: [\n        { x: 'Jan', y: 2400 },\n        { x: 'Feb', y: 1398 },\n        { x: 'Mar', y: 3800 },\n        { x: 'Apr', y: 3908 },\n        { x: 'May', y: 4800 },\n        { x: 'Jun', y: 3800 },\n      ],\n    },\n  ],\n}\n\nconst barChartData: ChartData = {\n  datasets: [\n    {\n      label: 'Sales',\n      data: [\n        { x: 'Q1', y: 120 },\n        { x: 'Q2', y: 190 },\n        { x: 'Q3', y: 300 },\n        { x: 'Q4', y: 500 },\n      ],\n    },\n    {\n      label: 'Target',\n      data: [\n        { x: 'Q1', y: 100 },\n        { x: 'Q2', y: 200 },\n        { x: 'Q3', y: 350 },\n        { x: 'Q4', y: 450 },\n      ],\n    },\n  ],\n}\n\nconst pieChartData: ChartData = {\n  datasets: [\n    {\n      label: 'Market Share',\n      data: [\n        { label: 'Product A', value: 35 },\n        { label: 'Product B', value: 25 },\n        { label: 'Product C', value: 20 },\n        { label: 'Product D', value: 15 },\n        { label: 'Others', value: 5 },\n      ],\n    },\n  ],\n}\n\nconst heatmapData: ChartData = {\n  datasets: [\n    {\n      label: 'Activity Heatmap',\n      data: [\n        { x: 'Mon', y: '9AM', value: 10 },\n        { x: 'Mon', y: '12PM', value: 20 },\n        { x: 'Mon', y: '3PM', value: 15 },\n        { x: 'Tue', y: '9AM', value: 25 },\n        { x: 'Tue', y: '12PM', value: 30 },\n        { x: 'Tue', y: '3PM', value: 18 },\n        { x: 'Wed', y: '9AM', value: 12 },\n        { x: 'Wed', y: '12PM', value: 22 },\n        { x: 'Wed', y: '3PM', value: 28 },\n      ],\n    },\n  ],\n  metadata: {\n    title: 'Weekly Activity Pattern',\n  },\n}\n\nexport function ChartExamples() {\n  const handleDataClick = (data: any) => {\n    console.log('Chart data clicked:', data)\n  }\n\n  const handleExportStart = (format: string) => {\n    console.log(`Starting export as ${format}...`)\n  }\n\n  const handleExportComplete = (format: string) => {\n    console.log(`Export as ${format} completed!`)\n  }\n\n  const handleExportError = (error: Error, format: string) => {\n    console.error(`Export as ${format} failed:`, error)\n  }\n\n  return (\n    <div className=\"space-y-8 p-6\">\n      <h2 className=\"text-2xl font-bold text-foreground\">Chart Examples</h2>\n      \n      {/* Line Chart */}\n      <div className=\"space-y-4\">\n        <h3 className=\"text-lg font-semibold text-foreground\">Line Chart</h3>\n        <div className=\"border border-border rounded-lg p-4\">\n          <ChartWrapper\n            type=\"line\"\n            data={lineChartData}\n            config={ChartConfigUtils.quickConfig('line', 'default')}\n            height={300}\n            exportable={true}\n            exportFilename=\"revenue-chart\"\n            onDataClick={handleDataClick}\n            onExportStart={handleExportStart}\n            onExportComplete={handleExportComplete}\n            onExportError={handleExportError}\n          />\n        </div>\n      </div>\n\n      {/* Bar Chart */}\n      <div className=\"space-y-4\">\n        <h3 className=\"text-lg font-semibold text-foreground\">Bar Chart</h3>\n        <div className=\"border border-border rounded-lg p-4\">\n          <ChartWrapper\n            type=\"bar\"\n            data={barChartData}\n            config={ChartConfigUtils.quickConfig('bar', 'vibrant')}\n            height={300}\n            exportable={true}\n            exportFilename=\"sales-chart\"\n            onDataClick={handleDataClick}\n          />\n        </div>\n      </div>\n\n      {/* Pie Chart */}\n      <div className=\"space-y-4\">\n        <h3 className=\"text-lg font-semibold text-foreground\">Pie Chart</h3>\n        <div className=\"border border-border rounded-lg p-4\">\n          <ChartWrapper\n            type=\"pie\"\n            data={pieChartData}\n            config={ChartConfigUtils.quickConfig('pie', 'minimal')}\n            height={300}\n            exportable={true}\n            exportFilename=\"market-share-chart\"\n            onDataClick={handleDataClick}\n          />\n        </div>\n      </div>\n\n      {/* Heatmap Chart */}\n      <div className=\"space-y-4\">\n        <h3 className=\"text-lg font-semibold text-foreground\">Heatmap Chart</h3>\n        <div className=\"border border-border rounded-lg p-4\">\n          <ChartWrapper\n            type=\"heatmap\"\n            data={heatmapData}\n            config={ChartConfigUtils.quickConfig('heatmap', 'dark')}\n            height={300}\n            exportable={true}\n            exportFilename=\"activity-heatmap\"\n            onDataClick={handleDataClick}\n          />\n        </div>\n      </div>\n\n      {/* Area Chart (Line Chart variant) */}\n      <div className=\"space-y-4\">\n        <h3 className=\"text-lg font-semibold text-foreground\">Area Chart</h3>\n        <div className=\"border border-border rounded-lg p-4\">\n          <ChartWrapper\n            type=\"area\"\n            data={lineChartData}\n            config={ChartConfigUtils.builder()\n              .withTheme('default')\n              .withPreset('line')\n              .withColors({ primary: '#10B981', secondary: '#3B82F6' })\n              .build()}\n            height={300}\n            exportable={true}\n            exportFilename=\"area-chart\"\n            onDataClick={handleDataClick}\n          />\n        </div>\n      </div>\n\n      {/* Custom Configuration Example */}\n      <div className=\"space-y-4\">\n        <h3 className=\"text-lg font-semibold text-foreground\">Custom Configuration</h3>\n        <div className=\"border border-border rounded-lg p-4\">\n          <ChartWrapper\n            type=\"line\"\n            data={lineChartData}\n            config={ChartConfigUtils.builder()\n              .withTheme('vibrant')\n              .withLegend({ show: true, position: 'top', align: 'start' })\n              .withTooltip({ \n                show: true, \n                format: (value) => `$${value.toLocaleString()}` \n              })\n              .withAnimations({ enabled: true, duration: 500, easing: 'ease-in-out' })\n              .build()}\n            height={300}\n            exportable={true}\n            exportFilename=\"custom-chart\"\n            onDataClick={handleDataClick}\n          />\n        </div>\n      </div>\n    </div>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-export-controls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-export.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/__tests__/bar-chart.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [338, 341], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [338, 341], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [519, 522], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [519, 522], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 20,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 20,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [675, 678], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [675, 678], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 21,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 21,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [762, 765], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [762, 765], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'content' is defined but never used.",
        "line": 25,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 25,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 25,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 25,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [950, 953], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [950, 953], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 26,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 26,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1024, 1027], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1024, 1027], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 31,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 31,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1192, 1195], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1192, 1195], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { BarChart } from '../bar-chart'\nimport type { ChartData, ChartConfiguration } from '@/types/dashboard'\n\n// Mock Recharts components\njest.mock('recharts', () => ({\n  BarChart: ({ children, data }: any) => (\n    <div data-testid=\"recharts-bar-chart\">\n      {children}\n      <div data-testid=\"chart-data\">{JSON.stringify(data)}</div>\n    </div>\n  ),\n  Bar: ({ dataKey, onClick }: any) => (\n    <div data-testid={`bar-${dataKey}`} onClick={() => onClick?.({ value: 100 }, 0)}>\n      Bar: {dataKey}\n    </div>\n  ),\n  XAxis: ({ dataKey }: any) => <div data-testid=\"x-axis\">XAxis: {dataKey}</div>,\n  YAxis: ({ tickFormatter }: any) => (\n    <div data-testid=\"y-axis\">YAxis{tickFormatter ? ' (formatted)' : ''}</div>\n  ),\n  CartesianGrid: () => <div data-testid=\"cartesian-grid\">Grid</div>,\n  Tooltip: ({ content }: any) => <div data-testid=\"tooltip\">Tooltip</div>,\n  Legend: ({ onClick }: any) => (\n    <div data-testid=\"legend\" onClick={() => onClick?.({ value: 'Test', color: '#000' })}>\n      Legend\n    </div>\n  ),\n  ResponsiveContainer: ({ children }: any) => (\n    <div data-testid=\"responsive-container\">{children}</div>\n  ),\n}))\n\nconst mockData: ChartData = {\n  datasets: [\n    {\n      label: 'Dataset 1',\n      data: [\n        { x: 'Q1', y: 100 },\n        { x: 'Q2', y: 200 },\n        { x: 'Q3', y: 150 },\n        { x: 'Q4', y: 300 },\n      ],\n    },\n    {\n      label: 'Dataset 2',\n      data: [\n        { x: 'Q1', y: 80 },\n        { x: 'Q2', y: 180 },\n        { x: 'Q3', y: 120 },\n        { x: 'Q4', y: 250 },\n      ],\n    },\n  ],\n}\n\nconst mockConfig: ChartConfiguration = {\n  colors: {\n    primary: '#3F51B5',\n    secondary: '#B19ADA',\n    accent: '#FF6B35',\n    success: '#10B981',\n    warning: '#F59E0B',\n    error: '#EF4444',\n  },\n  legend: {\n    show: true,\n    position: 'bottom',\n    align: 'center',\n  },\n  tooltip: {\n    show: true,\n  },\n  axes: {\n    x: { show: true },\n    y: { show: true, format: (value: number) => `$${value}` },\n  },\n  animations: {\n    enabled: true,\n    duration: 300,\n    easing: 'ease-out',\n  },\n}\n\ndescribe('BarChart', () => {\n  const defaultProps = {\n    data: mockData,\n    config: mockConfig,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: false,\n    colors: ['#3F51B5', '#B19ADA'],\n  }\n\n  it('renders bar chart correctly', () => {\n    render(<BarChart {...defaultProps} />)\n\n    expect(screen.getByTestId('recharts-bar-chart')).toBeInTheDocument()\n    expect(screen.getByTestId('responsive-container')).toBeInTheDocument()\n    expect(screen.getByTestId('x-axis')).toBeInTheDocument()\n    expect(screen.getByTestId('y-axis')).toBeInTheDocument()\n    expect(screen.getByTestId('cartesian-grid')).toBeInTheDocument()\n    expect(screen.getByTestId('tooltip')).toBeInTheDocument()\n    expect(screen.getByTestId('legend')).toBeInTheDocument()\n  })\n\n  it('renders multiple datasets as bars', () => {\n    render(<BarChart {...defaultProps} />)\n\n    expect(screen.getByTestId('bar-Dataset 1')).toBeInTheDocument()\n    expect(screen.getByTestId('bar-Dataset 2')).toBeInTheDocument()\n    expect(screen.getByText('Bar: Dataset 1')).toBeInTheDocument()\n    expect(screen.getByText('Bar: Dataset 2')).toBeInTheDocument()\n  })\n\n  it('transforms data correctly for Recharts', () => {\n    render(<BarChart {...defaultProps} />)\n\n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n\n    expect(chartData).toHaveLength(4) // Q1, Q2, Q3, Q4\n    expect(chartData[0]).toEqual({\n      x: 'Q1',\n      'Dataset 1': 100,\n      'Dataset 2': 80,\n    })\n    expect(chartData[1]).toEqual({\n      x: 'Q2',\n      'Dataset 1': 200,\n      'Dataset 2': 180,\n    })\n    expect(chartData[2]).toEqual({\n      x: 'Q3',\n      'Dataset 1': 150,\n      'Dataset 2': 120,\n    })\n    expect(chartData[3]).toEqual({\n      x: 'Q4',\n      'Dataset 1': 300,\n      'Dataset 2': 250,\n    })\n  })\n\n  it('handles bar click events', async () => {\n    const user = userEvent.setup()\n    const onDataClick = jest.fn()\n\n    render(<BarChart {...defaultProps} onDataClick={onDataClick} />)\n\n    await user.click(screen.getByTestId('bar-Dataset 1'))\n\n    expect(onDataClick).toHaveBeenCalledWith({\n      x: undefined,\n      y: 100,\n      value: 100,\n      label: undefined,\n    })\n  })\n\n  it('handles legend click events', async () => {\n    const user = userEvent.setup()\n    const onLegendClick = jest.fn()\n\n    render(<BarChart {...defaultProps} onLegendClick={onLegendClick} />)\n\n    await user.click(screen.getByTestId('legend'))\n\n    expect(onLegendClick).toHaveBeenCalledWith({\n      label: 'Test',\n      color: '#000',\n      visible: true,\n    })\n  })\n\n  it('applies Y-axis formatter when provided', () => {\n    render(<BarChart {...defaultProps} />)\n\n    expect(screen.getByText('YAxis (formatted)')).toBeInTheDocument()\n  })\n\n  it('hides axes when configured', () => {\n    const configWithHiddenAxes = {\n      ...mockConfig,\n      axes: {\n        x: { show: false },\n        y: { show: false },\n      },\n    }\n\n    render(<BarChart {...defaultProps} config={configWithHiddenAxes} />)\n\n    expect(screen.queryByTestId('x-axis')).not.toBeInTheDocument()\n    expect(screen.queryByTestId('y-axis')).not.toBeInTheDocument()\n  })\n\n  it('hides tooltip when configured', () => {\n    const configWithHiddenTooltip = {\n      ...mockConfig,\n      tooltip: { show: false },\n    }\n\n    render(<BarChart {...defaultProps} config={configWithHiddenTooltip} />)\n\n    expect(screen.queryByTestId('tooltip')).not.toBeInTheDocument()\n  })\n\n  it('hides legend when configured', () => {\n    const configWithHiddenLegend = {\n      ...mockConfig,\n      legend: { show: false, position: 'bottom' as const, align: 'center' as const },\n    }\n\n    render(<BarChart {...defaultProps} config={configWithHiddenLegend} />)\n\n    expect(screen.queryByTestId('legend')).not.toBeInTheDocument()\n  })\n\n  it('handles empty data gracefully', () => {\n    const emptyData: ChartData = { datasets: [] }\n\n    render(<BarChart {...defaultProps} data={emptyData} />)\n\n    expect(screen.getByTestId('recharts-bar-chart')).toBeInTheDocument()\n    \n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n    expect(chartData).toHaveLength(0)\n  })\n\n  it('sorts categories correctly', () => {\n    const unsortedData: ChartData = {\n      datasets: [\n        {\n          label: 'Test',\n          data: [\n            { x: 'Q3', y: 150 },\n            { x: 'Q1', y: 100 },\n            { x: 'Q4', y: 300 },\n            { x: 'Q2', y: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<BarChart {...defaultProps} data={unsortedData} />)\n\n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n\n    expect(chartData[0].x).toBe('Q1')\n    expect(chartData[1].x).toBe('Q2')\n    expect(chartData[2].x).toBe('Q3')\n    expect(chartData[3].x).toBe('Q4')\n  })\n\n  it('handles numeric categories', () => {\n    const numericData: ChartData = {\n      datasets: [\n        {\n          label: 'Test',\n          data: [\n            { x: 2023, y: 150 },\n            { x: 2021, y: 100 },\n            { x: 2022, y: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<BarChart {...defaultProps} data={numericData} />)\n\n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n\n    expect(chartData[0].x).toBe(2021)\n    expect(chartData[1].x).toBe(2022)\n    expect(chartData[2].x).toBe(2023)\n  })\n\n  it('handles missing data points', () => {\n    const sparseData: ChartData = {\n      datasets: [\n        {\n          label: 'Dataset 1',\n          data: [\n            { x: 'Q1', y: 100 },\n            { x: 'Q3', y: 150 },\n          ],\n        },\n        {\n          label: 'Dataset 2',\n          data: [\n            { x: 'Q1', y: 80 },\n            { x: 'Q2', y: 180 },\n            { x: 'Q3', y: 120 },\n          ],\n        },\n      ],\n    }\n\n    render(<BarChart {...defaultProps} data={sparseData} />)\n\n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n\n    expect(chartData).toHaveLength(3) // Q1, Q2, Q3\n    expect(chartData[0]).toEqual({\n      x: 'Q1',\n      'Dataset 1': 100,\n      'Dataset 2': 80,\n    })\n    expect(chartData[1]).toEqual({\n      x: 'Q2',\n      'Dataset 1': 0, // Missing data should default to 0\n      'Dataset 2': 180,\n    })\n    expect(chartData[2]).toEqual({\n      x: 'Q3',\n      'Dataset 1': 150,\n      'Dataset 2': 120,\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/__tests__/heatmap-chart.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [371, 374], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [371, 374], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'user' is assigned a value but never used.",
        "line": 137,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 137,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { HeatmapChart } from '../heatmap-chart'\nimport type { ChartData, ChartConfiguration } from '@/types/dashboard'\n\n// Mock Recharts ResponsiveContainer\njest.mock('recharts', () => ({\n  ResponsiveContainer: ({ children }: any) => (\n    <div data-testid=\"responsive-container\">{children}</div>\n  ),\n}))\n\nconst mockData: ChartData = {\n  datasets: [\n    {\n      label: 'Heatmap Data',\n      data: [\n        { x: 'Mon', y: 'Morning', value: 10 },\n        { x: 'Mon', y: 'Afternoon', value: 20 },\n        { x: 'Mon', y: 'Evening', value: 15 },\n        { x: 'Tue', y: 'Morning', value: 25 },\n        { x: 'Tue', y: 'Afternoon', value: 30 },\n        { x: 'Tue', y: 'Evening', value: 18 },\n        { x: 'Wed', y: 'Morning', value: 12 },\n        { x: 'Wed', y: 'Afternoon', value: 22 },\n        { x: 'Wed', y: 'Evening', value: 28 },\n      ],\n    },\n  ],\n  metadata: {\n    title: 'Weekly Activity Heatmap',\n  },\n}\n\nconst mockConfig: ChartConfiguration = {\n  colors: {\n    primary: '#3F51B5',\n    secondary: '#B19ADA',\n    accent: '#FF6B35',\n    success: '#10B981',\n    warning: '#F59E0B',\n    error: '#EF4444',\n  },\n  legend: {\n    show: true,\n    position: 'bottom',\n    align: 'center',\n  },\n  tooltip: {\n    show: true,\n    format: (value: number) => `${value} units`,\n  },\n}\n\ndescribe('HeatmapChart', () => {\n  const defaultProps = {\n    data: mockData,\n    config: mockConfig,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: false,\n    colors: ['#3F51B5'],\n  }\n\n  it('renders heatmap chart correctly', () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    expect(screen.getByTestId('responsive-container')).toBeInTheDocument()\n    expect(screen.getByText('Weekly Activity Heatmap')).toBeInTheDocument()\n  })\n\n  it('renders axis labels correctly', () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    // X-axis labels\n    expect(screen.getByText('Mon')).toBeInTheDocument()\n    expect(screen.getByText('Tue')).toBeInTheDocument()\n    expect(screen.getByText('Wed')).toBeInTheDocument()\n\n    // Y-axis labels\n    expect(screen.getByText('Morning')).toBeInTheDocument()\n    expect(screen.getByText('Afternoon')).toBeInTheDocument()\n    expect(screen.getByText('Evening')).toBeInTheDocument()\n  })\n\n  it('sorts axis labels correctly', () => {\n    const unsortedData: ChartData = {\n      datasets: [\n        {\n          label: 'Test',\n          data: [\n            { x: 'Wed', y: 'Evening', value: 10 },\n            { x: 'Mon', y: 'Morning', value: 20 },\n            { x: 'Tue', y: 'Afternoon', value: 15 },\n          ],\n        },\n      ],\n    }\n\n    render(<HeatmapChart {...defaultProps} data={unsortedData} />)\n\n    // Labels should be sorted alphabetically\n    const xLabels = screen.getAllByText(/Mon|Tue|Wed/)\n    const yLabels = screen.getAllByText(/Morning|Afternoon|Evening/)\n\n    expect(xLabels.length).toBeGreaterThan(0)\n    expect(yLabels.length).toBeGreaterThan(0)\n  })\n\n  it('handles numeric axis values', () => {\n    const numericData: ChartData = {\n      datasets: [\n        {\n          label: 'Numeric Data',\n          data: [\n            { x: 2023, y: 1, value: 10 },\n            { x: 2022, y: 2, value: 20 },\n            { x: 2021, y: 3, value: 15 },\n          ],\n        },\n      ],\n    }\n\n    render(<HeatmapChart {...defaultProps} data={numericData} />)\n\n    expect(screen.getByText('2021')).toBeInTheDocument()\n    expect(screen.getByText('2022')).toBeInTheDocument()\n    expect(screen.getByText('2023')).toBeInTheDocument()\n    expect(screen.getByText('1')).toBeInTheDocument()\n    expect(screen.getByText('2')).toBeInTheDocument()\n    expect(screen.getByText('3')).toBeInTheDocument()\n  })\n\n  it('handles cell click events', async () => {\n    const user = userEvent.setup()\n    const onDataClick = jest.fn()\n\n    render(<HeatmapChart {...defaultProps} onDataClick={onDataClick} />)\n\n    // Find and click a cell (SVG rect element)\n    const cells = document.querySelectorAll('rect')\n    expect(cells.length).toBeGreaterThan(0)\n\n    fireEvent.click(cells[0])\n\n    expect(onDataClick).toHaveBeenCalled()\n  })\n\n  it('shows tooltip on mouse enter', async () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    const cells = document.querySelectorAll('rect')\n    expect(cells.length).toBeGreaterThan(0)\n\n    // Simulate mouse enter\n    fireEvent.mouseEnter(cells[0], {\n      clientX: 100,\n      clientY: 100,\n    })\n\n    // Tooltip should appear (though we can't easily test the positioning)\n    // The tooltip is rendered conditionally based on state\n  })\n\n  it('hides tooltip on mouse leave', async () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    const cells = document.querySelectorAll('rect')\n    expect(cells.length).toBeGreaterThan(0)\n\n    // Simulate mouse enter then leave\n    fireEvent.mouseEnter(cells[0], {\n      clientX: 100,\n      clientY: 100,\n    })\n    fireEvent.mouseLeave(cells[0])\n\n    // Tooltip should be hidden\n  })\n\n  it('renders color legend when enabled', () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    // Should show min and max values in legend (with formatter applied)\n    expect(screen.getByText('10 units')).toBeInTheDocument() // Min value\n    expect(screen.getByText('30 units')).toBeInTheDocument() // Max value\n  })\n\n  it('hides color legend when disabled', () => {\n    const configWithoutLegend = {\n      ...mockConfig,\n      legend: { show: false, position: 'bottom' as const, align: 'center' as const },\n    }\n\n    render(<HeatmapChart {...defaultProps} config={configWithoutLegend} />)\n\n    // Legend should not be visible\n    // This is harder to test directly, but the component should not render the legend div\n  })\n\n  it('applies custom color based on value', () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    const cells = document.querySelectorAll('rect')\n    expect(cells.length).toBeGreaterThan(0)\n\n    // Each cell should have a fill color\n    cells.forEach(cell => {\n      expect(cell.getAttribute('fill')).toBeTruthy()\n    })\n  })\n\n  it('handles empty data gracefully', () => {\n    const emptyData: ChartData = { datasets: [] }\n\n    render(<HeatmapChart {...defaultProps} data={emptyData} />)\n\n    expect(screen.getByTestId('responsive-container')).toBeInTheDocument()\n    \n    // Should not render any cells\n    const cells = document.querySelectorAll('rect')\n    expect(cells.length).toBe(0)\n  })\n\n  it('handles data without x or y values', () => {\n    const invalidData: ChartData = {\n      datasets: [\n        {\n          label: 'Invalid Data',\n          data: [\n            { value: 10 }, // Missing x and y\n            { x: 'A', value: 20 }, // Missing y\n            { y: 'B', value: 15 }, // Missing x\n          ],\n        },\n      ],\n    }\n\n    render(<HeatmapChart {...defaultProps} data={invalidData} />)\n\n    expect(screen.getByTestId('responsive-container')).toBeInTheDocument()\n    \n    // Should handle gracefully without crashing\n  })\n\n  it('calculates min and max values correctly', () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    // Min value should be 10, max should be 30 based on mock data (with formatter applied)\n    expect(screen.getByText('10 units')).toBeInTheDocument()\n    expect(screen.getByText('30 units')).toBeInTheDocument()\n  })\n\n  it('handles single value data', () => {\n    const singleValueData: ChartData = {\n      datasets: [\n        {\n          label: 'Single Value',\n          data: [\n            { x: 'A', y: 'B', value: 50 },\n          ],\n        },\n      ],\n    }\n\n    render(<HeatmapChart {...defaultProps} data={singleValueData} />)\n\n    expect(screen.getByText('A')).toBeInTheDocument()\n    expect(screen.getByText('B')).toBeInTheDocument()\n    expect(screen.getAllByText('50 units')).toHaveLength(2) // Min and max are the same\n  })\n\n  it('applies tooltip formatter when provided', () => {\n    render(<HeatmapChart {...defaultProps} />)\n\n    const cells = document.querySelectorAll('rect')\n    expect(cells.length).toBeGreaterThan(0)\n\n    // Simulate mouse enter to show tooltip\n    fireEvent.mouseEnter(cells[0], {\n      clientX: 100,\n      clientY: 100,\n    })\n\n    // The tooltip should use the formatter (though hard to test the exact content)\n  })\n\n  it('handles missing values in sparse data', () => {\n    const sparseData: ChartData = {\n      datasets: [\n        {\n          label: 'Sparse Data',\n          data: [\n            { x: 'A', y: '1', value: 10 },\n            { x: 'C', y: '1', value: 20 }, // Missing B,1\n            { x: 'A', y: '3', value: 15 }, // Missing A,2\n          ],\n        },\n      ],\n    }\n\n    render(<HeatmapChart {...defaultProps} data={sparseData} />)\n\n    expect(screen.getByText('A')).toBeInTheDocument()\n    expect(screen.getByText('C')).toBeInTheDocument()\n    expect(screen.getByText('1')).toBeInTheDocument()\n    expect(screen.getByText('3')).toBeInTheDocument()\n\n    // Should render cells for all combinations, with 0 values for missing data\n    const cells = document.querySelectorAll('rect')\n    expect(cells.length).toBeGreaterThan(0)\n  })\n\n  it('renders without title when not provided', () => {\n    const dataWithoutTitle: ChartData = {\n      datasets: [\n        {\n          label: 'Test',\n          data: [{ x: 'A', y: 'B', value: 10 }],\n        },\n      ],\n    }\n\n    render(<HeatmapChart {...defaultProps} data={dataWithoutTitle} />)\n\n    expect(screen.queryByText('Weekly Activity Heatmap')).not.toBeInTheDocument()\n    expect(screen.getByTestId('responsive-container')).toBeInTheDocument()\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/__tests__/line-chart.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [341, 344], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [341, 344], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [524, 527], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [524, 527], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 20,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 20,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [682, 685], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [682, 685], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'content' is defined but never used.",
        "line": 23,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 23,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 23,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 23,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [888, 891], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [888, 891], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 24,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 24,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [962, 965], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [962, 965], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 29,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 29,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1130, 1133], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1130, 1133], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 32,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 32,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1237, 1240], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1237, 1240], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 37,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 37,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1406, 1409], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1406, 1409], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 43,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 43,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1592, 1595], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1592, 1595], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 48,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 48,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1770, 1773], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1770, 1773], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { LineChart } from '../line-chart'\nimport type { ChartData, ChartConfiguration } from '@/types/dashboard'\n\n// Mock Recharts components\njest.mock('recharts', () => ({\n  LineChart: ({ children, data }: any) => (\n    <div data-testid=\"recharts-line-chart\">\n      {children}\n      <div data-testid=\"chart-data\">{JSON.stringify(data)}</div>\n    </div>\n  ),\n  Line: ({ dataKey, onClick }: any) => (\n    <div data-testid={`line-${dataKey}`} onClick={() => onClick?.({ value: 100 }, 0)}>\n      Line: {dataKey}\n    </div>\n  ),\n  XAxis: ({ dataKey }: any) => <div data-testid=\"x-axis\">XAxis: {dataKey}</div>,\n  YAxis: () => <div data-testid=\"y-axis\">YAxis</div>,\n  CartesianGrid: () => <div data-testid=\"cartesian-grid\">Grid</div>,\n  Tooltip: ({ content }: any) => <div data-testid=\"tooltip\">Tooltip</div>,\n  Legend: ({ onClick }: any) => (\n    <div data-testid=\"legend\" onClick={() => onClick?.({ value: 'Test', color: '#000' })}>\n      Legend\n    </div>\n  ),\n  ResponsiveContainer: ({ children }: any) => (\n    <div data-testid=\"responsive-container\">{children}</div>\n  ),\n  Area: ({ dataKey, onClick }: any) => (\n    <div data-testid={`area-${dataKey}`} onClick={() => onClick?.({ value: 100 }, 0)}>\n      Area: {dataKey}\n    </div>\n  ),\n  AreaChart: ({ children, data }: any) => (\n    <div data-testid=\"recharts-area-chart\">\n      {children}\n      <div data-testid=\"chart-data\">{JSON.stringify(data)}</div>\n    </div>\n  ),\n  Scatter: ({ dataKey, onClick }: any) => (\n    <div data-testid={`scatter-${dataKey}`} onClick={() => onClick?.({ value: 100 }, 0)}>\n      Scatter: {dataKey}\n    </div>\n  ),\n  ScatterChart: ({ children, data }: any) => (\n    <div data-testid=\"recharts-scatter-chart\">\n      {children}\n      <div data-testid=\"chart-data\">{JSON.stringify(data)}</div>\n    </div>\n  ),\n}))\n\nconst mockData: ChartData = {\n  datasets: [\n    {\n      label: 'Dataset 1',\n      data: [\n        { x: 'Jan', y: 100 },\n        { x: 'Feb', y: 200 },\n        { x: 'Mar', y: 150 },\n      ],\n    },\n    {\n      label: 'Dataset 2',\n      data: [\n        { x: 'Jan', y: 80 },\n        { x: 'Feb', y: 180 },\n        { x: 'Mar', y: 120 },\n      ],\n    },\n  ],\n}\n\nconst mockConfig: ChartConfiguration = {\n  colors: {\n    primary: '#3F51B5',\n    secondary: '#B19ADA',\n    accent: '#FF6B35',\n    success: '#10B981',\n    warning: '#F59E0B',\n    error: '#EF4444',\n  },\n  legend: {\n    show: true,\n    position: 'bottom',\n    align: 'center',\n  },\n  tooltip: {\n    show: true,\n  },\n  axes: {\n    x: { show: true },\n    y: { show: true },\n  },\n  animations: {\n    enabled: true,\n    duration: 300,\n    easing: 'ease-out',\n  },\n}\n\ndescribe('LineChart', () => {\n  const defaultProps = {\n    data: mockData,\n    config: mockConfig,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: false,\n    colors: ['#3F51B5', '#B19ADA'],\n  }\n\n  it('renders line chart correctly', () => {\n    render(<LineChart {...defaultProps} />)\n\n    expect(screen.getByTestId('recharts-line-chart')).toBeInTheDocument()\n    expect(screen.getByTestId('responsive-container')).toBeInTheDocument()\n    expect(screen.getByTestId('x-axis')).toBeInTheDocument()\n    expect(screen.getByTestId('y-axis')).toBeInTheDocument()\n    expect(screen.getByTestId('cartesian-grid')).toBeInTheDocument()\n    expect(screen.getByTestId('tooltip')).toBeInTheDocument()\n    expect(screen.getByTestId('legend')).toBeInTheDocument()\n  })\n\n  it('renders multiple datasets as lines', () => {\n    render(<LineChart {...defaultProps} />)\n\n    expect(screen.getByTestId('line-Dataset 1')).toBeInTheDocument()\n    expect(screen.getByTestId('line-Dataset 2')).toBeInTheDocument()\n    expect(screen.getByText('Line: Dataset 1')).toBeInTheDocument()\n    expect(screen.getByText('Line: Dataset 2')).toBeInTheDocument()\n  })\n\n  it('transforms data correctly for Recharts', () => {\n    render(<LineChart {...defaultProps} />)\n\n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n\n    expect(chartData).toHaveLength(3) // Jan, Feb, Mar\n    expect(chartData[0]).toEqual({\n      x: 'Feb',\n      'Dataset 1': 200,\n      'Dataset 2': 180,\n    })\n    expect(chartData[1]).toEqual({\n      x: 'Jan',\n      'Dataset 1': 100,\n      'Dataset 2': 80,\n    })\n    expect(chartData[2]).toEqual({\n      x: 'Mar',\n      'Dataset 1': 150,\n      'Dataset 2': 120,\n    })\n  })\n\n  it('handles data click events', async () => {\n    const user = userEvent.setup()\n    const onDataClick = jest.fn()\n\n    render(<LineChart {...defaultProps} onDataClick={onDataClick} />)\n\n    await user.click(screen.getByTestId('line-Dataset 1'))\n\n    expect(onDataClick).toHaveBeenCalledWith({\n      x: undefined,\n      y: 100,\n      value: 100,\n      label: undefined,\n    })\n  })\n\n  it('handles legend click events', async () => {\n    const user = userEvent.setup()\n    const onLegendClick = jest.fn()\n\n    render(<LineChart {...defaultProps} onLegendClick={onLegendClick} />)\n\n    await user.click(screen.getByTestId('legend'))\n\n    expect(onLegendClick).toHaveBeenCalledWith({\n      label: 'Test',\n      color: '#000',\n      visible: true,\n    })\n  })\n\n  it('renders as area chart when area prop is true', () => {\n    render(<LineChart {...defaultProps} area={true} />)\n\n    expect(screen.getByTestId('recharts-area-chart')).toBeInTheDocument()\n    expect(screen.getByTestId('area-Dataset 1')).toBeInTheDocument()\n    expect(screen.getByTestId('area-Dataset 2')).toBeInTheDocument()\n  })\n\n  it('renders as scatter chart when scatter prop is true', () => {\n    render(<LineChart {...defaultProps} scatter={true} />)\n\n    expect(screen.getByTestId('recharts-scatter-chart')).toBeInTheDocument()\n    expect(screen.getByTestId('scatter-Dataset 1')).toBeInTheDocument()\n    expect(screen.getByTestId('scatter-Dataset 2')).toBeInTheDocument()\n  })\n\n  it('hides axes when configured', () => {\n    const configWithHiddenAxes = {\n      ...mockConfig,\n      axes: {\n        x: { show: false },\n        y: { show: false },\n      },\n    }\n\n    render(<LineChart {...defaultProps} config={configWithHiddenAxes} />)\n\n    expect(screen.queryByTestId('x-axis')).not.toBeInTheDocument()\n    expect(screen.queryByTestId('y-axis')).not.toBeInTheDocument()\n  })\n\n  it('hides tooltip when configured', () => {\n    const configWithHiddenTooltip = {\n      ...mockConfig,\n      tooltip: { show: false },\n    }\n\n    render(<LineChart {...defaultProps} config={configWithHiddenTooltip} />)\n\n    expect(screen.queryByTestId('tooltip')).not.toBeInTheDocument()\n  })\n\n  it('hides legend when configured', () => {\n    const configWithHiddenLegend = {\n      ...mockConfig,\n      legend: { show: false, position: 'bottom' as const, align: 'center' as const },\n    }\n\n    render(<LineChart {...defaultProps} config={configWithHiddenLegend} />)\n\n    expect(screen.queryByTestId('legend')).not.toBeInTheDocument()\n  })\n\n  it('handles empty data gracefully', () => {\n    const emptyData: ChartData = { datasets: [] }\n\n    render(<LineChart {...defaultProps} data={emptyData} />)\n\n    expect(screen.getByTestId('recharts-line-chart')).toBeInTheDocument()\n    \n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n    expect(chartData).toHaveLength(0)\n  })\n\n  it('sorts x values correctly', () => {\n    const unsortedData: ChartData = {\n      datasets: [\n        {\n          label: 'Test',\n          data: [\n            { x: 'Mar', y: 150 },\n            { x: 'Jan', y: 100 },\n            { x: 'Feb', y: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<LineChart {...defaultProps} data={unsortedData} />)\n\n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n\n    // String sorting is alphabetical: Feb, Jan, Mar\n    expect(chartData[0].x).toBe('Feb')\n    expect(chartData[1].x).toBe('Jan')\n    expect(chartData[2].x).toBe('Mar')\n  })\n\n  it('handles numeric x values', () => {\n    const numericData: ChartData = {\n      datasets: [\n        {\n          label: 'Test',\n          data: [\n            { x: 3, y: 150 },\n            { x: 1, y: 100 },\n            { x: 2, y: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<LineChart {...defaultProps} data={numericData} />)\n\n    const chartDataElement = screen.getByTestId('chart-data')\n    const chartData = JSON.parse(chartDataElement.textContent || '[]')\n\n    expect(chartData[0].x).toBe(1)\n    expect(chartData[1].x).toBe(2)\n    expect(chartData[2].x).toBe(3)\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/__tests__/pie-chart.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [332, 335], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [332, 335], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'label' is defined but never used.",
        "line": 12,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 12,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 12,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 12,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [440, 443], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [440, 443], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [564, 567], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [564, 567], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 26,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 26,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [832, 835], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [832, 835], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'content' is defined but never used.",
        "line": 27,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 27,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 27,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 27,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [931, 934], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [931, 934], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'content' is defined but never used.",
        "line": 28,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 28,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 28,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 28,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1005, 1008], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1005, 1008], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 29,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 29,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1091, 1094], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1091, 1094], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { PieChart } from '../pie-chart'\nimport type { ChartData, ChartConfiguration } from '@/types/dashboard'\n\n// Mock Recharts components\njest.mock('recharts', () => ({\n  PieChart: ({ children }: any) => (\n    <div data-testid=\"recharts-pie-chart\">{children}</div>\n  ),\n  Pie: ({ data, onClick, label }: any) => (\n    <div data-testid=\"pie\">\n      <div data-testid=\"pie-data\">{JSON.stringify(data)}</div>\n      {data.map((item: any, index: number) => (\n        <div\n          key={index}\n          data-testid={`pie-slice-${index}`}\n          onClick={() => onClick?.(item, index)}\n        >\n          Slice: {item.name} ({item.value})\n        </div>\n      ))}\n    </div>\n  ),\n  Cell: ({ fill }: any) => <div data-testid=\"pie-cell\" style={{ backgroundColor: fill }} />,\n  Tooltip: ({ content }: any) => <div data-testid=\"tooltip\">Tooltip</div>,\n  Legend: ({ content }: any) => <div data-testid=\"legend\">Legend</div>,\n  ResponsiveContainer: ({ children }: any) => (\n    <div data-testid=\"responsive-container\">{children}</div>\n  ),\n}))\n\nconst mockData: ChartData = {\n  datasets: [\n    {\n      label: 'Categories',\n      data: [\n        { label: 'Category A', value: 100, color: '#3F51B5' },\n        { label: 'Category B', value: 200, color: '#B19ADA' },\n        { label: 'Category C', value: 150, color: '#FF6B35' },\n        { label: 'Category D', value: 50, color: '#10B981' },\n      ],\n    },\n  ],\n}\n\nconst mockConfig: ChartConfiguration = {\n  colors: {\n    primary: '#3F51B5',\n    secondary: '#B19ADA',\n    accent: '#FF6B35',\n    success: '#10B981',\n    warning: '#F59E0B',\n    error: '#EF4444',\n  },\n  legend: {\n    show: true,\n    position: 'bottom',\n    align: 'center',\n  },\n  tooltip: {\n    show: true,\n  },\n  animations: {\n    enabled: true,\n    duration: 300,\n    easing: 'ease-out',\n  },\n}\n\ndescribe('PieChart', () => {\n  const defaultProps = {\n    data: mockData,\n    config: mockConfig,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: false,\n    colors: ['#3F51B5', '#B19ADA', '#FF6B35', '#10B981'],\n  }\n\n  it('renders pie chart correctly', () => {\n    render(<PieChart {...defaultProps} />)\n\n    expect(screen.getByTestId('recharts-pie-chart')).toBeInTheDocument()\n    expect(screen.getByTestId('responsive-container')).toBeInTheDocument()\n    expect(screen.getByTestId('pie')).toBeInTheDocument()\n    expect(screen.getByTestId('tooltip')).toBeInTheDocument()\n    expect(screen.getByTestId('legend')).toBeInTheDocument()\n  })\n\n  it('transforms data correctly for pie chart', () => {\n    render(<PieChart {...defaultProps} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n\n    expect(pieData).toHaveLength(4)\n    expect(pieData[0]).toEqual({\n      name: 'Category A',\n      value: 100,\n      color: '#3F51B5',\n      originalData: mockData.datasets[0].data[0],\n    })\n    expect(pieData[1]).toEqual({\n      name: 'Category B',\n      value: 200,\n      color: '#B19ADA',\n      originalData: mockData.datasets[0].data[1],\n    })\n  })\n\n  it('renders pie slices with correct data', () => {\n    render(<PieChart {...defaultProps} />)\n\n    expect(screen.getByText('Slice: Category A (100)')).toBeInTheDocument()\n    expect(screen.getByText('Slice: Category B (200)')).toBeInTheDocument()\n    expect(screen.getByText('Slice: Category C (150)')).toBeInTheDocument()\n    expect(screen.getByText('Slice: Category D (50)')).toBeInTheDocument()\n  })\n\n  it('handles slice click events', async () => {\n    const user = userEvent.setup()\n    const onDataClick = jest.fn()\n\n    render(<PieChart {...defaultProps} onDataClick={onDataClick} />)\n\n    await user.click(screen.getByTestId('pie-slice-0'))\n\n    expect(onDataClick).toHaveBeenCalledWith({\n      x: 'Category A',\n      y: 100,\n      value: 100,\n      label: 'Category A',\n      color: '#3F51B5',\n      metadata: mockData.datasets[0].data[0].metadata,\n    })\n  })\n\n  it('uses fallback colors when data colors are not provided', () => {\n    const dataWithoutColors: ChartData = {\n      datasets: [\n        {\n          label: 'Categories',\n          data: [\n            { label: 'Category A', value: 100 },\n            { label: 'Category B', value: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<PieChart {...defaultProps} data={dataWithoutColors} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n\n    expect(pieData[0].color).toBe('#3F51B5') // First color from props\n    expect(pieData[1].color).toBe('#B19ADA') // Second color from props\n  })\n\n  it('generates labels from x values when label is not provided', () => {\n    const dataWithXValues: ChartData = {\n      datasets: [\n        {\n          label: 'Categories',\n          data: [\n            { x: 'A', value: 100 },\n            { x: 'B', value: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<PieChart {...defaultProps} data={dataWithXValues} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n\n    expect(pieData[0].name).toBe('A')\n    expect(pieData[1].name).toBe('B')\n  })\n\n  it('generates fallback labels when neither label nor x is provided', () => {\n    const dataWithoutLabels: ChartData = {\n      datasets: [\n        {\n          label: 'Categories',\n          data: [\n            { value: 100 },\n            { value: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<PieChart {...defaultProps} data={dataWithoutLabels} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n\n    expect(pieData[0].name).toBe('Item 1')\n    expect(pieData[1].name).toBe('Item 2')\n  })\n\n  it('uses y value when value is not provided', () => {\n    const dataWithYValues: ChartData = {\n      datasets: [\n        {\n          label: 'Categories',\n          data: [\n            { label: 'Category A', y: 100 },\n            { label: 'Category B', y: 200 },\n          ],\n        },\n      ],\n    }\n\n    render(<PieChart {...defaultProps} data={dataWithYValues} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n\n    expect(pieData[0].value).toBe(100)\n    expect(pieData[1].value).toBe(200)\n  })\n\n  it('hides tooltip when configured', () => {\n    const configWithHiddenTooltip = {\n      ...mockConfig,\n      tooltip: { show: false },\n    }\n\n    render(<PieChart {...defaultProps} config={configWithHiddenTooltip} />)\n\n    expect(screen.queryByTestId('tooltip')).not.toBeInTheDocument()\n  })\n\n  it('hides legend when configured', () => {\n    const configWithHiddenLegend = {\n      ...mockConfig,\n      legend: { show: false, position: 'bottom' as const, align: 'center' as const },\n    }\n\n    render(<PieChart {...defaultProps} config={configWithHiddenLegend} />)\n\n    expect(screen.queryByTestId('legend')).not.toBeInTheDocument()\n  })\n\n  it('handles empty data gracefully', () => {\n    const emptyData: ChartData = { datasets: [] }\n\n    render(<PieChart {...defaultProps} data={emptyData} />)\n\n    expect(screen.getByTestId('recharts-pie-chart')).toBeInTheDocument()\n    \n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n    expect(pieData).toHaveLength(0)\n  })\n\n  it('handles dataset without data', () => {\n    const datasetWithoutData: ChartData = {\n      datasets: [\n        {\n          label: 'Empty Dataset',\n          data: [],\n        },\n      ],\n    }\n\n    render(<PieChart {...defaultProps} data={datasetWithoutData} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n    expect(pieData).toHaveLength(0)\n  })\n\n  it('handles zero values', () => {\n    const dataWithZeros: ChartData = {\n      datasets: [\n        {\n          label: 'Categories',\n          data: [\n            { label: 'Category A', value: 0 },\n            { label: 'Category B', value: 200 },\n            { label: 'Category C', value: 0 },\n          ],\n        },\n      ],\n    }\n\n    render(<PieChart {...defaultProps} data={dataWithZeros} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n\n    expect(pieData).toHaveLength(3)\n    expect(pieData[0].value).toBe(0)\n    expect(pieData[1].value).toBe(200)\n    expect(pieData[2].value).toBe(0)\n  })\n\n  it('cycles through colors when there are more data points than colors', () => {\n    const manyDataPoints: ChartData = {\n      datasets: [\n        {\n          label: 'Categories',\n          data: [\n            { label: 'A', value: 100 },\n            { label: 'B', value: 200 },\n            { label: 'C', value: 150 },\n            { label: 'D', value: 50 },\n            { label: 'E', value: 75 }, // Should cycle back to first color\n          ],\n        },\n      ],\n    }\n\n    render(<PieChart {...defaultProps} data={manyDataPoints} />)\n\n    const pieDataElement = screen.getByTestId('pie-data')\n    const pieData = JSON.parse(pieDataElement.textContent || '[]')\n\n    expect(pieData[0].color).toBe('#3F51B5') // First color\n    expect(pieData[4].color).toBe('#3F51B5') // Cycles back to first color\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/bar-chart.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 56,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 56,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1410, 1413], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1410, 1413], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'index' is defined but never used.",
        "line": 58,
        "column": 39,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 68,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 68,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1721, 1724], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1721, 1724], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 92,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 92,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2517, 2520], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2517, 2520], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 109,
        "column": 54,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 109,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2912, 2915], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2912, 2915], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 115,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 115,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3185, 3188], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3185, 3188], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport {\n  BarChart as RechartsBarChart,\n  Bar,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n} from 'recharts'\nimport type { ChartData, ChartConfiguration, ChartDataPoint, LegendItem } from '@/types/dashboard'\n\ninterface BarChartProps {\n  data: ChartData\n  config: ChartConfiguration\n  height: number\n  responsive: boolean\n  interactive: boolean\n  exportable: boolean\n  onDataClick?: (data: ChartDataPoint) => void\n  onLegendClick?: (legendItem: LegendItem) => void\n  colors: string[]\n}\n\nexport function BarChart({\n  data,\n  config,\n  height,\n  responsive,\n  interactive,\n  onDataClick,\n  onLegendClick,\n  colors,\n}: BarChartProps) {\n  // Transform data for Recharts format\n  const chartData = React.useMemo(() => {\n    if (!data.datasets || data.datasets.length === 0) return []\n\n    // Get all unique x values (categories)\n    const allXValues = new Set<string | number>()\n    data.datasets.forEach(dataset => {\n      dataset.data.forEach(point => {\n        if (point.x !== undefined) allXValues.add(point.x)\n      })\n    })\n\n    // Convert to array and sort\n    const sortedXValues = Array.from(allXValues).sort((a, b) => {\n      if (typeof a === 'number' && typeof b === 'number') return a - b\n      return String(a).localeCompare(String(b))\n    })\n\n    // Create chart data points\n    return sortedXValues.map(xValue => {\n      const dataPoint: any = { x: xValue }\n      \n      data.datasets.forEach((dataset, index) => {\n        const point = dataset.data.find(p => p.x === xValue)\n        dataPoint[dataset.label] = point?.y || point?.value || 0\n      })\n\n      return dataPoint\n    })\n  }, [data])\n\n  // Handle bar click\n  const handleBarClick = (data: any, index: number, event?: React.MouseEvent) => {\n    if (!interactive || !onDataClick) return\n    \n    // Find the clicked series from the event target or use first non-x key\n    const clickedSeries = event?.currentTarget?.getAttribute('data-key') || \n                         Object.keys(data).find(key => key !== 'x') || ''\n    \n    const chartDataPoint: ChartDataPoint = {\n      x: data.x,\n      y: data[clickedSeries] || 0,\n      value: data[clickedSeries] || 0,\n      label: data.x?.toString(),\n      metadata: {\n        category: data.x,\n        series: clickedSeries,\n        index,\n        chartType: 'bar',\n        allData: data, // Include all data for advanced filtering\n      },\n    }\n    onDataClick(chartDataPoint)\n  }\n\n  // Handle legend click\n  const handleLegendClick = (data: any, index: number) => {\n    if (!interactive || !onLegendClick) return\n    \n    const legendItem: LegendItem = {\n      label: data.value,\n      color: data.color,\n      visible: true,\n      metadata: {\n        series: data.value,\n        chartType: 'bar',\n        index,\n      },\n    }\n    onLegendClick(legendItem)\n  }\n\n  // Custom tooltip\n  const CustomTooltip = ({ active, payload, label }: any) => {\n    if (!active || !payload || !payload.length) return null\n\n    return (\n      <div className=\"bg-background border border-border rounded-lg shadow-lg p-3\">\n        <p className=\"text-sm font-medium text-foreground mb-2\">{label}</p>\n        {payload.map((entry: any, index: number) => (\n          <div key={index} className=\"flex items-center gap-2 text-sm\">\n            <div \n              className=\"w-3 h-3 rounded-full\" \n              style={{ backgroundColor: entry.color }}\n            />\n            <span className=\"text-muted-foreground\">{entry.dataKey}:</span>\n            <span className=\"font-medium text-foreground\">\n              {config.tooltip?.format ? config.tooltip.format(entry.value) : entry.value}\n            </span>\n          </div>\n        ))}\n      </div>\n    )\n  }\n\n  const containerHeight = responsive ? height : height\n\n  return (\n    <ResponsiveContainer width=\"100%\" height={containerHeight}>\n      <RechartsBarChart \n        data={chartData} \n        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}\n      >\n        {config.axes?.x?.show && (\n          <XAxis \n            dataKey=\"x\" \n            axisLine={false}\n            tickLine={false}\n            tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n          />\n        )}\n        {config.axes?.y?.show && (\n          <YAxis \n            axisLine={false}\n            tickLine={false}\n            tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n            tickFormatter={config.axes?.y?.format}\n          />\n        )}\n        <CartesianGrid strokeDasharray=\"3 3\" stroke=\"hsl(var(--border))\" />\n        {config.tooltip?.show && <Tooltip content={<CustomTooltip />} />}\n        {config.legend?.show && (\n          <Legend \n            onClick={interactive ? handleLegendClick : undefined}\n            wrapperStyle={{ \n              paddingTop: '20px',\n              cursor: interactive ? 'pointer' : 'default'\n            }}\n          />\n        )}\n        {data.datasets.map((dataset, index) => (\n          <Bar\n            key={dataset.label}\n            dataKey={dataset.label}\n            fill={colors[index]}\n            onClick={interactive ? (data, index, event) => handleBarClick(data, index, event) : undefined}\n            style={{ cursor: interactive ? 'pointer' : 'default' }}\n            animationDuration={config.animations?.enabled ? config.animations.duration : 0}\n            radius={[4, 4, 0, 0]} // Rounded top corners\n          />\n        ))}\n      </RechartsBarChart>\n    </ResponsiveContainer>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/heatmap-chart.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'onLegendClick' is defined but never used.",
        "line": 32,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 32,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { ResponsiveContainer } from 'recharts'\nimport type { ChartData, ChartConfiguration, ChartDataPoint, LegendItem } from '@/types/dashboard'\n\ninterface HeatmapChartProps {\n  data: ChartData\n  config: ChartConfiguration\n  height: number\n  responsive: boolean\n  interactive: boolean\n  exportable: boolean\n  onDataClick?: (data: ChartDataPoint) => void\n  onLegendClick?: (legendItem: LegendItem) => void\n  colors: string[]\n}\n\ninterface HeatmapCell {\n  x: string | number\n  y: string | number\n  value: number\n  color: string\n  originalData: ChartDataPoint\n}\n\nexport function HeatmapChart({\n  data,\n  config,\n  height,\n  responsive,\n  interactive,\n  onDataClick,\n  onLegendClick,\n  colors,\n}: HeatmapChartProps) {\n  // Transform data for heatmap format\n  const { heatmapData, xLabels, yLabels, minValue, maxValue } = React.useMemo(() => {\n    if (!data.datasets || data.datasets.length === 0) {\n      return { heatmapData: [], xLabels: [], yLabels: [], minValue: 0, maxValue: 0 }\n    }\n\n    const allData: HeatmapCell[] = []\n    const xSet = new Set<string | number>()\n    const ySet = new Set<string | number>()\n    let min = Infinity\n    let max = -Infinity\n\n    // Collect all data points\n    data.datasets.forEach(dataset => {\n      dataset.data.forEach(point => {\n        if (point.x !== undefined && point.y !== undefined) {\n          const value = point.value || 0\n          xSet.add(point.x)\n          ySet.add(point.y)\n          min = Math.min(min, value)\n          max = Math.max(max, value)\n          \n          allData.push({\n            x: point.x,\n            y: point.y,\n            value,\n            color: point.color || '',\n            originalData: point,\n          })\n        }\n      })\n    })\n\n    const xLabels = Array.from(xSet).sort((a, b) => {\n      if (typeof a === 'number' && typeof b === 'number') return a - b\n      return String(a).localeCompare(String(b))\n    })\n\n    const yLabels = Array.from(ySet).sort((a, b) => {\n      if (typeof a === 'number' && typeof b === 'number') return a - b\n      return String(a).localeCompare(String(b))\n    })\n\n    return {\n      heatmapData: allData,\n      xLabels,\n      yLabels,\n      minValue: min === Infinity ? 0 : min,\n      maxValue: max === -Infinity ? 0 : max,\n    }\n  }, [data])\n\n  // Generate color based on value\n  const getColorForValue = (value: number): string => {\n    if (maxValue === minValue) return colors[0] || '#3F51B5'\n    \n    const normalizedValue = (value - minValue) / (maxValue - minValue)\n    \n    // Use a gradient from light to dark based on the primary color\n    const baseColor = colors[0] || '#3F51B5'\n    const opacity = 0.2 + (normalizedValue * 0.8) // Range from 0.2 to 1.0\n    \n    // Convert hex to rgba\n    const hex = baseColor.replace('#', '')\n    const r = parseInt(hex.substr(0, 2), 16)\n    const g = parseInt(hex.substr(2, 2), 16)\n    const b = parseInt(hex.substr(4, 2), 16)\n    \n    return `rgba(${r}, ${g}, ${b}, ${opacity})`\n  }\n\n  // Handle cell click\n  const handleCellClick = (cell: HeatmapCell) => {\n    if (!interactive || !onDataClick) return\n    \n    const chartDataPoint: ChartDataPoint = {\n      x: cell.x,\n      y: cell.y,\n      value: cell.value,\n      label: `${cell.x}, ${cell.y}`,\n      metadata: cell.originalData.metadata,\n    }\n    onDataClick(chartDataPoint)\n  }\n\n  // Calculate cell dimensions\n  const cellWidth = Math.max(40, (responsive ? 600 : 600) / Math.max(xLabels.length, 1))\n  const cellHeight = Math.max(30, (height - 100) / Math.max(yLabels.length, 1))\n  const chartWidth = cellWidth * xLabels.length + 100 // Add margin for labels\n  const chartHeight = cellHeight * yLabels.length + 100 // Add margin for labels\n\n  // Custom tooltip\n  const [tooltip, setTooltip] = React.useState<{\n    visible: boolean\n    x: number\n    y: number\n    data: HeatmapCell | null\n  }>({\n    visible: false,\n    x: 0,\n    y: 0,\n    data: null,\n  })\n\n  const handleMouseEnter = (event: React.MouseEvent, cell: HeatmapCell) => {\n    if (!config.tooltip?.show) return\n    \n    setTooltip({\n      visible: true,\n      x: event.clientX,\n      y: event.clientY,\n      data: cell,\n    })\n  }\n\n  const handleMouseLeave = () => {\n    setTooltip(prev => ({ ...prev, visible: false }))\n  }\n\n  const containerHeight = responsive ? Math.max(height, chartHeight) : height\n\n  return (\n    <div className=\"relative w-full\" style={{ height: containerHeight }}>\n      <ResponsiveContainer width=\"100%\" height={containerHeight}>\n        <div className=\"flex flex-col items-center\">\n          {/* Chart Title */}\n          {data.metadata?.title && (\n            <h3 className=\"text-lg font-semibold text-foreground mb-4\">\n              {data.metadata.title}\n            </h3>\n          )}\n          \n          {/* Heatmap Grid */}\n          <div className=\"relative\">\n            <svg\n              width={chartWidth}\n              height={chartHeight}\n              className=\"overflow-visible\"\n            >\n              {/* Y-axis labels */}\n              {yLabels.map((yLabel, yIndex) => (\n                <text\n                  key={`y-${yIndex}`}\n                  x={80}\n                  y={90 + yIndex * cellHeight + cellHeight / 2}\n                  textAnchor=\"end\"\n                  dominantBaseline=\"middle\"\n                  fontSize={12}\n                  fill=\"hsl(var(--muted-foreground))\"\n                >\n                  {yLabel}\n                </text>\n              ))}\n              \n              {/* X-axis labels */}\n              {xLabels.map((xLabel, xIndex) => (\n                <text\n                  key={`x-${xIndex}`}\n                  x={90 + xIndex * cellWidth + cellWidth / 2}\n                  y={80}\n                  textAnchor=\"middle\"\n                  dominantBaseline=\"middle\"\n                  fontSize={12}\n                  fill=\"hsl(var(--muted-foreground))\"\n                  transform={`rotate(-45, ${90 + xIndex * cellWidth + cellWidth / 2}, 80)`}\n                >\n                  {xLabel}\n                </text>\n              ))}\n              \n              {/* Heatmap cells */}\n              {yLabels.map((yLabel, yIndex) =>\n                xLabels.map((xLabel, xIndex) => {\n                  const cell = heatmapData.find(d => d.x === xLabel && d.y === yLabel)\n                  const value = cell?.value || 0\n                  const color = cell?.color || getColorForValue(value)\n                  \n                  return (\n                    <rect\n                      key={`cell-${xIndex}-${yIndex}`}\n                      x={90 + xIndex * cellWidth}\n                      y={90 + yIndex * cellHeight}\n                      width={cellWidth - 1}\n                      height={cellHeight - 1}\n                      fill={color}\n                      stroke=\"hsl(var(--border))\"\n                      strokeWidth={0.5}\n                      style={{ cursor: interactive ? 'pointer' : 'default' }}\n                      onClick={() => cell && handleCellClick(cell)}\n                      onMouseEnter={(e) => cell && handleMouseEnter(e, cell)}\n                      onMouseLeave={handleMouseLeave}\n                    />\n                  )\n                })\n              )}\n            </svg>\n          </div>\n          \n          {/* Color Legend */}\n          {config.legend?.show && (\n            <div className=\"flex items-center gap-4 mt-4\">\n              <span className=\"text-sm text-muted-foreground\">\n                {config.tooltip?.format ? config.tooltip.format(minValue) : minValue}\n              </span>\n              <div className=\"flex\">\n                {Array.from({ length: 10 }).map((_, index) => {\n                  const value = minValue + (index / 9) * (maxValue - minValue)\n                  return (\n                    <div\n                      key={index}\n                      className=\"w-4 h-4\"\n                      style={{ backgroundColor: getColorForValue(value) }}\n                    />\n                  )\n                })}\n              </div>\n              <span className=\"text-sm text-muted-foreground\">\n                {config.tooltip?.format ? config.tooltip.format(maxValue) : maxValue}\n              </span>\n            </div>\n          )}\n        </div>\n      </ResponsiveContainer>\n      \n      {/* Custom Tooltip */}\n      {tooltip.visible && tooltip.data && (\n        <div\n          className=\"absolute z-50 bg-background border border-border rounded-lg shadow-lg p-3 pointer-events-none\"\n          style={{\n            left: tooltip.x + 10,\n            top: tooltip.y - 10,\n          }}\n        >\n          <div className=\"text-sm\">\n            <div className=\"font-medium text-foreground\">\n              {tooltip.data.x}  {tooltip.data.y}\n            </div>\n            <div className=\"text-muted-foreground\">\n              Value: <span className=\"font-medium text-foreground\">\n                {config.tooltip?.format \n                  ? config.tooltip.format(tooltip.data.value) \n                  : tooltip.data.value\n                }\n              </span>\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/line-chart.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 64,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 64,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1523, 1526], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1523, 1526], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'index' is defined but never used.",
        "line": 66,
        "column": 39,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 66,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 76,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 76,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1842, 1845], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1842, 1845], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 100,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 100,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2705, 2708], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2705, 2708], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 117,
        "column": 54,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 117,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3139, 3142], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3139, 3142], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 123,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 123,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3412, 3415], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3412, 3415], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport {\n  LineChart as RechartsLineChart,\n  Line,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n  Area,\n  AreaChart,\n  Scatter,\n  ScatterChart,\n} from 'recharts'\nimport type { ChartData, ChartConfiguration, ChartDataPoint, LegendItem } from '@/types/dashboard'\n\ninterface LineChartProps {\n  data: ChartData\n  config: ChartConfiguration\n  height: number\n  responsive: boolean\n  interactive: boolean\n  exportable: boolean\n  onDataClick?: (data: ChartDataPoint) => void\n  onLegendClick?: (legendItem: LegendItem) => void\n  colors: string[]\n  area?: boolean\n  scatter?: boolean\n}\n\nexport function LineChart({\n  data,\n  config,\n  height,\n  responsive,\n  interactive,\n  onDataClick,\n  onLegendClick,\n  colors,\n  area = false,\n  scatter = false,\n}: LineChartProps) {\n  // Transform data for Recharts format\n  const chartData = React.useMemo(() => {\n    if (!data.datasets || data.datasets.length === 0) return []\n\n    // Get all unique x values\n    const allXValues = new Set<string | number>()\n    data.datasets.forEach(dataset => {\n      dataset.data.forEach(point => {\n        if (point.x !== undefined) allXValues.add(point.x)\n      })\n    })\n\n    // Convert to array and sort\n    const sortedXValues = Array.from(allXValues).sort((a, b) => {\n      if (typeof a === 'number' && typeof b === 'number') return a - b\n      return String(a).localeCompare(String(b))\n    })\n\n    // Create chart data points\n    return sortedXValues.map(xValue => {\n      const dataPoint: any = { x: xValue }\n      \n      data.datasets.forEach((dataset, index) => {\n        const point = dataset.data.find(p => p.x === xValue)\n        dataPoint[dataset.label] = point?.y || point?.value || 0\n      })\n\n      return dataPoint\n    })\n  }, [data])\n\n  // Handle data point click\n  const handleDataClick = (data: any, index: number, event?: React.MouseEvent) => {\n    if (!interactive || !onDataClick) return\n    \n    // Find the clicked series from the event target or use first non-x key\n    const clickedSeries = event?.currentTarget?.getAttribute('data-key') || \n                         Object.keys(data).find(key => key !== 'x') || ''\n    \n    const chartDataPoint: ChartDataPoint = {\n      x: data.x,\n      y: data.value || data[clickedSeries] || 0,\n      value: data.value || data[clickedSeries] || 0,\n      label: data.x?.toString(),\n      metadata: {\n        category: data.x,\n        series: clickedSeries,\n        index,\n        chartType: area ? 'area' : scatter ? 'scatter' : 'line',\n        allData: data, // Include all data for advanced filtering\n      },\n    }\n    onDataClick(chartDataPoint)\n  }\n\n  // Handle legend click\n  const handleLegendClick = (data: any, index: number) => {\n    if (!interactive || !onLegendClick) return\n    \n    const legendItem: LegendItem = {\n      label: data.value,\n      color: data.color,\n      visible: true,\n      metadata: {\n        series: data.value,\n        chartType: area ? 'area' : scatter ? 'scatter' : 'line',\n        index,\n      },\n    }\n    onLegendClick(legendItem)\n  }\n\n  // Custom tooltip\n  const CustomTooltip = ({ active, payload, label }: any) => {\n    if (!active || !payload || !payload.length) return null\n\n    return (\n      <div className=\"bg-background border border-border rounded-lg shadow-lg p-3\">\n        <p className=\"text-sm font-medium text-foreground mb-2\">{label}</p>\n        {payload.map((entry: any, index: number) => (\n          <div key={index} className=\"flex items-center gap-2 text-sm\">\n            <div \n              className=\"w-3 h-3 rounded-full\" \n              style={{ backgroundColor: entry.color }}\n            />\n            <span className=\"text-muted-foreground\">{entry.dataKey}:</span>\n            <span className=\"font-medium text-foreground\">\n              {config.tooltip?.format ? config.tooltip.format(entry.value) : entry.value}\n            </span>\n          </div>\n        ))}\n      </div>\n    )\n  }\n\n  const containerHeight = responsive ? height : height\n\n  if (scatter) {\n    return (\n      <ResponsiveContainer width=\"100%\" height={containerHeight}>\n        <ScatterChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>\n          {config.axes?.x?.show && (\n            <XAxis \n              dataKey=\"x\" \n              axisLine={false}\n              tickLine={false}\n              tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n            />\n          )}\n          {config.axes?.y?.show && (\n            <YAxis \n              axisLine={false}\n              tickLine={false}\n              tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n            />\n          )}\n          <CartesianGrid strokeDasharray=\"3 3\" stroke=\"hsl(var(--border))\" />\n          {config.tooltip?.show && <Tooltip content={<CustomTooltip />} />}\n          {config.legend?.show && (\n            <Legend \n              onClick={interactive ? handleLegendClick : undefined}\n              wrapperStyle={{ \n                paddingTop: '20px',\n                cursor: interactive ? 'pointer' : 'default'\n              }}\n            />\n          )}\n          {data.datasets.map((dataset, index) => (\n            <Scatter\n              key={dataset.label}\n              dataKey={dataset.label}\n              fill={colors[index]}\n              onClick={interactive ? (data, index, event) => handleDataClick(data, index, event) : undefined}\n              style={{ cursor: interactive ? 'pointer' : 'default' }}\n            />\n          ))}\n        </ScatterChart>\n      </ResponsiveContainer>\n    )\n  }\n\n  if (area) {\n    return (\n      <ResponsiveContainer width=\"100%\" height={containerHeight}>\n        <AreaChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>\n          {config.axes?.x?.show && (\n            <XAxis \n              dataKey=\"x\" \n              axisLine={false}\n              tickLine={false}\n              tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n            />\n          )}\n          {config.axes?.y?.show && (\n            <YAxis \n              axisLine={false}\n              tickLine={false}\n              tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n            />\n          )}\n          <CartesianGrid strokeDasharray=\"3 3\" stroke=\"hsl(var(--border))\" />\n          {config.tooltip?.show && <Tooltip content={<CustomTooltip />} />}\n          {config.legend?.show && (\n            <Legend \n              onClick={interactive ? handleLegendClick : undefined}\n              wrapperStyle={{ \n                paddingTop: '20px',\n                cursor: interactive ? 'pointer' : 'default'\n              }}\n            />\n          )}\n          {data.datasets.map((dataset, index) => (\n            <Area\n              key={dataset.label}\n              type=\"monotone\"\n              dataKey={dataset.label}\n              stroke={colors[index]}\n              fill={colors[index]}\n              fillOpacity={0.3}\n              strokeWidth={2}\n              onClick={interactive ? (data, index, event) => handleDataClick(data, index, event) : undefined}\n              style={{ cursor: interactive ? 'pointer' : 'default' }}\n              animationDuration={config.animations?.enabled ? config.animations.duration : 0}\n            />\n          ))}\n        </AreaChart>\n      </ResponsiveContainer>\n    )\n  }\n\n  return (\n    <ResponsiveContainer width=\"100%\" height={containerHeight}>\n      <RechartsLineChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>\n        {config.axes?.x?.show && (\n          <XAxis \n            dataKey=\"x\" \n            axisLine={false}\n            tickLine={false}\n            tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n          />\n        )}\n        {config.axes?.y?.show && (\n          <YAxis \n            axisLine={false}\n            tickLine={false}\n            tick={{ fontSize: 12, fill: 'hsl(var(--muted-foreground))' }}\n          />\n        )}\n        <CartesianGrid strokeDasharray=\"3 3\" stroke=\"hsl(var(--border))\" />\n        {config.tooltip?.show && <Tooltip content={<CustomTooltip />} />}\n        {config.legend?.show && (\n          <Legend \n            onClick={interactive ? handleLegendClick : undefined}\n            wrapperStyle={{ \n              paddingTop: '20px',\n              cursor: interactive ? 'pointer' : 'default'\n            }}\n          />\n        )}\n        {data.datasets.map((dataset, index) => (\n          <Line\n            key={dataset.label}\n            type=\"monotone\"\n            dataKey={dataset.label}\n            stroke={colors[index]}\n            strokeWidth={2}\n            dot={{ fill: colors[index], strokeWidth: 2, r: 4 }}\n            activeDot={{ r: 6, stroke: colors[index], strokeWidth: 2 }}\n            onClick={interactive ? (data, index, event) => handleDataClick(data, index, event) : undefined}\n            style={{ cursor: interactive ? 'pointer' : 'default' }}\n            animationDuration={config.animations?.enabled ? config.animations.duration : 0}\n          />\n        ))}\n      </RechartsLineChart>\n    </ResponsiveContainer>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-types/pie-chart.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 51,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 51,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1288, 1291], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1288, 1291], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'event' is defined but never used.",
        "line": 51,
        "column": 55,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 51,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 77,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 77,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2067, 2070], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2067, 2070], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 94,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 94,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2457, 2460], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2457, 2460], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 122,
        "column": 87,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 122,
        "endColumn": 90,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3588, 3591], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3588, 3591], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 146,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 146,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4240, 4243], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4240, 4243], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 151,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 151,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4400, 4403], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4400, 4403], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport {\n  PieChart as RechartsPieChart,\n  Pie,\n  Cell,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n} from 'recharts'\nimport type { ChartData, ChartConfiguration, ChartDataPoint, LegendItem } from '@/types/dashboard'\n\ninterface PieChartProps {\n  data: ChartData\n  config: ChartConfiguration\n  height: number\n  responsive: boolean\n  interactive: boolean\n  exportable: boolean\n  onDataClick?: (data: ChartDataPoint) => void\n  onLegendClick?: (legendItem: LegendItem) => void\n  colors: string[]\n}\n\nexport function PieChart({\n  data,\n  config,\n  height,\n  responsive,\n  interactive,\n  onDataClick,\n  onLegendClick,\n  colors,\n}: PieChartProps) {\n  // Transform data for Recharts pie chart format\n  const chartData = React.useMemo(() => {\n    if (!data.datasets || data.datasets.length === 0) return []\n\n    // For pie charts, we typically use the first dataset\n    const dataset = data.datasets[0]\n    if (!dataset) return []\n\n    return dataset.data.map((point, index) => ({\n      name: point.label || point.x?.toString() || `Item ${index + 1}`,\n      value: point.value || point.y || 0,\n      color: point.color || colors[index % colors.length],\n      originalData: point,\n    }))\n  }, [data, colors])\n\n  // Handle pie slice click\n  const handleSliceClick = (data: any, index: number, event?: React.MouseEvent) => {\n    if (!interactive || !onDataClick) return\n    \n    const totalValue = chartData.reduce((sum, item) => sum + item.value, 0)\n    const percentage = totalValue > 0 ? ((data.value / totalValue) * 100).toFixed(1) : '0'\n    \n    const chartDataPoint: ChartDataPoint = {\n      x: data.name,\n      y: data.value,\n      value: data.value,\n      label: data.name,\n      color: data.color,\n      metadata: {\n        ...data.originalData?.metadata,\n        category: data.name,\n        percentage,\n        index,\n        chartType: 'pie',\n        totalValue,\n        allData: data, // Include all data for advanced filtering\n      },\n    }\n    onDataClick(chartDataPoint)\n  }\n\n  // Handle legend click\n  const handleLegendClick = (data: any, index: number) => {\n    if (!interactive || !onLegendClick) return\n    \n    const legendItem: LegendItem = {\n      label: data.value,\n      color: data.color,\n      visible: true,\n      metadata: {\n        category: data.value,\n        chartType: 'pie',\n        index,\n      },\n    }\n    onLegendClick(legendItem)\n  }\n\n  // Custom tooltip\n  const CustomTooltip = ({ active, payload }: any) => {\n    if (!active || !payload || !payload.length) return null\n\n    const data = payload[0]\n    const percentage = ((data.value / chartData.reduce((sum, item) => sum + item.value, 0)) * 100).toFixed(1)\n\n    return (\n      <div className=\"bg-background border border-border rounded-lg shadow-lg p-3\">\n        <div className=\"flex items-center gap-2 text-sm\">\n          <div \n            className=\"w-3 h-3 rounded-full\" \n            style={{ backgroundColor: data.payload.color }}\n          />\n          <span className=\"font-medium text-foreground\">{data.name}</span>\n        </div>\n        <div className=\"mt-1 text-sm text-muted-foreground\">\n          Value: <span className=\"font-medium text-foreground\">\n            {config.tooltip?.format ? config.tooltip.format(data.value) : data.value}\n          </span>\n        </div>\n        <div className=\"text-sm text-muted-foreground\">\n          Percentage: <span className=\"font-medium text-foreground\">{percentage}%</span>\n        </div>\n      </div>\n    )\n  }\n\n  // Custom label renderer\n  const renderCustomLabel = ({ cx, cy, midAngle, innerRadius, outerRadius, percent }: any) => {\n    if (percent < 0.05) return null // Don't show labels for slices smaller than 5%\n\n    const RADIAN = Math.PI / 180\n    const radius = innerRadius + (outerRadius - innerRadius) * 0.5\n    const x = cx + radius * Math.cos(-midAngle * RADIAN)\n    const y = cy + radius * Math.sin(-midAngle * RADIAN)\n\n    return (\n      <text \n        x={x} \n        y={y} \n        fill=\"white\" \n        textAnchor={x > cx ? 'start' : 'end'} \n        dominantBaseline=\"central\"\n        fontSize={12}\n        fontWeight=\"medium\"\n      >\n        {`${(percent * 100).toFixed(0)}%`}\n      </text>\n    )\n  }\n\n  // Custom legend\n  const CustomLegend = ({ payload }: any) => {\n    if (!config.legend?.show) return null\n\n    return (\n      <div className=\"flex flex-wrap justify-center gap-4 mt-4\">\n        {payload.map((entry: any, index: number) => (\n          <div\n            key={index}\n            className={`flex items-center gap-2 text-sm ${\n              interactive ? 'cursor-pointer hover:opacity-80' : ''\n            }`}\n            onClick={() => handleLegendClick(entry, index)}\n          >\n            <div \n              className=\"w-3 h-3 rounded-full\" \n              style={{ backgroundColor: entry.color }}\n            />\n            <span className=\"text-foreground\">{entry.value}</span>\n          </div>\n        ))}\n      </div>\n    )\n  }\n\n  const containerHeight = responsive ? height : height\n\n  return (\n    <ResponsiveContainer width=\"100%\" height={containerHeight}>\n      <RechartsPieChart>\n        <Pie\n          data={chartData}\n          cx=\"50%\"\n          cy=\"50%\"\n          labelLine={false}\n          label={renderCustomLabel}\n          outerRadius={Math.min(containerHeight * 0.35, 120)}\n          fill=\"#8884d8\"\n          dataKey=\"value\"\n          onClick={interactive ? (data, index, event) => handleSliceClick(data, index, event) : undefined}\n          style={{ cursor: interactive ? 'pointer' : 'default' }}\n          animationDuration={config.animations?.enabled ? config.animations.duration : 0}\n        >\n          {chartData.map((entry, index) => (\n            <Cell \n              key={`cell-${index}`} \n              fill={entry.color}\n            />\n          ))}\n        </Pie>\n        {config.tooltip?.show && <Tooltip content={<CustomTooltip />} />}\n        {config.legend?.show && <Legend content={<CustomLegend />} />}\n      </RechartsPieChart>\n    </ResponsiveContainer>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-wrapper.stories.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 324,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 324,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6445, 6448], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6445, 6448], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Meta, StoryObj } from '@storybook/nextjs-vite'\nimport { ChartWrapper } from './chart-wrapper'\n\nconst meta: Meta<typeof ChartWrapper> = {\n  title: 'Dashboard/Charts/ChartWrapper',\n  component: ChartWrapper,\n  parameters: {\n    layout: 'padded',\n    docs: {\n      description: {\n        component: 'A universal chart container component that supports multiple chart types with lazy loading, export functionality, and interactive features.',\n      },\n    },\n  },\n  argTypes: {\n    type: {\n      control: 'select',\n      options: ['line', 'bar', 'pie', 'heatmap', 'area', 'scatter'],\n      description: 'Type of chart to render',\n    },\n    height: {\n      control: 'number',\n      description: 'Chart height in pixels',\n    },\n    responsive: {\n      control: 'boolean',\n      description: 'Enable responsive behavior',\n    },\n    interactive: {\n      control: 'boolean',\n      description: 'Enable interactive features',\n    },\n    exportable: {\n      control: 'boolean',\n      description: 'Enable export functionality',\n    },\n    loading: {\n      control: 'boolean',\n      description: 'Show loading state',\n    },\n    error: {\n      control: 'text',\n      description: 'Error message to display',\n    },\n  },\n}\n\nexport default meta\ntype Story = StoryObj<typeof ChartWrapper>\n\n// Sample data for different chart types\nconst lineChartData = {\n  datasets: [\n    {\n      label: 'Agent Performance',\n      data: [\n        { x: 'Jan', y: 65 },\n        { x: 'Feb', y: 78 },\n        { x: 'Mar', y: 82 },\n        { x: 'Apr', y: 75 },\n        { x: 'May', y: 89 },\n        { x: 'Jun', y: 94 },\n      ],\n      color: '#3F51B5',\n    },\n    {\n      label: 'System Load',\n      data: [\n        { x: 'Jan', y: 45 },\n        { x: 'Feb', y: 52 },\n        { x: 'Mar', y: 48 },\n        { x: 'Apr', y: 61 },\n        { x: 'May', y: 55 },\n        { x: 'Jun', y: 67 },\n      ],\n      color: '#B19ADA',\n    },\n  ],\n}\n\nconst barChartData = {\n  datasets: [\n    {\n      label: 'Task Completion',\n      data: [\n        { x: 'Mon', y: 24 },\n        { x: 'Tue', y: 32 },\n        { x: 'Wed', y: 28 },\n        { x: 'Thu', y: 35 },\n        { x: 'Fri', y: 42 },\n        { x: 'Sat', y: 18 },\n        { x: 'Sun', y: 15 },\n      ],\n      color: '#FF6B35',\n    },\n  ],\n}\n\nconst pieChartData = {\n  datasets: [\n    {\n      label: 'Platform Distribution',\n      data: [\n        { label: 'n8n', value: 45, color: '#3F51B5' },\n        { label: 'Make.com', value: 30, color: '#B19ADA' },\n        { label: 'Zapier', value: 20, color: '#FF6B35' },\n        { label: 'Other', value: 5, color: '#10B981' },\n      ],\n    },\n  ],\n}\n\nconst heatmapData = {\n  datasets: [\n    {\n      label: 'Activity Heatmap',\n      data: [\n        { x: 0, y: 0, value: 12 },\n        { x: 1, y: 0, value: 19 },\n        { x: 2, y: 0, value: 3 },\n        { x: 3, y: 0, value: 5 },\n        { x: 0, y: 1, value: 2 },\n        { x: 1, y: 1, value: 3 },\n        { x: 2, y: 1, value: 20 },\n        { x: 3, y: 1, value: 17 },\n        { x: 0, y: 2, value: 20 },\n        { x: 1, y: 2, value: 17 },\n        { x: 2, y: 2, value: 8 },\n        { x: 3, y: 2, value: 2 },\n      ],\n    },\n  ],\n}\n\nconst areaChartData = {\n  datasets: [\n    {\n      label: 'Memory Usage',\n      data: [\n        { x: '00:00', y: 45 },\n        { x: '04:00', y: 52 },\n        { x: '08:00', y: 68 },\n        { x: '12:00', y: 75 },\n        { x: '16:00', y: 82 },\n        { x: '20:00', y: 65 },\n        { x: '24:00', y: 48 },\n      ],\n      color: '#10B981',\n    },\n  ],\n}\n\nconst scatterData = {\n  datasets: [\n    {\n      label: 'Performance vs Load',\n      data: [\n        { x: 10, y: 85 },\n        { x: 25, y: 78 },\n        { x: 40, y: 72 },\n        { x: 55, y: 65 },\n        { x: 70, y: 58 },\n        { x: 85, y: 45 },\n        { x: 95, y: 32 },\n      ],\n      color: '#F59E0B',\n    },\n  ],\n}\n\nexport const LineChart: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const BarChart: Story = {\n  args: {\n    type: 'bar',\n    data: barChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const PieChart: Story = {\n  args: {\n    type: 'pie',\n    data: pieChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const HeatmapChart: Story = {\n  args: {\n    type: 'heatmap',\n    data: heatmapData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const AreaChart: Story = {\n  args: {\n    type: 'area',\n    data: areaChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const ScatterChart: Story = {\n  args: {\n    type: 'scatter',\n    data: scatterData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const SmallChart: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 200,\n    responsive: true,\n    interactive: false,\n    exportable: false,\n  },\n}\n\nexport const LargeChart: Story = {\n  args: {\n    type: 'bar',\n    data: barChartData,\n    height: 500,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n    config: {\n      legend: {\n        show: true,\n        position: 'bottom',\n        align: 'center',\n      },\n      tooltip: {\n        show: true,\n      },\n      animations: {\n        enabled: true,\n        duration: 750,\n        easing: 'ease-in-out',\n      },\n    },\n  },\n}\n\nexport const CustomColors: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n    config: {\n      colors: {\n        primary: '#8B5CF6',\n        secondary: '#06B6D4',\n        accent: '#F59E0B',\n        success: '#10B981',\n        warning: '#F59E0B',\n        error: '#EF4444',\n      },\n    },\n  },\n}\n\nexport const WithLegend: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 350,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n    config: {\n      legend: {\n        show: true,\n        position: 'top',\n        align: 'end',\n      },\n    },\n  },\n}\n\nexport const WithCustomTooltip: Story = {\n  args: {\n    type: 'bar',\n    data: barChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n    config: {\n      tooltip: {\n        show: true,\n        format: (value: any) => `${value} tasks completed`,\n      },\n    },\n  },\n}\n\nexport const WithAnimations: Story = {\n  args: {\n    type: 'pie',\n    data: pieChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n    config: {\n      animations: {\n        enabled: true,\n        duration: 1000,\n        easing: 'ease-in-out',\n      },\n    },\n  },\n}\n\nexport const LoadingState: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 300,\n    loading: true,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const ErrorState: Story = {\n  args: {\n    type: 'bar',\n    data: barChartData,\n    height: 300,\n    error: 'Failed to load chart data. Please try again.',\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const NonResponsive: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 300,\n    responsive: false,\n    interactive: true,\n    exportable: true,\n  },\n}\n\nexport const NonInteractive: Story = {\n  args: {\n    type: 'bar',\n    data: barChartData,\n    height: 300,\n    responsive: true,\n    interactive: false,\n    exportable: true,\n  },\n}\n\nexport const NonExportable: Story = {\n  args: {\n    type: 'pie',\n    data: pieChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: false,\n  },\n}\n\nexport const InteractiveWithCallbacks: Story = {\n  args: {\n    type: 'bar',\n    data: barChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n    onDataClick: (data) => {\n      console.log('Data clicked:', data)\n      alert(`Clicked: ${data.x} - ${data.y}`)\n    },\n    onLegendClick: (legendItem) => {\n      console.log('Legend clicked:', legendItem)\n      alert(`Legend clicked: ${legendItem.label}`)\n    },\n  },\n}\n\nexport const ResponsiveMobile: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 250,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n  parameters: {\n    viewport: {\n      defaultViewport: 'mobile',\n    },\n  },\n}\n\nexport const ResponsiveTablet: Story = {\n  args: {\n    type: 'bar',\n    data: barChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n  parameters: {\n    viewport: {\n      defaultViewport: 'tablet',\n    },\n  },\n}\n\nexport const DarkTheme: Story = {\n  args: {\n    type: 'line',\n    data: lineChartData,\n    height: 300,\n    responsive: true,\n    interactive: true,\n    exportable: true,\n  },\n  parameters: {\n    backgrounds: {\n      default: 'dark',\n    },\n  },\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/charts/chart-wrapper.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'lazy' is defined but never used.",
        "line": 1,
        "column": 27,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'TooltipProps' is defined but never used.",
        "line": 15,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'AxisConfiguration' is defined but never used.",
        "line": 16,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 85,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 85,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2483, 2486], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2483, 2486], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 87,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 87,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2591, 2594], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2591, 2594], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'index' is defined but never used.",
        "line": 211,
        "column": 66,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 211,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'event' is defined but never used.",
        "line": 224,
        "column": 39,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 224,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'event' is defined but never used.",
        "line": 231,
        "column": 60,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 231,
        "endColumn": 65
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { Suspense, lazy, useMemo, useRef, useCallback, useEffect, useState } from 'react'\nimport { cn } from '@/lib/utils'\nimport { ChartExportControls } from './chart-export-controls'\nimport { KeyboardNavigation } from '../accessibility/keyboard-navigation'\nimport { useAriaLabels, AriaDescription } from '../accessibility/aria-labels'\nimport { useScreenReaderAnnouncer, DataAnnouncer, ChartAnnouncer } from '../accessibility/screen-reader-announcer'\nimport { TouchInteraction, useIsTouchDevice, useIsMobile } from '../mobile/touch-interactions'\nimport { ChartMobileTooltip } from '../mobile/mobile-tooltip'\nimport type {\n  ChartType,\n  ChartData,\n  ChartConfiguration,\n  ChartDataPoint,\n  LegendItem,\n  TooltipProps,\n  AxisConfiguration,\n} from '@/types/dashboard'\n\ninterface ChartWrapperProps {\n  type: ChartType\n  data: ChartData\n  config?: ChartConfiguration\n  loading?: boolean\n  error?: string\n  height?: number\n  responsive?: boolean\n  interactive?: boolean\n  exportable?: boolean\n  exportFilename?: string\n  onDataClick?: (data: ChartDataPoint) => void\n  onLegendClick?: (legendItem: LegendItem) => void\n  onExportStart?: (format: string) => void\n  onExportComplete?: (format: string) => void\n  onExportError?: (error: Error, format: string) => void\n  className?: string\n}\n\n// Import dynamic chart components\nimport { ChartBundle, trackDynamicImportPerformance } from '../performance/dynamic-imports'\n\nconst { LineChart: LazyLineChart, BarChart: LazyBarChart, PieChart: LazyPieChart, HeatmapChart: LazyHeatmapChart } = ChartBundle\n\n// Default color palette following Cubcen brand colors\nconst DEFAULT_COLORS = {\n  primary: '#3F51B5',\n  secondary: '#B19ADA',\n  accent: '#FF6B35',\n  success: '#10B981',\n  warning: '#F59E0B',\n  error: '#EF4444',\n}\n\n// Default chart color palette\nconst DEFAULT_CHART_PALETTE = [\n  '#3F51B5', // Primary\n  '#B19ADA', // Secondary\n  '#FF6B35', // Accent\n  '#10B981', // Success\n  '#F59E0B', // Warning\n  '#EF4444', // Error\n  '#3B82F6', // Info\n  '#8B5CF6', // Purple\n]\n\nexport function ChartWrapper({\n  type,\n  data,\n  config,\n  loading = false,\n  error,\n  height = 300,\n  responsive = true,\n  interactive = true,\n  exportable = false,\n  exportFilename = 'chart',\n  onDataClick,\n  onLegendClick,\n  onExportStart,\n  onExportComplete,\n  onExportError,\n  className,\n}: ChartWrapperProps) {\n  const chartRef = useRef<HTMLDivElement>(null)\n  const focusedElementRef = useRef<number>(0)\n  const [selectedElement, setSelectedElement] = useState<any>(null)\n  const [zoomLevel, setZoomLevel] = useState(1)\n  const [tooltipData, setTooltipData] = useState<any>(null)\n  \n  const ariaLabels = useAriaLabels()\n  const { announceChartInteraction } = useScreenReaderAnnouncer()\n  const isTouchDevice = useIsTouchDevice()\n  const isMobile = useIsMobile()\n  \n  // Generate unique IDs for ARIA relationships\n  const chartId = React.useId()\n  const titleId = `${chartId}-title`\n  const descriptionId = `${chartId}-description`\n  const instructionsId = `${chartId}-instructions`\n\n  // Track chart load completion\n  useEffect(() => {\n    const performanceTracker = trackDynamicImportPerformance(`${type}-chart`)\n    performanceTracker.end()\n  }, [type])\n  // Memoize the merged configuration with sensible defaults\n  const mergedConfig = useMemo((): ChartConfiguration => ({\n    colors: {\n      ...DEFAULT_COLORS,\n      ...config?.colors,\n    },\n    legend: {\n      show: true,\n      position: 'bottom',\n      align: 'center',\n      ...config?.legend,\n    },\n    tooltip: {\n      show: true,\n      ...config?.tooltip,\n    },\n    axes: {\n      x: {\n        show: true,\n        ...config?.axes?.x,\n      },\n      y: {\n        show: true,\n        ...config?.axes?.y,\n      },\n    },\n    animations: {\n      enabled: true,\n      duration: 300,\n      easing: 'ease-out',\n      ...config?.animations,\n    },\n    responsive: config?.responsive,\n  }), [config])\n\n  // Memoize chart colors based on data\n  const chartColors = useMemo(() => {\n    if (!data?.datasets) return DEFAULT_CHART_PALETTE\n\n    return data.datasets.map((dataset, index) => \n      dataset.color || DEFAULT_CHART_PALETTE[index % DEFAULT_CHART_PALETTE.length]\n    )\n  }, [data])\n\n  // Handle keyboard navigation for chart elements\n  const handleChartKeyDown = useCallback((event: React.KeyboardEvent) => {\n    if (!interactive) return\n\n    const { key } = event\n    const chartElements = chartRef.current?.querySelectorAll('[data-chart-element]')\n    \n    if (!chartElements || chartElements.length === 0) return\n\n    switch (key) {\n      case 'ArrowRight':\n      case 'ArrowDown':\n        event.preventDefault()\n        focusedElementRef.current = (focusedElementRef.current + 1) % chartElements.length\n        ;(chartElements[focusedElementRef.current] as HTMLElement).focus()\n        break\n      case 'ArrowLeft':\n      case 'ArrowUp':\n        event.preventDefault()\n        focusedElementRef.current = focusedElementRef.current === 0 \n          ? chartElements.length - 1 \n          : focusedElementRef.current - 1\n        ;(chartElements[focusedElementRef.current] as HTMLElement).focus()\n        break\n      case 'Enter':\n      case ' ':\n        event.preventDefault()\n        const activeElement = chartElements[focusedElementRef.current] as HTMLElement\n        if (activeElement) {\n          activeElement.click()\n        }\n        break\n      case 'Home':\n        event.preventDefault()\n        focusedElementRef.current = 0\n        ;(chartElements[0] as HTMLElement).focus()\n        break\n      case 'End':\n        event.preventDefault()\n        focusedElementRef.current = chartElements.length - 1\n        ;(chartElements[chartElements.length - 1] as HTMLElement).focus()\n        break\n    }\n  }, [interactive])\n\n  // Handle chart element click with keyboard support\n  const handleChartElementClick = useCallback((dataPoint: ChartDataPoint, index: number) => {\n    focusedElementRef.current = index\n    setSelectedElement(dataPoint)\n    \n    // Announce interaction to screen readers\n    announceChartInteraction(\n      'Selected',\n      'data point',\n      dataPoint.value || dataPoint.y,\n      `${type} chart`\n    )\n    \n    onDataClick?.(dataPoint)\n  }, [onDataClick, type, announceChartInteraction])\n\n  // Handle legend click with keyboard support\n  const handleLegendClick = useCallback((legendItem: LegendItem, index: number) => {\n    // Announce legend interaction\n    announceChartInteraction(\n      'Toggled',\n      'legend item',\n      legendItem.label,\n      `${type} chart`\n    )\n    \n    onLegendClick?.(legendItem)\n  }, [onLegendClick, type, announceChartInteraction])\n\n  // Handle touch interactions for charts\n  const handleChartTap = useCallback((event: TouchEvent) => {\n    // For touch devices, show tooltip data on tap\n    if (selectedElement) {\n      setTooltipData(selectedElement)\n    }\n  }, [selectedElement])\n\n  const handleChartPinchZoom = useCallback((scale: number, event: TouchEvent) => {\n    // Handle pinch-to-zoom for charts\n    const newZoomLevel = Math.max(0.5, Math.min(3, zoomLevel * scale))\n    setZoomLevel(newZoomLevel)\n    \n    // Announce zoom level change\n    announceChartInteraction(\n      'Zoomed',\n      'chart',\n      `${Math.round(newZoomLevel * 100)}%`,\n      `${type} chart`\n    )\n  }, [zoomLevel, type, announceChartInteraction])\n\n  const handleChartSwipe = useCallback((direction: 'left' | 'right' | 'up' | 'down') => {\n    // Handle swipe gestures for chart navigation\n    announceChartInteraction(\n      'Swiped',\n      'chart',\n      direction,\n      `${type} chart`\n    )\n  }, [type, announceChartInteraction])\n\n  // Generate chart title for accessibility\n  const getChartTitle = () => {\n    const datasetLabel = data?.datasets?.[0]?.label\n    return datasetLabel || `${type} chart`\n  }\n\n  // Generate chart description for accessibility\n  const getChartDescription = () => {\n    const datasetCount = data?.datasets?.length || 0\n    const dataPointCount = data?.datasets?.[0]?.data?.length || 0\n    \n    let description = `${type} chart`\n    if (datasetCount > 0) {\n      description += ` with ${datasetCount} dataset${datasetCount !== 1 ? 's' : ''}`\n    }\n    if (dataPointCount > 0) {\n      description += ` and ${dataPointCount} data point${dataPointCount !== 1 ? 's' : ''}`\n    }\n    \n    return description\n  }\n\n  // Loading state\n  if (loading) {\n    return (\n      <div\n        className={cn('chart-wrapper chart-loading', className)}\n        style={{ height: `${height}px` }}\n        role=\"status\"\n        aria-label={ariaLabels.chart.loading(type)}\n        aria-describedby={descriptionId}\n      >\n        <AriaDescription id={descriptionId}>\n          {`${type} chart is currently loading data`}\n        </AriaDescription>\n        <div className=\"flex items-center justify-center h-full\">\n          <div className=\"animate-pulse text-muted-foreground\">Loading chart...</div>\n        </div>\n      </div>\n    )\n  }\n\n  // Error state\n  if (error) {\n    return (\n      <div\n        className={cn('chart-wrapper chart-error', className)}\n        style={{ height: `${height}px` }}\n        role=\"alert\"\n        aria-label={ariaLabels.chart.error(type, error)}\n        aria-describedby={descriptionId}\n      >\n        <AriaDescription id={descriptionId}>\n          {`${type} chart failed to load: ${error}`}\n        </AriaDescription>\n        <div className=\"flex items-center justify-center h-full\">\n          <div className=\"text-destructive text-sm\">{error}</div>\n        </div>\n      </div>\n    )\n  }\n\n  // No data state\n  if (!data?.datasets || data.datasets.length === 0) {\n    return (\n      <div\n        className={cn('chart-wrapper chart-empty', className)}\n        style={{ height: `${height}px` }}\n        role=\"img\"\n        aria-label={ariaLabels.chart.noData(type)}\n        aria-describedby={descriptionId}\n      >\n        <AriaDescription id={descriptionId}>\n          {`${type} chart has no data to display`}\n        </AriaDescription>\n        <div className=\"flex items-center justify-center h-full\">\n          <div className=\"text-muted-foreground text-sm\">No data available</div>\n        </div>\n      </div>\n    )\n  }\n\n  // Render appropriate chart component with performance tracking\n  const renderChart = () => {\n    const commonProps = {\n      data,\n      config: mergedConfig,\n      height,\n      responsive,\n      interactive,\n      exportable,\n      onDataClick: handleChartElementClick,\n      onLegendClick: handleLegendClick,\n      colors: chartColors,\n      // Mobile-specific props\n      isTouchDevice,\n      isMobile,\n      zoomLevel: isTouchDevice ? zoomLevel : 1,\n    }\n\n\n\n    switch (type) {\n      case 'line':\n        return <LazyLineChart {...commonProps} />\n      case 'bar':\n        return <LazyBarChart {...commonProps} />\n      case 'pie':\n        return <LazyPieChart {...commonProps} />\n      case 'heatmap':\n        return <LazyHeatmapChart {...commonProps} />\n      case 'area':\n        return <LazyLineChart {...commonProps} area />\n      case 'scatter':\n        return <LazyLineChart {...commonProps} scatter />\n      default:\n        return (\n          <div className=\"text-center text-muted-foreground p-8\">\n            Unsupported chart type: {type}\n          </div>\n        )\n    }\n  }\n\n  const chartContainer = (\n    <div\n      data-chart-container\n      onKeyDown={handleChartKeyDown}\n      tabIndex={interactive ? 0 : -1}\n      role={interactive ? 'application' : 'img'}\n      aria-label={ariaLabels.chart.container(type, getChartTitle())}\n      aria-labelledby={titleId}\n      aria-describedby={`${descriptionId} ${interactive ? instructionsId : ''}`}\n      style={{\n        transform: isTouchDevice ? `scale(${zoomLevel})` : undefined,\n        transformOrigin: 'center center',\n        transition: 'transform 0.2s ease-out',\n      }}\n    >\n      {/* Chart title for screen readers */}\n      <AriaDescription id={titleId}>\n        {getChartTitle()}\n      </AriaDescription>\n      \n      {/* Chart description for screen readers */}\n      <AriaDescription id={descriptionId}>\n        {getChartDescription()}\n      </AriaDescription>\n\n      {/* Screen reader instructions for interactive charts */}\n      {interactive && (\n        <AriaDescription id={instructionsId}>\n          {isTouchDevice \n            ? 'Interactive chart. Tap to select elements, pinch to zoom, swipe to navigate.'\n            : 'Interactive chart. Use arrow keys to navigate chart elements, Enter or Space to select, Home and End to go to first and last elements.'\n          }\n        </AriaDescription>\n      )}\n\n      {/* Export Controls */}\n      {exportable && (\n        <div className=\"absolute top-2 right-2 z-10\">\n          <ChartExportControls\n            chartRef={chartRef}\n            filename={exportFilename}\n            onExportStart={onExportStart}\n            onExportComplete={onExportComplete}\n            onExportError={onExportError}\n          />\n        </div>\n      )}\n\n      <Suspense\n        fallback={\n          <div \n            className=\"flex items-center justify-center h-full\"\n            style={{ height: `${height}px` }}\n            role=\"status\"\n            aria-label=\"Loading chart\"\n          >\n            <div className=\"animate-pulse text-muted-foreground\">Loading chart...</div>\n          </div>\n        }\n      >\n        <div \n          ref={chartRef}\n          className=\"chart-container w-full h-full\"\n        >\n          {renderChart()}\n        </div>\n      </Suspense>\n    </div>\n  )\n\n  return (\n    <DataAnnouncer\n      data={data}\n      dataType={`${type} chart`}\n      loading={loading}\n      error={error}\n    >\n      <ChartAnnouncer\n        chartType={type}\n        data={data}\n        selectedElement={selectedElement}\n      >\n        <KeyboardNavigation\n          className={cn(\n            'chart-wrapper relative',\n            // Mobile-specific styles\n            isMobile && 'overflow-hidden',\n            className\n          )}\n          style={{ height: responsive ? 'auto' : `${height}px` }}\n        >\n          {/* Wrap with touch interactions for touch devices */}\n          {isTouchDevice && interactive ? (\n            <TouchInteraction\n              onTap={handleChartTap}\n              onPinchZoom={handleChartPinchZoom}\n              onSwipeLeft={() => handleChartSwipe('left')}\n              onSwipeRight={() => handleChartSwipe('right')}\n              onSwipeUp={() => handleChartSwipe('up')}\n              onSwipeDown={() => handleChartSwipe('down')}\n              className=\"chart-touch-wrapper w-full h-full\"\n            >\n              {tooltipData ? (\n                <ChartMobileTooltip\n                  data={tooltipData}\n                  side=\"top\"\n                  tapToShow={true}\n                  tapToHide={true}\n                >\n                  {chartContainer}\n                </ChartMobileTooltip>\n              ) : (\n                chartContainer\n              )}\n            </TouchInteraction>\n          ) : (\n            chartContainer\n          )}\n        </KeyboardNavigation>\n      </ChartAnnouncer>\n    </DataAnnouncer>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/dashboard-overview.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/documentation.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/examples/click-to-filter-example.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'MetricCard' is defined but never used.",
        "line": 8,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'activeFilters' is assigned a value but never used.",
        "line": 66,
        "column": 25,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 66,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useState } from 'react'\nimport { FilterProvider } from '../filters/filter-context'\nimport { FilterSynchronizer, ActiveFiltersDisplay, useCrossCardFiltering } from '../filters/filter-synchronizer'\nimport { DashboardGrid } from '../grid/dashboard-grid'\nimport { ChartCard } from '../cards/chart-card'\nimport { MetricCard } from '../cards/metric-card'\nimport { FilterableCard } from '../filters/filterable-card'\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'\nimport { Button } from '@/components/ui/button'\nimport { BarChart3, TrendingUp, Users, Activity } from 'lucide-react'\nimport type { ChartData, ChartDataPoint, LegendItem, FilterValue } from '@/types/dashboard'\n\n// Sample data for demonstration\nconst sampleChartData: ChartData = {\n  datasets: [\n    {\n      label: 'Sales',\n      data: [\n        { x: 'Jan', y: 4000, label: 'January', metadata: { category: 'Q1', region: 'North' } },\n        { x: 'Feb', y: 3000, label: 'February', metadata: { category: 'Q1', region: 'North' } },\n        { x: 'Mar', y: 5000, label: 'March', metadata: { category: 'Q1', region: 'South' } },\n        { x: 'Apr', y: 4500, label: 'April', metadata: { category: 'Q2', region: 'South' } },\n        { x: 'May', y: 6000, label: 'May', metadata: { category: 'Q2', region: 'East' } },\n        { x: 'Jun', y: 5500, label: 'June', metadata: { category: 'Q2', region: 'East' } },\n      ],\n    },\n    {\n      label: 'Revenue',\n      data: [\n        { x: 'Jan', y: 2400, label: 'January', metadata: { category: 'Q1', region: 'North' } },\n        { x: 'Feb', y: 1398, label: 'February', metadata: { category: 'Q1', region: 'North' } },\n        { x: 'Mar', y: 9800, label: 'March', metadata: { category: 'Q1', region: 'South' } },\n        { x: 'Apr', y: 3908, label: 'April', metadata: { category: 'Q2', region: 'South' } },\n        { x: 'May', y: 4800, label: 'May', metadata: { category: 'Q2', region: 'East' } },\n        { x: 'Jun', y: 3800, label: 'June', metadata: { category: 'Q2', region: 'East' } },\n      ],\n    },\n  ],\n}\n\nconst pieChartData: ChartData = {\n  datasets: [\n    {\n      label: 'Regions',\n      data: [\n        { label: 'North', value: 35, metadata: { region: 'North', category: 'Q1' } },\n        { label: 'South', value: 25, metadata: { region: 'South', category: 'Q1' } },\n        { label: 'East', value: 30, metadata: { region: 'East', category: 'Q2' } },\n        { label: 'West', value: 10, metadata: { region: 'West', category: 'Q2' } },\n      ],\n    },\n  ],\n}\n\n// Sample table data\nconst tableData = [\n  { id: 1, name: 'Product A', category: 'Q1', region: 'North', sales: 4000, revenue: 2400 },\n  { id: 2, name: 'Product B', category: 'Q1', region: 'South', sales: 3000, revenue: 1398 },\n  { id: 3, name: 'Product C', category: 'Q2', region: 'East', sales: 5000, revenue: 9800 },\n  { id: 4, name: 'Product D', category: 'Q2', region: 'West', sales: 4500, revenue: 3908 },\n]\n\nfunction FilteredDataTable() {\n  const { filteredData, activeFilters, filterCount } = useCrossCardFiltering(tableData, {\n    searchFields: ['name', 'category', 'region'],\n    filterMappings: {\n      category: (item, filterValue) => item.category === filterValue.value,\n      region: (item, filterValue) => item.region === filterValue.value,\n      month: (item, filterValue) => {\n        // Map month names to categories for demo\n        const monthToCategory: Record<string, string> = {\n          'January': 'Q1', 'February': 'Q1', 'March': 'Q1',\n          'April': 'Q2', 'May': 'Q2', 'June': 'Q2',\n        }\n        return item.category === monthToCategory[filterValue.value as string]\n      },\n    },\n  })\n\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\">\n          <Activity className=\"h-5 w-5\" />\n          Filtered Data Table\n          {filterCount > 0 && (\n            <span className=\"text-sm bg-primary/10 text-primary px-2 py-1 rounded-full\">\n              {filterCount} filter{filterCount !== 1 ? 's' : ''} active\n            </span>\n          )}\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"overflow-x-auto\">\n          <table className=\"w-full text-sm\">\n            <thead>\n              <tr className=\"border-b\">\n                <th className=\"text-left p-2\">Name</th>\n                <th className=\"text-left p-2\">Category</th>\n                <th className=\"text-left p-2\">Region</th>\n                <th className=\"text-right p-2\">Sales</th>\n                <th className=\"text-right p-2\">Revenue</th>\n              </tr>\n            </thead>\n            <tbody>\n              {filteredData.map((item) => (\n                <tr key={item.id} className=\"border-b hover:bg-muted/50\">\n                  <td className=\"p-2 font-medium\">{item.name}</td>\n                  <td className=\"p-2\">{item.category}</td>\n                  <td className=\"p-2\">{item.region}</td>\n                  <td className=\"p-2 text-right\">{item.sales.toLocaleString()}</td>\n                  <td className=\"p-2 text-right\">${item.revenue.toLocaleString()}</td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n          {filteredData.length === 0 && (\n            <div className=\"text-center py-8 text-muted-foreground\">\n              No data matches the current filters\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\nexport function ClickToFilterExample() {\n  const [debugMode, setDebugMode] = useState(false)\n\n  // Custom filter mappings for charts\n  const barChartFilterMappings = {\n    dataClick: (dataPoint: ChartDataPoint) => {\n      const filters: Record<string, FilterValue> = {}\n      \n      // Filter by month\n      if (dataPoint.label) {\n        filters.month = {\n          type: 'string',\n          value: dataPoint.label,\n          operator: 'equals',\n        }\n      }\n      \n      // Filter by category from metadata\n      if (dataPoint.metadata?.category) {\n        filters.category = {\n          type: 'string',\n          value: dataPoint.metadata.category,\n          operator: 'equals',\n        }\n      }\n      \n      return filters\n    },\n    legendClick: (legendItem: LegendItem) => ({\n      series: {\n        type: 'string',\n        value: legendItem.label,\n        operator: 'equals',\n      },\n    }),\n  }\n\n  const pieChartFilterMappings = {\n    dataClick: (dataPoint: ChartDataPoint) => ({\n      region: {\n        type: 'string',\n        value: dataPoint.label || '',\n        operator: 'equals',\n      },\n    }),\n  }\n\n  return (\n    <FilterProvider>\n      <div className=\"space-y-6\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <h2 className=\"text-2xl font-bold\">Click-to-Filter Dashboard</h2>\n            <p className=\"text-muted-foreground\">\n              Click on chart elements to filter data across all dashboard components\n            </p>\n          </div>\n          <Button\n            variant=\"outline\"\n            onClick={() => setDebugMode(!debugMode)}\n          >\n            {debugMode ? 'Hide' : 'Show'} Debug Info\n          </Button>\n        </div>\n\n        {/* Active Filters Display */}\n        <ActiveFiltersDisplay className=\"mb-4\" />\n\n        {/* Filter Synchronizer */}\n        <FilterSynchronizer\n          syncConfig={{\n            syncAll: true,\n            debounceMs: 100,\n            onSync: (filters) => {\n              if (debugMode) {\n                console.log('Filters synchronized:', filters)\n              }\n            },\n          }}\n        >\n          {/* Dashboard Grid */}\n          <DashboardGrid columns={12} gap={6}>\n            {/* KPI Cards */}\n            <div className=\"col-span-12 md:col-span-3\">\n              <FilterableCard\n                title=\"Total Sales\"\n                metric={{\n                  value: '24,500',\n                  unit: 'units',\n                  trend: 'up',\n                  trendValue: '+12%',\n                }}\n                icon={TrendingUp}\n                size=\"sm\"\n                priority=\"high\"\n                enableFiltering={true}\n                filterData={{ category: 'sales' }}\n              />\n            </div>\n            \n            <div className=\"col-span-12 md:col-span-3\">\n              <FilterableCard\n                title=\"Revenue\"\n                metric={{\n                  value: '$45,200',\n                  trend: 'up',\n                  trendValue: '+8%',\n                }}\n                icon={BarChart3}\n                size=\"sm\"\n                priority=\"high\"\n                enableFiltering={true}\n                filterData={{ category: 'revenue' }}\n              />\n            </div>\n            \n            <div className=\"col-span-12 md:col-span-3\">\n              <FilterableCard\n                title=\"Active Users\"\n                metric={{\n                  value: '1,234',\n                  trend: 'neutral',\n                }}\n                icon={Users}\n                size=\"sm\"\n                priority=\"medium\"\n                enableFiltering={true}\n                filterData={{ category: 'users' }}\n              />\n            </div>\n            \n            <div className=\"col-span-12 md:col-span-3\">\n              <FilterableCard\n                title=\"Conversion Rate\"\n                metric={{\n                  value: '3.2%',\n                  trend: 'down',\n                  trendValue: '-0.5%',\n                }}\n                icon={Activity}\n                size=\"sm\"\n                priority=\"critical\"\n                enableFiltering={true}\n                filterData={{ category: 'conversion' }}\n              />\n            </div>\n\n            {/* Charts */}\n            <div className=\"col-span-12 lg:col-span-8\">\n              <ChartCard\n                title=\"Sales & Revenue Trends\"\n                subtitle=\"Monthly performance data\"\n                chartType=\"bar\"\n                data={sampleChartData}\n                exportable={true}\n                filterable={true}\n                enableCrossCardFiltering={true}\n                filterMappings={barChartFilterMappings}\n                exportFilename=\"sales-revenue-trends\"\n                chartConfig={{\n                  legend: { show: true, position: 'bottom' },\n                  tooltip: { show: true },\n                  animations: { enabled: true, duration: 300 },\n                }}\n              />\n            </div>\n\n            <div className=\"col-span-12 lg:col-span-4\">\n              <ChartCard\n                title=\"Regional Distribution\"\n                subtitle=\"Sales by region\"\n                chartType=\"pie\"\n                data={pieChartData}\n                exportable={true}\n                filterable={true}\n                enableCrossCardFiltering={true}\n                filterMappings={pieChartFilterMappings}\n                exportFilename=\"regional-distribution\"\n                chartConfig={{\n                  legend: { show: true, position: 'bottom' },\n                  tooltip: { show: true },\n                  animations: { enabled: true, duration: 300 },\n                }}\n              />\n            </div>\n\n            {/* Filtered Data Table */}\n            <div className=\"col-span-12\">\n              <FilteredDataTable />\n            </div>\n          </DashboardGrid>\n        </FilterSynchronizer>\n\n        {/* Instructions */}\n        <Card>\n          <CardHeader>\n            <CardTitle>How to Use Click-to-Filter</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            <div>\n              <h4 className=\"font-semibold mb-2\">Chart Interactions:</h4>\n              <ul className=\"list-disc list-inside space-y-1 text-sm text-muted-foreground\">\n                <li>Click on bar chart bars to filter by month and category</li>\n                <li>Click on pie chart slices to filter by region</li>\n                <li>Click on chart legends to filter by data series</li>\n                <li>Filters are applied across all dashboard components</li>\n              </ul>\n            </div>\n            \n            <div>\n              <h4 className=\"font-semibold mb-2\">Card Interactions:</h4>\n              <ul className=\"list-disc list-inside space-y-1 text-sm text-muted-foreground\">\n                <li>Click on KPI cards to filter by category</li>\n                <li>Multiple filters can be active simultaneously</li>\n                <li>Click the &times; button on filter chips to remove individual filters</li>\n                <li>Use &quot;Clear all&quot; to remove all active filters</li>\n              </ul>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Debug Info */}\n        {debugMode && (\n          <Card>\n            <CardHeader>\n              <CardTitle>Debug Information</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <p className=\"text-sm text-muted-foreground mb-2\">\n                Open browser console to see filter synchronization logs\n              </p>\n            </CardContent>\n          </Card>\n        )}\n      </div>\n    </FilterProvider>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/examples/dashboard-example.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/examples/dashboard-layout-example.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/examples/theming-example.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/__tests__/dashboard-filters.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 21,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 21,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [651, 654], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [651, 654], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { DashboardFilters } from '../dashboard-filters'\nimport { FilterProvider } from '../filter-context'\n\n// Mock Next.js navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(() => ({ replace: jest.fn() })),\n  useSearchParams: jest.fn(() => ({ get: jest.fn(), toString: jest.fn(() => '') })),\n}))\n\n// Mock clipboard API\nObject.assign(navigator, {\n  clipboard: {\n    writeText: jest.fn(),\n  },\n})\n\n// Test wrapper with FilterProvider\nfunction TestWrapper({ children, ...props }: any) {\n  return (\n    <FilterProvider {...props}>\n      {children}\n    </FilterProvider>\n  )\n}\n\ndescribe('DashboardFilters', () => {\n  const user = userEvent.setup()\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('renders in compact mode', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters compact />\n      </TestWrapper>\n    )\n\n    expect(screen.getByRole('button', { name: /filters/i })).toBeInTheDocument()\n    expect(screen.getByText('Filters')).toBeInTheDocument()\n  })\n\n  it('renders in full mode', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    expect(screen.getByText('Filters')).toBeInTheDocument()\n    expect(screen.getByText('Quick Filters')).toBeInTheDocument()\n    expect(screen.getByText('Date Range')).toBeInTheDocument()\n    expect(screen.getByText('Status')).toBeInTheDocument()\n    expect(screen.getByText('Priority')).toBeInTheDocument()\n    expect(screen.getByText('Platforms')).toBeInTheDocument()\n  })\n\n  it('shows default presets', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    expect(screen.getByText('Last 7 Days')).toBeInTheDocument()\n    expect(screen.getByText('Last 30 Days')).toBeInTheDocument()\n    expect(screen.getByText('High Priority')).toBeInTheDocument()\n    expect(screen.getByText('Active Agents')).toBeInTheDocument()\n  })\n\n  it('applies preset when clicked', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('High Priority'))\n\n    // Should show active filters\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n      expect(screen.getByText('high')).toBeInTheDocument()\n      expect(screen.getByText('critical')).toBeInTheDocument()\n    })\n  })\n\n  it('handles status filter selection', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    // Click on active status checkbox\n    const activeCheckbox = screen.getByLabelText('active')\n    await user.click(activeCheckbox)\n\n    expect(activeCheckbox).toBeChecked()\n\n    // Should show in active filters\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n      expect(screen.getByText('active')).toBeInTheDocument()\n    })\n  })\n\n  it('handles priority filter selection', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    // Click on high priority checkbox\n    const highCheckbox = screen.getByLabelText('high')\n    await user.click(highCheckbox)\n\n    expect(highCheckbox).toBeChecked()\n\n    // Should show in active filters\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n      expect(screen.getByText('high')).toBeInTheDocument()\n    })\n  })\n\n  it('handles platform filter selection', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    // Click on n8n platform checkbox\n    const n8nCheckbox = screen.getByLabelText('n8n')\n    await user.click(n8nCheckbox)\n\n    expect(n8nCheckbox).toBeChecked()\n\n    // Should show in active filters\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n      expect(screen.getByText('n8n')).toBeInTheDocument()\n    })\n  })\n\n  it('shows custom categories when provided', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters availableCategories={['category1', 'category2']} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByText('Categories')).toBeInTheDocument()\n    expect(screen.getByLabelText('category1')).toBeInTheDocument()\n    expect(screen.getByLabelText('category2')).toBeInTheDocument()\n  })\n\n  it('shows custom agents when provided', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters availableAgents={['agent1', 'agent2']} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByText('Agents')).toBeInTheDocument()\n    expect(screen.getByLabelText('agent1')).toBeInTheDocument()\n    expect(screen.getByLabelText('agent2')).toBeInTheDocument()\n  })\n\n  it('removes individual filters when X is clicked', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    // Add a filter first\n    const activeCheckbox = screen.getByLabelText('active')\n    await user.click(activeCheckbox)\n\n    // Wait for active filters to appear\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n    })\n\n    // Find and click the X button to remove the filter\n    const removeButton = screen.getByRole('button', { name: /remove active filter/i }) ||\n                        screen.getByText('active').parentElement?.querySelector('svg')\n    \n    if (removeButton) {\n      await user.click(removeButton)\n    }\n\n    // Filter should be removed\n    await waitFor(() => {\n      expect(activeCheckbox).not.toBeChecked()\n    })\n  })\n\n  it('clears all filters when Clear All is clicked', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    // Add multiple filters\n    await user.click(screen.getByLabelText('active'))\n    await user.click(screen.getByLabelText('high'))\n\n    // Wait for filters to be applied\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n    })\n\n    // Click Clear All\n    await user.click(screen.getByText('Clear All'))\n\n    // All filters should be cleared\n    await waitFor(() => {\n      expect(screen.getByLabelText('active')).not.toBeChecked()\n      expect(screen.getByLabelText('high')).not.toBeChecked()\n      expect(screen.queryByText('Active Filters')).not.toBeInTheDocument()\n    })\n  })\n\n  it('shows share button when enabled', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters showShareButton />\n      </TestWrapper>\n    )\n\n    expect(screen.getByText('Share')).toBeInTheDocument()\n  })\n\n  it('hides share button when disabled', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters showShareButton={false} />\n      </TestWrapper>\n    )\n\n    expect(screen.queryByText('Share')).not.toBeInTheDocument()\n  })\n\n  it('copies URL to clipboard when share is clicked', async () => {\n    const mockWriteText = jest.fn()\n    navigator.clipboard.writeText = mockWriteText\n\n    render(\n      <TestWrapper>\n        <DashboardFilters showShareButton />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Share'))\n\n    expect(mockWriteText).toHaveBeenCalledWith(window.location.href)\n  })\n\n  it('hides presets when showPresets is false', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters showPresets={false} />\n      </TestWrapper>\n    )\n\n    expect(screen.queryByText('Quick Filters')).not.toBeInTheDocument()\n    expect(screen.queryByText('Last 7 Days')).not.toBeInTheDocument()\n  })\n\n  it('shows active filter count in compact mode', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters compact />\n      </TestWrapper>\n    )\n\n    // Open the popover\n    await user.click(screen.getByRole('button', { name: /filters/i }))\n\n    // Add a filter\n    const activeCheckbox = screen.getByLabelText('active')\n    await user.click(activeCheckbox)\n\n    // Close popover by clicking outside\n    await user.click(document.body)\n\n    // Should show filter count badge\n    await waitFor(() => {\n      expect(screen.getByText('1')).toBeInTheDocument()\n    })\n  })\n\n  it('shows Clear button in compact mode when filtered', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters compact />\n      </TestWrapper>\n    )\n\n    // Open the popover and add a filter\n    await user.click(screen.getByRole('button', { name: /filters/i }))\n    await user.click(screen.getByLabelText('active'))\n    await user.click(document.body) // Close popover\n\n    // Should show Clear button\n    await waitFor(() => {\n      expect(screen.getByText('Clear')).toBeInTheDocument()\n    })\n\n    // Click Clear button\n    await user.click(screen.getByText('Clear'))\n\n    // Clear button should disappear\n    await waitFor(() => {\n      expect(screen.queryByText('Clear')).not.toBeInTheDocument()\n    })\n  })\n\n  it('handles date range selection', async () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters />\n      </TestWrapper>\n    )\n\n    // Click on date range button\n    const dateButton = screen.getByText('Select date range')\n    await user.click(dateButton)\n\n    // Calendar should be visible\n    expect(screen.getByRole('grid')).toBeInTheDocument()\n  })\n\n  it('applies custom filter options', () => {\n    render(\n      <TestWrapper>\n        <DashboardFilters\n          availableStatuses={['custom-status']}\n          availablePriorities={['custom-priority']}\n          availablePlatforms={['custom-platform']}\n        />\n      </TestWrapper>\n    )\n\n    expect(screen.getByLabelText('custom-status')).toBeInTheDocument()\n    expect(screen.getByLabelText('custom-priority')).toBeInTheDocument()\n    expect(screen.getByLabelText('custom-platform')).toBeInTheDocument()\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/__tests__/filter-context.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'FilterValue' is defined but never used.",
        "line": 5,
        "column": 23,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'deletePreset' is assigned a value but never used.",
        "line": 48,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 48,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { useRouter, useSearchParams } from 'next/navigation'\nimport { FilterProvider, useFilters, useFilterValue, useIsFilterActive } from '../filter-context'\nimport { FilterState, FilterValue } from '@/types/dashboard'\n\n// Mock Next.js navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n  useSearchParams: jest.fn(),\n}))\n\nconst mockRouter = {\n  replace: jest.fn(),\n}\n\nconst mockSearchParams = {\n  get: jest.fn(),\n  toString: jest.fn(() => ''),\n}\n\n// Mock localStorage\nconst mockLocalStorage = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n}\n\nObject.defineProperty(window, 'localStorage', {\n  value: mockLocalStorage,\n})\n\n// Test component that uses the filter context\nfunction TestComponent() {\n  const {\n    filters,\n    setFilter,\n    removeFilter,\n    clearFilters,\n    setDateRange,\n    setCategories,\n    setStatus,\n    setPriority,\n    setPlatforms,\n    setAgents,\n    applyPreset,\n    savePreset,\n    deletePreset,\n    isFiltered,\n    activeFilterCount,\n    presets,\n  } = useFilters()\n\n  const searchValue = useFilterValue<string>('search')\n  const isSearchActive = useIsFilterActive('search')\n\n  return (\n    <div>\n      <div data-testid=\"filters\">{JSON.stringify(filters)}</div>\n      <div data-testid=\"is-filtered\">{isFiltered.toString()}</div>\n      <div data-testid=\"active-count\">{activeFilterCount}</div>\n      <div data-testid=\"search-value\">{searchValue || 'none'}</div>\n      <div data-testid=\"search-active\">{isSearchActive.toString()}</div>\n      <div data-testid=\"presets-count\">{presets.length}</div>\n      \n      <button\n        data-testid=\"set-filter\"\n        onClick={() => setFilter('search', { type: 'string', value: 'test', operator: 'contains' })}\n      >\n        Set Filter\n      </button>\n      \n      <button\n        data-testid=\"remove-filter\"\n        onClick={() => removeFilter('search')}\n      >\n        Remove Filter\n      </button>\n      \n      <button\n        data-testid=\"clear-filters\"\n        onClick={clearFilters}\n      >\n        Clear Filters\n      </button>\n      \n      <button\n        data-testid=\"set-date-range\"\n        onClick={() => setDateRange(new Date('2023-01-01'), new Date('2023-12-31'))}\n      >\n        Set Date Range\n      </button>\n      \n      <button\n        data-testid=\"set-categories\"\n        onClick={() => setCategories(['category1', 'category2'])}\n      >\n        Set Categories\n      </button>\n      \n      <button\n        data-testid=\"set-status\"\n        onClick={() => setStatus(['active', 'running'])}\n      >\n        Set Status\n      </button>\n      \n      <button\n        data-testid=\"set-priority\"\n        onClick={() => setPriority(['high', 'critical'])}\n      >\n        Set Priority\n      </button>\n      \n      <button\n        data-testid=\"set-platforms\"\n        onClick={() => setPlatforms(['n8n', 'make'])}\n      >\n        Set Platforms\n      </button>\n      \n      <button\n        data-testid=\"set-agents\"\n        onClick={() => setAgents(['agent1', 'agent2'])}\n      >\n        Set Agents\n      </button>\n      \n      <button\n        data-testid=\"apply-preset\"\n        onClick={() => applyPreset({\n          id: 'test-preset',\n          name: 'Test Preset',\n          filters: { status: ['active'] }\n        })}\n      >\n        Apply Preset\n      </button>\n      \n      <button\n        data-testid=\"save-preset\"\n        onClick={() => savePreset('My Preset', 'Test description')}\n      >\n        Save Preset\n      </button>\n    </div>\n  )\n}\n\ndescribe('FilterProvider', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n    ;(useRouter as jest.Mock).mockReturnValue(mockRouter)\n    ;(useSearchParams as jest.Mock).mockReturnValue(mockSearchParams)\n    mockLocalStorage.getItem.mockReturnValue(null)\n    mockSearchParams.get.mockReturnValue(null)\n  })\n\n  it('provides initial filter state', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    expect(screen.getByTestId('filters')).toHaveTextContent('{}')\n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('false')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('0')\n    expect(screen.getByTestId('search-value')).toHaveTextContent('none')\n    expect(screen.getByTestId('search-active')).toHaveTextContent('false')\n  })\n\n  it('includes default presets', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Should have default presets (last-7-days, last-30-days, high-priority, active-agents)\n    expect(screen.getByTestId('presets-count')).toHaveTextContent('4')\n  })\n\n  it('sets and removes custom filters', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Set a filter\n    fireEvent.click(screen.getByTestId('set-filter'))\n    \n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('true')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('1')\n    expect(screen.getByTestId('search-value')).toHaveTextContent('test')\n    expect(screen.getByTestId('search-active')).toHaveTextContent('true')\n\n    // Remove the filter\n    fireEvent.click(screen.getByTestId('remove-filter'))\n    \n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('false')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('0')\n    expect(screen.getByTestId('search-value')).toHaveTextContent('none')\n    expect(screen.getByTestId('search-active')).toHaveTextContent('false')\n  })\n\n  it('sets date range filter', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    fireEvent.click(screen.getByTestId('set-date-range'))\n    \n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('true')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('1')\n    \n    const filters = JSON.parse(screen.getByTestId('filters').textContent || '{}')\n    expect(filters.dateRange).toBeDefined()\n    expect(new Date(filters.dateRange.start)).toEqual(new Date('2023-01-01'))\n    expect(new Date(filters.dateRange.end)).toEqual(new Date('2023-12-31'))\n  })\n\n  it('sets array-based filters', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Set categories\n    fireEvent.click(screen.getByTestId('set-categories'))\n    expect(screen.getByTestId('active-count')).toHaveTextContent('1')\n    \n    // Set status\n    fireEvent.click(screen.getByTestId('set-status'))\n    expect(screen.getByTestId('active-count')).toHaveTextContent('2')\n    \n    // Set priority\n    fireEvent.click(screen.getByTestId('set-priority'))\n    expect(screen.getByTestId('active-count')).toHaveTextContent('3')\n    \n    // Set platforms\n    fireEvent.click(screen.getByTestId('set-platforms'))\n    expect(screen.getByTestId('active-count')).toHaveTextContent('4')\n    \n    // Set agents\n    fireEvent.click(screen.getByTestId('set-agents'))\n    expect(screen.getByTestId('active-count')).toHaveTextContent('5')\n\n    const filters = JSON.parse(screen.getByTestId('filters').textContent || '{}')\n    expect(filters.categories).toEqual(['category1', 'category2'])\n    expect(filters.status).toEqual(['active', 'running'])\n    expect(filters.priority).toEqual(['high', 'critical'])\n    expect(filters.platforms).toEqual(['n8n', 'make'])\n    expect(filters.agents).toEqual(['agent1', 'agent2'])\n  })\n\n  it('clears all filters', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Set multiple filters\n    fireEvent.click(screen.getByTestId('set-filter'))\n    fireEvent.click(screen.getByTestId('set-categories'))\n    fireEvent.click(screen.getByTestId('set-status'))\n    \n    expect(screen.getByTestId('active-count')).toHaveTextContent('3')\n\n    // Clear all filters\n    fireEvent.click(screen.getByTestId('clear-filters'))\n    \n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('false')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('0')\n    expect(screen.getByTestId('filters')).toHaveTextContent('{}')\n  })\n\n  it('applies presets', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    fireEvent.click(screen.getByTestId('apply-preset'))\n    \n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('true')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('1')\n    \n    const filters = JSON.parse(screen.getByTestId('filters').textContent || '{}')\n    expect(filters.status).toEqual(['active'])\n  })\n\n  it('saves custom presets', () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Set some filters first\n    fireEvent.click(screen.getByTestId('set-filter'))\n    fireEvent.click(screen.getByTestId('set-categories'))\n    \n    // Save as preset\n    fireEvent.click(screen.getByTestId('save-preset'))\n    \n    // Should have 5 presets now (4 default + 1 custom)\n    expect(screen.getByTestId('presets-count')).toHaveTextContent('5')\n  })\n\n  it('loads filters from localStorage', () => {\n    const storedFilters: FilterState = {\n      categories: ['stored-category'],\n      status: ['stored-status'],\n    }\n    \n    mockLocalStorage.getItem.mockReturnValue(JSON.stringify(storedFilters))\n\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('true')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('2')\n    \n    const filters = JSON.parse(screen.getByTestId('filters').textContent || '{}')\n    expect(filters.categories).toEqual(['stored-category'])\n    expect(filters.status).toEqual(['stored-status'])\n  })\n\n  it('loads filters from URL', () => {\n    const urlFilters: FilterState = {\n      priority: ['url-priority'],\n    }\n    \n    mockSearchParams.get.mockReturnValue(encodeURIComponent(JSON.stringify(urlFilters)))\n\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('true')\n    expect(screen.getByTestId('active-count')).toHaveTextContent('1')\n    \n    const filters = JSON.parse(screen.getByTestId('filters').textContent || '{}')\n    expect(filters.priority).toEqual(['url-priority'])\n  })\n\n  it('saves filters to localStorage when they change', async () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    fireEvent.click(screen.getByTestId('set-filter'))\n    \n    await waitFor(() => {\n      expect(mockLocalStorage.setItem).toHaveBeenCalledWith(\n        'dashboard-filters',\n        expect.stringContaining('search')\n      )\n    })\n  })\n\n  it('updates URL when filters change', async () => {\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    fireEvent.click(screen.getByTestId('set-filter'))\n    \n    await waitFor(() => {\n      expect(mockRouter.replace).toHaveBeenCalledWith(\n        expect.stringContaining('filters='),\n        { scroll: false }\n      )\n    })\n  })\n\n  it('handles configuration options', () => {\n    const customPresets = [\n      {\n        id: 'custom-preset',\n        name: 'Custom Preset',\n        filters: { status: ['custom'] },\n      },\n    ]\n\n    render(\n      <FilterProvider\n        configuration={{\n          persistent: false,\n          shareable: false,\n          presets: customPresets,\n        }}\n        storageKey=\"custom-key\"\n        enableUrlSync={false}\n      >\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Should have 4 default + 1 custom preset\n    expect(screen.getByTestId('presets-count')).toHaveTextContent('5')\n  })\n\n  it('handles invalid localStorage data gracefully', () => {\n    mockLocalStorage.getItem.mockReturnValue('invalid-json')\n\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Should still render with empty filters\n    expect(screen.getByTestId('filters')).toHaveTextContent('{}')\n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('false')\n  })\n\n  it('handles invalid URL data gracefully', () => {\n    mockSearchParams.get.mockReturnValue('invalid-encoded-data')\n\n    render(\n      <FilterProvider>\n        <TestComponent />\n      </FilterProvider>\n    )\n\n    // Should still render with empty filters\n    expect(screen.getByTestId('filters')).toHaveTextContent('{}')\n    expect(screen.getByTestId('is-filtered')).toHaveTextContent('false')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/__tests__/filter-controls.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 14,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 14,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [565, 568], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [565, 568], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 23,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 23,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [762, 765], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [762, 765], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 442,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 442,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12656, 12659], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12656, 12659], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { FilterControls, useFilteredData } from '../filter-controls'\nimport { FilterProvider } from '../filter-context'\n\n// Mock Next.js navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(() => ({ replace: jest.fn() })),\n  useSearchParams: jest.fn(() => ({ get: jest.fn(), toString: jest.fn(() => '') })),\n}))\n\n// Test wrapper with FilterProvider\nfunction TestWrapper({ children, ...props }: any) {\n  return (\n    <FilterProvider {...props}>\n      {children}\n    </FilterProvider>\n  )\n}\n\n// Test component for useFilteredData hook\nfunction FilteredDataTest({ data, searchFields }: { data: any[], searchFields: string[] }) {\n  const filteredData = useFilteredData(data, searchFields)\n  \n  return (\n    <div>\n      <div data-testid=\"filtered-count\">{filteredData.length}</div>\n      <div data-testid=\"filtered-data\">{JSON.stringify(filteredData)}</div>\n    </div>\n  )\n}\n\ndescribe('FilterControls', () => {\n  const user = userEvent.setup()\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('renders search input', () => {\n    render(\n      <TestWrapper>\n        <FilterControls />\n      </TestWrapper>\n    )\n\n    expect(screen.getByPlaceholderText('Search...')).toBeInTheDocument()\n  })\n\n  it('renders with custom search placeholder', () => {\n    render(\n      <TestWrapper>\n        <FilterControls searchPlaceholder=\"Custom search...\" />\n      </TestWrapper>\n    )\n\n    expect(screen.getByPlaceholderText('Custom search...')).toBeInTheDocument()\n  })\n\n  it('shows advanced filters button when enabled', () => {\n    render(\n      <TestWrapper>\n        <FilterControls showAdvancedFilters />\n      </TestWrapper>\n    )\n\n    expect(screen.getByText('Advanced')).toBeInTheDocument()\n  })\n\n  it('hides advanced filters button when disabled', () => {\n    render(\n      <TestWrapper>\n        <FilterControls showAdvancedFilters={false} />\n      </TestWrapper>\n    )\n\n    expect(screen.queryByText('Advanced')).not.toBeInTheDocument()\n  })\n\n  it('handles search input changes', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls />\n      </TestWrapper>\n    )\n\n    const searchInput = screen.getByPlaceholderText('Search...')\n    await user.type(searchInput, 'test search')\n\n    expect(searchInput).toHaveValue('test search')\n  })\n\n  it('shows clear button when search has value', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls />\n      </TestWrapper>\n    )\n\n    const searchInput = screen.getByPlaceholderText('Search...')\n    await user.type(searchInput, 'test')\n\n    // Clear button should appear\n    const clearButton = screen.getByRole('button', { name: /clear search/i }) ||\n                       searchInput.parentElement?.querySelector('button')\n    expect(clearButton).toBeInTheDocument()\n  })\n\n  it('clears search when clear button is clicked', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls />\n      </TestWrapper>\n    )\n\n    const searchInput = screen.getByPlaceholderText('Search...')\n    await user.type(searchInput, 'test')\n\n    // Find and click clear button\n    const clearButton = searchInput.parentElement?.querySelector('button')\n    if (clearButton) {\n      await user.click(clearButton)\n    }\n\n    expect(searchInput).toHaveValue('')\n  })\n\n  it('shows Clear All button when filters are active', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls />\n      </TestWrapper>\n    )\n\n    // Add a search filter\n    const searchInput = screen.getByPlaceholderText('Search...')\n    await user.type(searchInput, 'test')\n\n    // Clear All button should appear\n    await waitFor(() => {\n      expect(screen.getByText('Clear All')).toBeInTheDocument()\n    })\n  })\n\n  it('opens advanced filters popover', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls showAdvancedFilters />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Advanced'))\n\n    expect(screen.getByText('Advanced Filters')).toBeInTheDocument()\n    expect(screen.getByText('Add Custom Filter')).toBeInTheDocument()\n  })\n\n  it('renders custom filter options', async () => {\n    const customOptions = [\n      { key: 'department', label: 'Department', type: 'select' as const, options: ['IT', 'HR', 'Finance'] },\n      { key: 'score', label: 'Score', type: 'number' as const },\n      { key: 'description', label: 'Description', type: 'string' as const },\n    ]\n\n    render(\n      <TestWrapper>\n        <FilterControls\n          showAdvancedFilters\n          customFilterOptions={customOptions}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Advanced'))\n\n    expect(screen.getByText('Department')).toBeInTheDocument()\n    expect(screen.getByText('Score')).toBeInTheDocument()\n    expect(screen.getByText('Description')).toBeInTheDocument()\n  })\n\n  it('handles select-type custom filters', async () => {\n    const customOptions = [\n      { key: 'department', label: 'Department', type: 'select' as const, options: ['IT', 'HR'] },\n    ]\n\n    render(\n      <TestWrapper>\n        <FilterControls\n          showAdvancedFilters\n          customFilterOptions={customOptions}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Advanced'))\n    \n    // Find and click the department select\n    const departmentSelect = screen.getByRole('combobox', { name: /department/i })\n    await user.click(departmentSelect)\n\n    // Select IT option\n    await user.click(screen.getByText('IT'))\n\n    // Should show active filter\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n      expect(screen.getByText('department: IT')).toBeInTheDocument()\n    })\n  })\n\n  it('adds custom filters through the builder', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls showAdvancedFilters />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Advanced'))\n\n    // Fill in custom filter form\n    const nameInput = screen.getByPlaceholderText('Filter name')\n    const valueInput = screen.getByPlaceholderText('Filter value')\n    \n    await user.type(nameInput, 'custom-field')\n    await user.type(valueInput, 'custom-value')\n\n    // Click Add Filter button\n    await user.click(screen.getByText('Add Filter'))\n\n    // Should show active filter\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n      expect(screen.getByText('custom-field: custom-value')).toBeInTheDocument()\n    })\n  })\n\n  it('handles different filter types in custom builder', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls showAdvancedFilters />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Advanced'))\n\n    // Change filter type to number\n    const typeSelect = screen.getByDisplayValue('Text')\n    await user.click(typeSelect)\n    await user.click(screen.getByText('Number'))\n\n    // Value input should now be number type\n    const valueInput = screen.getByPlaceholderText('Filter value')\n    expect(valueInput).toHaveAttribute('type', 'number')\n  })\n\n  it('shows different operators for number filters', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls showAdvancedFilters />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Advanced'))\n\n    // Change filter type to number\n    const typeSelect = screen.getByDisplayValue('Text')\n    await user.click(typeSelect)\n    await user.click(screen.getByText('Number'))\n\n    // Operator select should show number-specific options\n    const operatorSelect = screen.getByDisplayValue('Contains')\n    await user.click(operatorSelect)\n\n    expect(screen.getByText('Greater Than')).toBeInTheDocument()\n    expect(screen.getByText('Less Than')).toBeInTheDocument()\n  })\n\n  it('removes active filters when X is clicked', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls />\n      </TestWrapper>\n    )\n\n    // Add a search filter\n    const searchInput = screen.getByPlaceholderText('Search...')\n    await user.type(searchInput, 'test')\n\n    // Wait for active filters to appear\n    await waitFor(() => {\n      expect(screen.getByText('Active Filters')).toBeInTheDocument()\n    })\n\n    // Find and click X button\n    const removeButton = screen.getByText('search: test').parentElement?.querySelector('svg')\n    if (removeButton) {\n      await user.click(removeButton)\n    }\n\n    // Filter should be removed\n    await waitFor(() => {\n      expect(screen.queryByText('Active Filters')).not.toBeInTheDocument()\n    })\n  })\n\n  it('disables Add Filter button when fields are empty', async () => {\n    render(\n      <TestWrapper>\n        <FilterControls showAdvancedFilters />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByText('Advanced'))\n\n    const addButton = screen.getByText('Add Filter')\n    expect(addButton).toBeDisabled()\n\n    // Fill in name only\n    const nameInput = screen.getByPlaceholderText('Filter name')\n    await user.type(nameInput, 'test')\n\n    expect(addButton).toBeDisabled()\n\n    // Fill in value\n    const valueInput = screen.getByPlaceholderText('Filter value')\n    await user.type(valueInput, 'value')\n\n    expect(addButton).not.toBeDisabled()\n  })\n})\n\ndescribe('useFilteredData', () => {\n  const testData = [\n    { id: 1, name: 'John Doe', status: 'active', priority: 'high', category: 'user', createdAt: '2023-01-15' },\n    { id: 2, name: 'Jane Smith', status: 'inactive', priority: 'low', category: 'admin', createdAt: '2023-02-20' },\n    { id: 3, name: 'Bob Johnson', status: 'active', priority: 'medium', category: 'user', createdAt: '2023-03-10' },\n  ]\n\n  it('returns all data when no filters are applied', () => {\n    render(\n      <TestWrapper>\n        <FilteredDataTest data={testData} searchFields={['name']} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('filtered-count')).toHaveTextContent('3')\n  })\n\n  it('filters data by search term', async () => {\n    const TestComponent = () => {\n      return (\n        <TestWrapper>\n          <FilterControls />\n          <FilteredDataTest data={testData} searchFields={['name']} />\n        </TestWrapper>\n      )\n    }\n\n    render(<TestComponent />)\n\n    // Add search filter\n    const searchInput = screen.getByPlaceholderText('Search...')\n    await userEvent.type(searchInput, 'John')\n\n    await waitFor(() => {\n      expect(screen.getByTestId('filtered-count')).toHaveTextContent('2')\n    })\n  })\n\n  it('filters data by status', async () => {\n    const TestComponent = () => {\n      return (\n        <TestWrapper>\n          <FilterControls showAdvancedFilters />\n          <FilteredDataTest data={testData} searchFields={['name']} />\n        </TestWrapper>\n      )\n    }\n\n    render(<TestComponent />)\n\n    // Add status filter through advanced filters\n    await userEvent.click(screen.getByText('Advanced'))\n    \n    const nameInput = screen.getByPlaceholderText('Filter name')\n    const valueInput = screen.getByPlaceholderText('Filter value')\n    \n    await userEvent.type(nameInput, 'status')\n    await userEvent.type(valueInput, 'active')\n    await userEvent.click(screen.getByText('Add Filter'))\n\n    await waitFor(() => {\n      expect(screen.getByTestId('filtered-count')).toHaveTextContent('2')\n    })\n  })\n\n  it('filters data by multiple criteria', async () => {\n    const TestComponent = () => {\n      return (\n        <TestWrapper>\n          <FilterControls showAdvancedFilters />\n          <FilteredDataTest data={testData} searchFields={['name']} />\n        </TestWrapper>\n      )\n    }\n\n    render(<TestComponent />)\n\n    // Add search filter\n    const searchInput = screen.getByPlaceholderText('Search...')\n    await userEvent.type(searchInput, 'John')\n\n    // Add status filter\n    await userEvent.click(screen.getByText('Advanced'))\n    \n    const nameInput = screen.getByPlaceholderText('Filter name')\n    const valueInput = screen.getByPlaceholderText('Filter value')\n    \n    await userEvent.type(nameInput, 'status')\n    await userEvent.type(valueInput, 'active')\n    await userEvent.click(screen.getByText('Add Filter'))\n\n    await waitFor(() => {\n      expect(screen.getByTestId('filtered-count')).toHaveTextContent('1')\n    })\n  })\n\n  it('handles empty data gracefully', () => {\n    render(\n      <TestWrapper>\n        <FilteredDataTest data={[]} searchFields={['name']} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('filtered-count')).toHaveTextContent('0')\n  })\n\n  it('handles null/undefined data gracefully', () => {\n    render(\n      <TestWrapper>\n        <FilteredDataTest data={null as any} searchFields={['name']} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('filtered-count')).toHaveTextContent('0')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/__tests__/filter-synchronizer.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 19,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 19,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [635, 638], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [635, 638], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 62,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 62,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1642, 1645], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1642, 1645], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 73,
        "column": 9,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 73,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1896, 1899], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1896, 1899], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 75,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 75,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1955, 1958], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1955, 1958], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 75,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 75,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1969, 1972], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1969, 1972], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'filters' is defined but never used.",
        "line": 373,
        "column": 40,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 373,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 401,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 401,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10142, 10145], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10142, 10145], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { \n  FilterSynchronizer, \n  useFilterSync, \n  useSyncedFilteredData, \n  FilterDebugger \n} from '../filter-synchronizer'\nimport { FilterProvider, useFilters } from '../filter-context'\n\n// Mock Next.js navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(() => ({ replace: jest.fn() })),\n  useSearchParams: jest.fn(() => ({ get: jest.fn(), toString: jest.fn(() => '') })),\n}))\n\n// Test wrapper with FilterProvider\nfunction TestWrapper({ children, ...props }: any) {\n  return (\n    <FilterProvider {...props}>\n      {children}\n    </FilterProvider>\n  )\n}\n\n// Test component that uses filters\nfunction TestFilterComponent() {\n  const { setFilter, setCategories, setStatus, clearFilters } = useFilters()\n\n  return (\n    <div>\n      <button\n        data-testid=\"set-custom-filter\"\n        onClick={() => setFilter('test', { type: 'string', value: 'test-value', operator: 'equals' })}\n      >\n        Set Custom Filter\n      </button>\n      <button\n        data-testid=\"set-categories\"\n        onClick={() => setCategories(['cat1', 'cat2'])}\n      >\n        Set Categories\n      </button>\n      <button\n        data-testid=\"set-status\"\n        onClick={() => setStatus(['active'])}\n      >\n        Set Status\n      </button>\n      <button\n        data-testid=\"clear-filters\"\n        onClick={clearFilters}\n      >\n        Clear Filters\n      </button>\n    </div>\n  )\n}\n\n// Test component for useFilterSync hook\nfunction FilterSyncTest({ callback }: { callback: (filters: any) => void }) {\n  useFilterSync(callback)\n  return <div data-testid=\"filter-sync-test\">Filter Sync Test</div>\n}\n\n// Test component for useSyncedFilteredData hook\nfunction SyncedFilteredDataTest({ \n  data, \n  searchFields, \n  customLogic \n}: { \n  data: any[], \n  searchFields?: string[], \n  customLogic?: (item: any, filters: any) => boolean \n}) {\n  const filteredData = useSyncedFilteredData(data, searchFields, customLogic)\n  \n  return (\n    <div>\n      <div data-testid=\"filtered-count\">{filteredData.length}</div>\n      <div data-testid=\"filtered-data\">{JSON.stringify(filteredData)}</div>\n    </div>\n  )\n}\n\ndescribe('FilterSynchronizer', () => {\n  const user = userEvent.setup()\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n    jest.useFakeTimers()\n  })\n\n  afterEach(() => {\n    jest.useRealTimers()\n  })\n\n  it('renders children without issues', () => {\n    render(\n      <TestWrapper>\n        <FilterSynchronizer>\n          <div data-testid=\"child-content\">Child Content</div>\n        </FilterSynchronizer>\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('child-content')).toBeInTheDocument()\n  })\n\n  it('calls onFilterChange when filters change', async () => {\n    const onFilterChange = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterSynchronizer onFilterChange={onFilterChange}>\n          <TestFilterComponent />\n        </FilterSynchronizer>\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-custom-filter'))\n\n    // Fast-forward timers to trigger debounced callback\n    jest.advanceTimersByTime(300)\n\n    await waitFor(() => {\n      expect(onFilterChange).toHaveBeenCalled()\n    })\n  })\n\n  it('calls onFilterApplied when filters are added', async () => {\n    const onFilterApplied = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterSynchronizer onFilterApplied={onFilterApplied}>\n          <TestFilterComponent />\n        </FilterSynchronizer>\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-custom-filter'))\n\n    await waitFor(() => {\n      expect(onFilterApplied).toHaveBeenCalledWith(\n        'test',\n        { type: 'string', value: 'test-value', operator: 'equals' }\n      )\n    })\n  })\n\n  it('calls onFilterRemoved when filters are removed', async () => {\n    const onFilterRemoved = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterSynchronizer onFilterRemoved={onFilterRemoved}>\n          <TestFilterComponent />\n        </FilterSynchronizer>\n      </TestWrapper>\n    )\n\n    // Add a filter first\n    await user.click(screen.getByTestId('set-custom-filter'))\n\n    // Then clear all filters\n    await user.click(screen.getByTestId('clear-filters'))\n\n    await waitFor(() => {\n      expect(onFilterRemoved).toHaveBeenCalledWith('test')\n    })\n  })\n\n  it('handles array-based filter changes', async () => {\n    const onFilterApplied = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterSynchronizer onFilterApplied={onFilterApplied}>\n          <TestFilterComponent />\n        </FilterSynchronizer>\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-categories'))\n\n    await waitFor(() => {\n      expect(onFilterApplied).toHaveBeenCalledWith(\n        'categories',\n        { type: 'array', value: ['cat1', 'cat2'], operator: 'equals' }\n      )\n    })\n  })\n\n  it('debounces filter change callbacks', async () => {\n    const onFilterChange = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterSynchronizer onFilterChange={onFilterChange} syncDelay={500}>\n          <TestFilterComponent />\n        </FilterSynchronizer>\n      </TestWrapper>\n    )\n\n    // Trigger multiple filter changes quickly\n    await user.click(screen.getByTestId('set-custom-filter'))\n    await user.click(screen.getByTestId('set-categories'))\n    await user.click(screen.getByTestId('set-status'))\n\n    // Should not have been called yet\n    expect(onFilterChange).not.toHaveBeenCalled()\n\n    // Fast-forward timers\n    jest.advanceTimersByTime(500)\n\n    await waitFor(() => {\n      // Should only be called once due to debouncing\n      expect(onFilterChange).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  it('cleans up timeout on unmount', () => {\n    const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout')\n\n    const { unmount } = render(\n      <TestWrapper>\n        <FilterSynchronizer onFilterChange={jest.fn()}>\n          <TestFilterComponent />\n        </FilterSynchronizer>\n      </TestWrapper>\n    )\n\n    unmount()\n\n    expect(clearTimeoutSpy).toHaveBeenCalled()\n  })\n})\n\ndescribe('useFilterSync', () => {\n  const user = userEvent.setup()\n\n  it('calls callback when filters change', async () => {\n    const callback = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterSyncTest callback={callback} />\n        <TestFilterComponent />\n      </TestWrapper>\n    )\n\n    // Initial call\n    expect(callback).toHaveBeenCalledWith({})\n\n    await user.click(screen.getByTestId('set-custom-filter'))\n\n    await waitFor(() => {\n      expect(callback).toHaveBeenCalledTimes(2)\n      expect(callback).toHaveBeenLastCalledWith(\n        expect.objectContaining({\n          customFilters: expect.objectContaining({\n            test: { type: 'string', value: 'test-value', operator: 'equals' }\n          })\n        })\n      )\n    })\n  })\n\n  it('updates callback when callback changes', () => {\n    const callback1 = jest.fn()\n    const callback2 = jest.fn()\n\n    const { rerender } = render(\n      <TestWrapper>\n        <FilterSyncTest callback={callback1} />\n      </TestWrapper>\n    )\n\n    expect(callback1).toHaveBeenCalledWith({})\n\n    rerender(\n      <TestWrapper>\n        <FilterSyncTest callback={callback2} />\n      </TestWrapper>\n    )\n\n    expect(callback2).toHaveBeenCalledWith({})\n  })\n})\n\ndescribe('useSyncedFilteredData', () => {\n  const user = userEvent.setup()\n\n  const testData = [\n    { id: 1, name: 'John Doe', status: 'active', category: 'user' },\n    { id: 2, name: 'Jane Smith', status: 'inactive', category: 'admin' },\n    { id: 3, name: 'Bob Johnson', status: 'active', category: 'user' },\n  ]\n\n  it('returns all data when no filters are applied', () => {\n    render(\n      <TestWrapper>\n        <SyncedFilteredDataTest data={testData} searchFields={['name']} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('filtered-count')).toHaveTextContent('3')\n  })\n\n  it('filters data based on search filter', async () => {\n    const TestComponent = () => {\n      const { setFilter } = useFilters()\n      \n      return (\n        <div>\n          <button\n            data-testid=\"set-search\"\n            onClick={() => setFilter('search', { type: 'string', value: 'John', operator: 'contains' })}\n          >\n            Set Search\n          </button>\n          <SyncedFilteredDataTest data={testData} searchFields={['name']} />\n        </div>\n      )\n    }\n\n    render(\n      <TestWrapper>\n        <TestComponent />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-search'))\n\n    await waitFor(() => {\n      expect(screen.getByTestId('filtered-count')).toHaveTextContent('2')\n    })\n  })\n\n  it('filters data based on status filter', async () => {\n    const TestComponent = () => {\n      const { setStatus } = useFilters()\n      \n      return (\n        <div>\n          <button\n            data-testid=\"set-status-filter\"\n            onClick={() => setStatus(['active'])}\n          >\n            Set Status Filter\n          </button>\n          <SyncedFilteredDataTest data={testData} />\n        </div>\n      )\n    }\n\n    render(\n      <TestWrapper>\n        <TestComponent />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-status-filter'))\n\n    await waitFor(() => {\n      expect(screen.getByTestId('filtered-count')).toHaveTextContent('2')\n    })\n  })\n\n  it('uses custom filter logic when provided', async () => {\n    const customLogic = jest.fn((item, filters) => item.id > 1)\n\n    render(\n      <TestWrapper>\n        <SyncedFilteredDataTest \n          data={testData} \n          customLogic={customLogic}\n        />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('filtered-count')).toHaveTextContent('2')\n    expect(customLogic).toHaveBeenCalled()\n  })\n\n  it('handles empty data gracefully', () => {\n    render(\n      <TestWrapper>\n        <SyncedFilteredDataTest data={[]} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('filtered-count')).toHaveTextContent('0')\n  })\n\n  it('handles null data gracefully', () => {\n    render(\n      <TestWrapper>\n        <SyncedFilteredDataTest data={null as any} />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('filtered-count')).toHaveTextContent('0')\n  })\n\n  it('filters by multiple criteria', async () => {\n    const TestComponent = () => {\n      const { setFilter, setStatus } = useFilters()\n      \n      return (\n        <div>\n          <button\n            data-testid=\"set-multiple-filters\"\n            onClick={() => {\n              setFilter('search', { type: 'string', value: 'John', operator: 'contains' })\n              setStatus(['active'])\n            }}\n          >\n            Set Multiple Filters\n          </button>\n          <SyncedFilteredDataTest data={testData} searchFields={['name']} />\n        </div>\n      )\n    }\n\n    render(\n      <TestWrapper>\n        <TestComponent />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-multiple-filters'))\n\n    await waitFor(() => {\n      expect(screen.getByTestId('filtered-count')).toHaveTextContent('1')\n    })\n  })\n})\n\ndescribe('FilterDebugger', () => {\n  const user = userEvent.setup()\n\n  it('renders nothing when disabled', () => {\n    render(\n      <TestWrapper>\n        <FilterDebugger enabled={false} />\n      </TestWrapper>\n    )\n\n    expect(screen.queryByText('Filter Debug')).not.toBeInTheDocument()\n  })\n\n  it('renders debug info when enabled', () => {\n    render(\n      <TestWrapper>\n        <FilterDebugger enabled />\n      </TestWrapper>\n    )\n\n    expect(screen.getByText('Filter Debug')).toBeInTheDocument()\n    expect(screen.getByText('Active: No')).toBeInTheDocument()\n    expect(screen.getByText('Count: 0')).toBeInTheDocument()\n  })\n\n  it('updates debug info when filters change', async () => {\n    render(\n      <TestWrapper>\n        <FilterDebugger enabled />\n        <TestFilterComponent />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-custom-filter'))\n\n    await waitFor(() => {\n      expect(screen.getByText('Active: Yes')).toBeInTheDocument()\n      expect(screen.getByText('Count: 1')).toBeInTheDocument()\n    })\n  })\n\n  it('shows filter state in details', async () => {\n    render(\n      <TestWrapper>\n        <FilterDebugger enabled />\n        <TestFilterComponent />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('set-custom-filter'))\n\n    // Open details\n    const summary = screen.getByText('Filter State')\n    await user.click(summary)\n\n    await waitFor(() => {\n      expect(screen.getByText(/\"test\"/)).toBeInTheDocument()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/__tests__/filterable-card.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'waitFor' is defined but never used.",
        "line": 2,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 72,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 75,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [625, 628], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [625, 628], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 34,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 34,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1115, 1118], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1115, 1118], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'onFilter' is defined but never used.",
        "line": 262,
        "column": 32,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 262,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 262,
        "column": 74,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 262,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6824, 6827], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6824, 6827], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { FilterableCard, withCardFiltering } from '../filterable-card'\nimport { FilterProvider } from '../filter-context'\n\n// Mock Next.js navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(() => ({ replace: jest.fn() })),\n  useSearchParams: jest.fn(() => ({ get: jest.fn(), toString: jest.fn(() => '') })),\n}))\n\n// Mock DashboardCard\njest.mock('../cards/dashboard-card', () => ({\n  DashboardCard: ({ onClick, onFilter, interactive, title, ...props }: any) => (\n    <div \n      data-testid=\"dashboard-card\" \n      onClick={onClick}\n      role={interactive ? 'button' : undefined}\n      {...props}\n    >\n      <div data-testid=\"card-title\">{title}</div>\n      <button\n        data-testid=\"trigger-filter\"\n        onClick={() => onFilter?.({ type: 'string', value: 'test', operator: 'equals' })}\n      >\n        Trigger Filter\n      </button>\n    </div>\n  )\n}))\n\n// Test wrapper with FilterProvider\nfunction TestWrapper({ children, ...props }: any) {\n  return (\n    <FilterProvider {...props}>\n      {children}\n    </FilterProvider>\n  )\n}\n\ndescribe('FilterableCard', () => {\n  const user = userEvent.setup()\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('renders dashboard card with props', () => {\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          metric={{ value: 100, unit: 'items' }}\n        />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('dashboard-card')).toBeInTheDocument()\n    expect(screen.getByTestId('card-title')).toHaveTextContent('Test Card')\n  })\n\n  it('makes card interactive when filtering is enabled', () => {\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    const card = screen.getByTestId('dashboard-card')\n    expect(card).toHaveAttribute('role', 'button')\n  })\n\n  it('handles card clicks with default filtering using filterData', async () => {\n    const filterData = {\n      category: 'test-category',\n      status: 'active',\n      priority: 'high'\n    }\n\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          enableFiltering\n          filterData={filterData}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('dashboard-card'))\n\n    // Should apply filters based on filterData\n    // We can't easily test the filter state without exposing it,\n    // but we can verify the click was handled\n    expect(screen.getByTestId('dashboard-card')).toBeInTheDocument()\n  })\n\n  it('handles card clicks with custom filter mappings', async () => {\n    const customMapping = jest.fn(() => ({\n      customFilter: {\n        type: 'string' as const,\n        value: 'custom-value',\n        operator: 'equals' as const,\n      }\n    }))\n\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          enableFiltering\n          filterMappings={{\n            cardClick: customMapping\n          }}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('dashboard-card'))\n\n    expect(customMapping).toHaveBeenCalled()\n  })\n\n  it('falls back to title-based filtering when no filterData or mappings', async () => {\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Fallback Card\"\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('dashboard-card'))\n\n    // Should apply cardTitle filter\n    expect(screen.getByTestId('dashboard-card')).toBeInTheDocument()\n  })\n\n  it('calls custom onClick handler before applying filters', async () => {\n    const customOnClick = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          enableFiltering\n          onClick={customOnClick}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('dashboard-card'))\n\n    expect(customOnClick).toHaveBeenCalled()\n  })\n\n  it('calls onFilter callback when filters are applied', async () => {\n    const onFilter = jest.fn()\n    const filterData = { category: 'test' }\n\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          enableFiltering\n          filterData={filterData}\n          onFilter={onFilter}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('dashboard-card'))\n\n    expect(onFilter).toHaveBeenCalledWith({\n      type: 'string',\n      value: 'test',\n      operator: 'equals'\n    })\n  })\n\n  it('disables filtering when enableFiltering is false', async () => {\n    const customOnClick = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          enableFiltering={false}\n          onClick={customOnClick}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('dashboard-card'))\n\n    // Custom handler should still be called\n    expect(customOnClick).toHaveBeenCalled()\n    // But card should not be interactive due to filtering\n    const card = screen.getByTestId('dashboard-card')\n    expect(card).not.toHaveAttribute('role', 'button')\n  })\n\n  it('handles different data types in filterData', async () => {\n    const filterData = {\n      stringField: 'text-value',\n      numberField: 42,\n      booleanField: true,\n      nullField: null,\n      undefinedField: undefined\n    }\n\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          enableFiltering\n          filterData={filterData}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('dashboard-card'))\n\n    // Should handle different data types appropriately\n    // null and undefined values should be ignored\n    expect(screen.getByTestId('dashboard-card')).toBeInTheDocument()\n  })\n\n  it('passes through all card props', () => {\n    render(\n      <TestWrapper>\n        <FilterableCard\n          title=\"Test Card\"\n          subtitle=\"Test Subtitle\"\n          size=\"lg\"\n          priority=\"high\"\n          loading={false}\n          className=\"custom-class\"\n        />\n      </TestWrapper>\n    )\n\n    const card = screen.getByTestId('dashboard-card')\n    expect(card).toHaveAttribute('title', 'Test Card')\n    expect(card).toHaveAttribute('subtitle', 'Test Subtitle')\n    expect(card).toHaveAttribute('size', 'lg')\n    expect(card).toHaveAttribute('priority', 'high')\n    expect(card).toHaveAttribute('loading', 'false')\n    expect(card).toHaveAttribute('className', 'custom-class')\n  })\n})\n\ndescribe('withCardFiltering HOC', () => {\n  const user = userEvent.setup()\n\n  // Mock component to wrap\n  const MockCard = ({ onClick, onFilter, interactive, title, ...props }: any) => (\n    <div \n      data-testid=\"mock-card\" \n      onClick={onClick}\n      role={interactive ? 'button' : undefined}\n      {...props}\n    >\n      <div data-testid=\"mock-title\">{title}</div>\n    </div>\n  )\n\n  it('wraps component with filtering functionality', async () => {\n    const FilterableMockCard = withCardFiltering(MockCard)\n\n    render(\n      <TestWrapper>\n        <FilterableMockCard\n          title=\"HOC Card\"\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('mock-card')).toBeInTheDocument()\n    expect(screen.getByTestId('mock-title')).toHaveTextContent('HOC Card')\n\n    const card = screen.getByTestId('mock-card')\n    expect(card).toHaveAttribute('role', 'button')\n\n    await user.click(card)\n    // Should apply filtering\n  })\n\n  it('uses default filter mappings provided to HOC', async () => {\n    const defaultMappings = {\n      cardClick: jest.fn(() => ({\n        defaultFilter: {\n          type: 'string' as const,\n          value: 'default-value',\n          operator: 'equals' as const,\n        }\n      }))\n    }\n\n    const FilterableMockCard = withCardFiltering(MockCard, defaultMappings)\n\n    render(\n      <TestWrapper>\n        <FilterableMockCard\n          title=\"HOC Card\"\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('mock-card'))\n\n    expect(defaultMappings.cardClick).toHaveBeenCalled()\n  })\n\n  it('allows overriding default mappings', async () => {\n    const defaultMappings = {\n      cardClick: jest.fn(() => ({ default: { type: 'string' as const, value: 'default', operator: 'equals' as const } }))\n    }\n\n    const overrideMappings = {\n      cardClick: jest.fn(() => ({ override: { type: 'string' as const, value: 'override', operator: 'equals' as const } }))\n    }\n\n    const FilterableMockCard = withCardFiltering(MockCard, defaultMappings)\n\n    render(\n      <TestWrapper>\n        <FilterableMockCard\n          title=\"HOC Card\"\n          enableFiltering\n          filterMappings={overrideMappings}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('mock-card'))\n\n    expect(overrideMappings.cardClick).toHaveBeenCalled()\n    expect(defaultMappings.cardClick).not.toHaveBeenCalled()\n  })\n\n  it('handles filterData in HOC', async () => {\n    const FilterableMockCard = withCardFiltering(MockCard)\n    const filterData = { category: 'hoc-category' }\n\n    render(\n      <TestWrapper>\n        <FilterableMockCard\n          title=\"HOC Card\"\n          enableFiltering\n          filterData={filterData}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('mock-card'))\n\n    // Should apply filters based on filterData\n    expect(screen.getByTestId('mock-card')).toBeInTheDocument()\n  })\n\n  it('calls custom handlers in HOC', async () => {\n    const customOnClick = jest.fn()\n    const customOnFilter = jest.fn()\n    const FilterableMockCard = withCardFiltering(MockCard)\n\n    render(\n      <TestWrapper>\n        <FilterableMockCard\n          title=\"HOC Card\"\n          enableFiltering\n          onClick={customOnClick}\n          onFilter={customOnFilter}\n          filterData={{ test: 'value' }}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('mock-card'))\n\n    expect(customOnClick).toHaveBeenCalled()\n    expect(customOnFilter).toHaveBeenCalled()\n  })\n\n  it('passes through all props to wrapped component', () => {\n    const FilterableMockCard = withCardFiltering(MockCard)\n\n    render(\n      <TestWrapper>\n        <FilterableMockCard\n          title=\"HOC Card\"\n          customProp=\"test-value\"\n          anotherProp={123}\n        />\n      </TestWrapper>\n    )\n\n    const mockCard = screen.getByTestId('mock-card')\n    expect(mockCard).toHaveAttribute('title', 'HOC Card')\n    expect(mockCard).toHaveAttribute('customProp', 'test-value')\n    expect(mockCard).toHaveAttribute('anotherProp', '123')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/__tests__/filterable-chart.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fireEvent' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'waitFor' is defined but never used.",
        "line": 2,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ChartDataPoint' is defined but never used.",
        "line": 6,
        "column": 21,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'LegendItem' is defined but never used.",
        "line": 6,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 16,
        "column": 60,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 16,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [684, 687], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [684, 687], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 45,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 45,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1383, 1386], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1383, 1386], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 261,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 261,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6825, 6828], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6825, 6828], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { FilterableChart, withFiltering } from '../filterable-chart'\nimport { FilterProvider } from '../filter-context'\nimport { ChartData, ChartDataPoint, LegendItem } from '@/types/dashboard'\n\n// Mock Next.js navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(() => ({ replace: jest.fn() })),\n  useSearchParams: jest.fn(() => ({ get: jest.fn(), toString: jest.fn(() => '') })),\n}))\n\n// Mock ChartWrapper\njest.mock('../charts/chart-wrapper', () => ({\n  ChartWrapper: ({ onDataClick, onLegendClick, ...props }: any) => (\n    <div data-testid=\"chart-wrapper\" {...props}>\n      <button\n        data-testid=\"data-point\"\n        onClick={() => onDataClick?.({\n          x: 'Category A',\n          y: 100,\n          value: 100,\n          label: 'Category A',\n          metadata: { category: 'Category A', series: 'Series 1' }\n        })}\n      >\n        Click Data Point\n      </button>\n      <button\n        data-testid=\"legend-item\"\n        onClick={() => onLegendClick?.({\n          label: 'Series 1',\n          color: '#3F51B5',\n          visible: true\n        })}\n      >\n        Click Legend\n      </button>\n    </div>\n  )\n}))\n\n// Test wrapper with FilterProvider\nfunction TestWrapper({ children, ...props }: any) {\n  return (\n    <FilterProvider {...props}>\n      {children}\n    </FilterProvider>\n  )\n}\n\nconst mockChartData: ChartData = {\n  datasets: [\n    {\n      label: 'Series 1',\n      data: [\n        { x: 'Category A', y: 100, label: 'Category A' },\n        { x: 'Category B', y: 200, label: 'Category B' },\n      ]\n    }\n  ]\n}\n\ndescribe('FilterableChart', () => {\n  const user = userEvent.setup()\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('renders chart wrapper with props', () => {\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"bar\"\n          data={mockChartData}\n          height={300}\n        />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('chart-wrapper')).toBeInTheDocument()\n  })\n\n  it('handles data point clicks with default filtering', async () => {\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"bar\"\n          data={mockChartData}\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('data-point'))\n\n    // Should apply default category filter\n    // We can't easily test the filter state without exposing it,\n    // but we can verify the click handler was called\n    expect(screen.getByTestId('data-point')).toBeInTheDocument()\n  })\n\n  it('handles legend clicks with default filtering', async () => {\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"bar\"\n          data={mockChartData}\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('legend-item'))\n\n    // Should apply default series filter\n    expect(screen.getByTestId('legend-item')).toBeInTheDocument()\n  })\n\n  it('uses custom filter mappings for data clicks', async () => {\n    const customDataMapping = jest.fn(() => ({\n      customFilter: {\n        type: 'string' as const,\n        value: 'custom-value',\n        operator: 'equals' as const,\n      }\n    }))\n\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"bar\"\n          data={mockChartData}\n          enableFiltering\n          filterMappings={{\n            dataClick: customDataMapping\n          }}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('data-point'))\n\n    expect(customDataMapping).toHaveBeenCalledWith({\n      x: 'Category A',\n      y: 100,\n      value: 100,\n      label: 'Category A',\n      metadata: { category: 'Category A', series: 'Series 1' }\n    })\n  })\n\n  it('uses custom filter mappings for legend clicks', async () => {\n    const customLegendMapping = jest.fn(() => ({\n      customLegendFilter: {\n        type: 'string' as const,\n        value: 'legend-value',\n        operator: 'equals' as const,\n      }\n    }))\n\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"bar\"\n          data={mockChartData}\n          enableFiltering\n          filterMappings={{\n            legendClick: customLegendMapping\n          }}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('legend-item'))\n\n    expect(customLegendMapping).toHaveBeenCalledWith({\n      label: 'Series 1',\n      color: '#3F51B5',\n      visible: true\n    })\n  })\n\n  it('calls custom handlers before applying filters', async () => {\n    const customDataClick = jest.fn()\n    const customLegendClick = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"bar\"\n          data={mockChartData}\n          enableFiltering\n          onDataClick={customDataClick}\n          onLegendClick={customLegendClick}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('data-point'))\n    await user.click(screen.getByTestId('legend-item'))\n\n    expect(customDataClick).toHaveBeenCalled()\n    expect(customLegendClick).toHaveBeenCalled()\n  })\n\n  it('disables filtering when enableFiltering is false', async () => {\n    const customDataClick = jest.fn()\n\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"bar\"\n          data={mockChartData}\n          enableFiltering={false}\n          onDataClick={customDataClick}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('data-point'))\n\n    // Custom handler should still be called\n    expect(customDataClick).toHaveBeenCalled()\n    // But no filters should be applied (we can't easily test this without exposing filter state)\n  })\n\n  it('passes through all chart props', () => {\n    render(\n      <TestWrapper>\n        <FilterableChart\n          type=\"line\"\n          data={mockChartData}\n          height={400}\n          responsive={false}\n          interactive={false}\n          exportable\n          exportFilename=\"test-chart\"\n          className=\"custom-class\"\n        />\n      </TestWrapper>\n    )\n\n    const chartWrapper = screen.getByTestId('chart-wrapper')\n    expect(chartWrapper).toHaveAttribute('type', 'line')\n    expect(chartWrapper).toHaveAttribute('height', '400')\n    expect(chartWrapper).toHaveAttribute('responsive', 'false')\n    expect(chartWrapper).toHaveAttribute('interactive', 'false')\n    expect(chartWrapper).toHaveAttribute('exportable', 'true')\n    expect(chartWrapper).toHaveAttribute('exportFilename', 'test-chart')\n    expect(chartWrapper).toHaveAttribute('className', 'custom-class')\n  })\n})\n\ndescribe('withFiltering HOC', () => {\n  const user = userEvent.setup()\n\n  // Mock component to wrap\n  const MockChart = ({ onDataClick, onLegendClick, ...props }: any) => (\n    <div data-testid=\"mock-chart\" {...props}>\n      <button\n        data-testid=\"hoc-data-point\"\n        onClick={() => onDataClick?.({\n          x: 'HOC Category',\n          y: 150,\n          value: 150,\n          label: 'HOC Category'\n        })}\n      >\n        HOC Data Point\n      </button>\n      <button\n        data-testid=\"hoc-legend-item\"\n        onClick={() => onLegendClick?.({\n          label: 'HOC Series',\n          color: '#FF6B35',\n          visible: true\n        })}\n      >\n        HOC Legend\n      </button>\n    </div>\n  )\n\n  it('wraps component with filtering functionality', async () => {\n    const FilterableMockChart = withFiltering(MockChart)\n\n    render(\n      <TestWrapper>\n        <FilterableMockChart\n          data={mockChartData}\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    expect(screen.getByTestId('mock-chart')).toBeInTheDocument()\n\n    await user.click(screen.getByTestId('hoc-data-point'))\n    // Should apply filtering (can't easily test without exposing state)\n  })\n\n  it('uses default filter mappings provided to HOC', async () => {\n    const defaultMappings = {\n      dataClick: jest.fn(() => ({\n        defaultFilter: {\n          type: 'string' as const,\n          value: 'default-value',\n          operator: 'equals' as const,\n        }\n      }))\n    }\n\n    const FilterableMockChart = withFiltering(MockChart, defaultMappings)\n\n    render(\n      <TestWrapper>\n        <FilterableMockChart\n          data={mockChartData}\n          enableFiltering\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('hoc-data-point'))\n\n    expect(defaultMappings.dataClick).toHaveBeenCalled()\n  })\n\n  it('allows overriding default mappings', async () => {\n    const defaultMappings = {\n      dataClick: jest.fn(() => ({ default: { type: 'string' as const, value: 'default', operator: 'equals' as const } }))\n    }\n\n    const overrideMappings = {\n      dataClick: jest.fn(() => ({ override: { type: 'string' as const, value: 'override', operator: 'equals' as const } }))\n    }\n\n    const FilterableMockChart = withFiltering(MockChart, defaultMappings)\n\n    render(\n      <TestWrapper>\n        <FilterableMockChart\n          data={mockChartData}\n          enableFiltering\n          filterMappings={overrideMappings}\n        />\n      </TestWrapper>\n    )\n\n    await user.click(screen.getByTestId('hoc-data-point'))\n\n    expect(overrideMappings.dataClick).toHaveBeenCalled()\n    expect(defaultMappings.dataClick).not.toHaveBeenCalled()\n  })\n\n  it('passes through all props to wrapped component', () => {\n    const FilterableMockChart = withFiltering(MockChart)\n\n    render(\n      <TestWrapper>\n        <FilterableMockChart\n          data={mockChartData}\n          customProp=\"test-value\"\n          anotherProp={123}\n        />\n      </TestWrapper>\n    )\n\n    const mockChart = screen.getByTestId('mock-chart')\n    expect(mockChart).toHaveAttribute('customProp', 'test-value')\n    expect(mockChart).toHaveAttribute('anotherProp', '123')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/dashboard-filters.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Select' is defined but never used.",
        "line": 9,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SelectContent' is defined but never used.",
        "line": 9,
        "column": 18,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SelectItem' is defined but never used.",
        "line": 9,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SelectTrigger' is defined but never used.",
        "line": 9,
        "column": 45,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SelectValue' is defined but never used.",
        "line": 9,
        "column": 60,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'FilterPreset' is defined but never used.",
        "line": 16,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useState } from 'react'\nimport { Calendar, Filter, X, RotateCcw, Bookmark, Share2 } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\nimport { Badge } from '@/components/ui/badge'\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'\nimport { Calendar as CalendarComponent } from '@/components/ui/calendar'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport { Input } from '@/components/ui/input'\nimport { Label } from '@/components/ui/label'\nimport { Separator } from '@/components/ui/separator'\nimport { useFilters } from './filter-context'\nimport { FilterPreset } from '@/types/dashboard'\nimport { cn } from '@/lib/utils'\n\ninterface DashboardFiltersProps {\n  className?: string\n  compact?: boolean\n  showPresets?: boolean\n  showShareButton?: boolean\n  availableCategories?: string[]\n  availableStatuses?: string[]\n  availablePriorities?: string[]\n  availablePlatforms?: string[]\n  availableAgents?: string[]\n}\n\nexport function DashboardFilters({\n  className,\n  compact = false,\n  showPresets = true,\n  showShareButton = true,\n  availableCategories = [],\n  availableStatuses = ['active', 'inactive', 'running', 'stopped', 'error'],\n  availablePriorities = ['low', 'medium', 'high', 'critical'],\n  availablePlatforms = ['n8n', 'make', 'zapier'],\n  availableAgents = [],\n}: DashboardFiltersProps) {\n  const {\n    filters,\n    presets,\n    setDateRange,\n    setCategories,\n    setStatus,\n    setPriority,\n    setPlatforms,\n    setAgents,\n    applyPreset,\n    savePreset,\n    clearFilters,\n    isFiltered,\n    activeFilterCount,\n  } = useFilters()\n\n  const [isDatePickerOpen, setIsDatePickerOpen] = useState(false)\n  const [isPresetDialogOpen, setIsPresetDialogOpen] = useState(false)\n  const [newPresetName, setNewPresetName] = useState('')\n  const [newPresetDescription, setNewPresetDescription] = useState('')\n\n  // Handle date range selection\n  const handleDateRangeSelect = (range: { from?: Date; to?: Date }) => {\n    if (range.from && range.to) {\n      setDateRange(range.from, range.to)\n      setIsDatePickerOpen(false)\n    }\n  }\n\n  // Handle multi-select changes\n  const handleMultiSelectChange = (\n    value: string,\n    currentValues: string[] = [],\n    onChange: (values: string[]) => void\n  ) => {\n    const newValues = currentValues.includes(value)\n      ? currentValues.filter(v => v !== value)\n      : [...currentValues, value]\n    onChange(newValues)\n  }\n\n  // Handle preset save\n  const handleSavePreset = () => {\n    if (newPresetName.trim()) {\n      savePreset(newPresetName.trim(), newPresetDescription.trim() || undefined)\n      setNewPresetName('')\n      setNewPresetDescription('')\n      setIsPresetDialogOpen(false)\n    }\n  }\n\n  // Handle share filters\n  const handleShareFilters = async () => {\n    const url = window.location.href\n    try {\n      await navigator.clipboard.writeText(url)\n      // You could add a toast notification here\n      console.log('Filter URL copied to clipboard')\n    } catch (error) {\n      console.error('Failed to copy URL:', error)\n    }\n  }\n\n  if (compact) {\n    return (\n      <div className={cn('flex items-center gap-2', className)}>\n        <Popover>\n          <PopoverTrigger asChild>\n            <Button variant=\"outline\" size=\"sm\" className=\"gap-2\">\n              <Filter className=\"h-4 w-4\" />\n              Filters\n              {activeFilterCount > 0 && (\n                <Badge variant=\"secondary\" className=\"ml-1 h-5 px-1.5 text-xs\">\n                  {activeFilterCount}\n                </Badge>\n              )}\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-80\" align=\"start\">\n            <DashboardFilters\n              compact={false}\n              showPresets={showPresets}\n              showShareButton={showShareButton}\n              availableCategories={availableCategories}\n              availableStatuses={availableStatuses}\n              availablePriorities={availablePriorities}\n              availablePlatforms={availablePlatforms}\n              availableAgents={availableAgents}\n            />\n          </PopoverContent>\n        </Popover>\n        \n        {isFiltered && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={clearFilters}\n            className=\"gap-2 text-muted-foreground hover:text-foreground\"\n          >\n            <RotateCcw className=\"h-4 w-4\" />\n            Clear\n          </Button>\n        )}\n      </div>\n    )\n  }\n\n  return (\n    <Card className={className}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"text-base font-medium\">Filters</CardTitle>\n          <div className=\"flex items-center gap-2\">\n            {showShareButton && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleShareFilters}\n                className=\"gap-2\"\n              >\n                <Share2 className=\"h-4 w-4\" />\n                Share\n              </Button>\n            )}\n            {isFiltered && (\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={clearFilters}\n                className=\"gap-2\"\n              >\n                <RotateCcw className=\"h-4 w-4\" />\n                Clear All\n              </Button>\n            )}\n          </div>\n        </div>\n      </CardHeader>\n      \n      <CardContent className=\"space-y-4\">\n        {/* Presets */}\n        {showPresets && presets.length > 0 && (\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm font-medium\">Quick Filters</Label>\n            <div className=\"flex flex-wrap gap-2\">\n              {presets.map((preset) => (\n                <Button\n                  key={preset.id}\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => applyPreset(preset)}\n                  className=\"gap-2\"\n                >\n                  <Bookmark className=\"h-3 w-3\" />\n                  {preset.name}\n                </Button>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Date Range */}\n        <div className=\"space-y-2\">\n          <Label className=\"text-sm font-medium\">Date Range</Label>\n          <Popover open={isDatePickerOpen} onOpenChange={setIsDatePickerOpen}>\n            <PopoverTrigger asChild>\n              <Button\n                variant=\"outline\"\n                className={cn(\n                  'w-full justify-start text-left font-normal',\n                  !filters.dateRange && 'text-muted-foreground'\n                )}\n              >\n                <Calendar className=\"mr-2 h-4 w-4\" />\n                {filters.dateRange\n                  ? `${filters.dateRange.start.toLocaleDateString()} - ${filters.dateRange.end.toLocaleDateString()}`\n                  : 'Select date range'\n                }\n              </Button>\n            </PopoverTrigger>\n            <PopoverContent className=\"w-auto p-0\" align=\"start\">\n              <CalendarComponent\n                mode=\"range\"\n                selected={{\n                  from: filters.dateRange?.start,\n                  to: filters.dateRange?.end,\n                }}\n                onSelect={handleDateRangeSelect}\n                numberOfMonths={2}\n              />\n            </PopoverContent>\n          </Popover>\n        </div>\n\n        {/* Categories */}\n        {availableCategories.length > 0 && (\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm font-medium\">Categories</Label>\n            <div className=\"space-y-2\">\n              {availableCategories.map((category) => (\n                <div key={category} className=\"flex items-center space-x-2\">\n                  <Checkbox\n                    id={`category-${category}`}\n                    checked={filters.categories?.includes(category) || false}\n                    onCheckedChange={() =>\n                      handleMultiSelectChange(category, filters.categories, setCategories)\n                    }\n                  />\n                  <Label\n                    htmlFor={`category-${category}`}\n                    className=\"text-sm font-normal capitalize\"\n                  >\n                    {category}\n                  </Label>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Status */}\n        <div className=\"space-y-2\">\n          <Label className=\"text-sm font-medium\">Status</Label>\n          <div className=\"space-y-2\">\n            {availableStatuses.map((status) => (\n              <div key={status} className=\"flex items-center space-x-2\">\n                <Checkbox\n                  id={`status-${status}`}\n                  checked={filters.status?.includes(status) || false}\n                  onCheckedChange={() =>\n                    handleMultiSelectChange(status, filters.status, setStatus)\n                  }\n                />\n                <Label\n                  htmlFor={`status-${status}`}\n                  className=\"text-sm font-normal capitalize\"\n                >\n                  {status}\n                </Label>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Priority */}\n        <div className=\"space-y-2\">\n          <Label className=\"text-sm font-medium\">Priority</Label>\n          <div className=\"space-y-2\">\n            {availablePriorities.map((priority) => (\n              <div key={priority} className=\"flex items-center space-x-2\">\n                <Checkbox\n                  id={`priority-${priority}`}\n                  checked={filters.priority?.includes(priority) || false}\n                  onCheckedChange={() =>\n                    handleMultiSelectChange(priority, filters.priority, setPriority)\n                  }\n                />\n                <Label\n                  htmlFor={`priority-${priority}`}\n                  className=\"text-sm font-normal capitalize\"\n                >\n                  {priority}\n                </Label>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Platforms */}\n        <div className=\"space-y-2\">\n          <Label className=\"text-sm font-medium\">Platforms</Label>\n          <div className=\"space-y-2\">\n            {availablePlatforms.map((platform) => (\n              <div key={platform} className=\"flex items-center space-x-2\">\n                <Checkbox\n                  id={`platform-${platform}`}\n                  checked={filters.platforms?.includes(platform) || false}\n                  onCheckedChange={() =>\n                    handleMultiSelectChange(platform, filters.platforms, setPlatforms)\n                  }\n                />\n                <Label\n                  htmlFor={`platform-${platform}`}\n                  className=\"text-sm font-normal capitalize\"\n                >\n                  {platform}\n                </Label>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        {/* Agents */}\n        {availableAgents.length > 0 && (\n          <div className=\"space-y-2\">\n            <Label className=\"text-sm font-medium\">Agents</Label>\n            <div className=\"space-y-2\">\n              {availableAgents.map((agent) => (\n                <div key={agent} className=\"flex items-center space-x-2\">\n                  <Checkbox\n                    id={`agent-${agent}`}\n                    checked={filters.agents?.includes(agent) || false}\n                    onCheckedChange={() =>\n                      handleMultiSelectChange(agent, filters.agents, setAgents)\n                    }\n                  />\n                  <Label\n                    htmlFor={`agent-${agent}`}\n                    className=\"text-sm font-normal\"\n                  >\n                    {agent}\n                  </Label>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Active Filters Summary */}\n        {isFiltered && (\n          <>\n            <Separator />\n            <div className=\"space-y-2\">\n              <Label className=\"text-sm font-medium\">Active Filters</Label>\n              <div className=\"flex flex-wrap gap-2\">\n                {filters.dateRange && (\n                  <Badge variant=\"secondary\" className=\"gap-1\">\n                    Date Range\n                    <X\n                      className=\"h-3 w-3 cursor-pointer\"\n                      onClick={() => setDateRange(new Date(0), new Date(0))}\n                    />\n                  </Badge>\n                )}\n                {filters.categories?.map((category) => (\n                  <Badge key={category} variant=\"secondary\" className=\"gap-1\">\n                    {category}\n                    <X\n                      className=\"h-3 w-3 cursor-pointer\"\n                      onClick={() =>\n                        setCategories(filters.categories?.filter(c => c !== category) || [])\n                      }\n                    />\n                  </Badge>\n                ))}\n                {filters.status?.map((status) => (\n                  <Badge key={status} variant=\"secondary\" className=\"gap-1\">\n                    {status}\n                    <X\n                      className=\"h-3 w-3 cursor-pointer\"\n                      onClick={() =>\n                        setStatus(filters.status?.filter(s => s !== status) || [])\n                      }\n                    />\n                  </Badge>\n                ))}\n                {filters.priority?.map((priority) => (\n                  <Badge key={priority} variant=\"secondary\" className=\"gap-1\">\n                    {priority}\n                    <X\n                      className=\"h-3 w-3 cursor-pointer\"\n                      onClick={() =>\n                        setPriority(filters.priority?.filter(p => p !== priority) || [])\n                      }\n                    />\n                  </Badge>\n                ))}\n                {filters.platforms?.map((platform) => (\n                  <Badge key={platform} variant=\"secondary\" className=\"gap-1\">\n                    {platform}\n                    <X\n                      className=\"h-3 w-3 cursor-pointer\"\n                      onClick={() =>\n                        setPlatforms(filters.platforms?.filter(p => p !== platform) || [])\n                      }\n                    />\n                  </Badge>\n                ))}\n                {filters.agents?.map((agent) => (\n                  <Badge key={agent} variant=\"secondary\" className=\"gap-1\">\n                    {agent}\n                    <X\n                      className=\"h-3 w-3 cursor-pointer\"\n                      onClick={() =>\n                        setAgents(filters.agents?.filter(a => a !== agent) || [])\n                      }\n                    />\n                  </Badge>\n                ))}\n              </div>\n            </div>\n          </>\n        )}\n\n        {/* Save Preset */}\n        {isFiltered && (\n          <>\n            <Separator />\n            <div className=\"space-y-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setIsPresetDialogOpen(true)}\n                className=\"w-full gap-2\"\n              >\n                <Bookmark className=\"h-4 w-4\" />\n                Save as Preset\n              </Button>\n            </div>\n          </>\n        )}\n      </CardContent>\n\n      {/* Save Preset Dialog */}\n      {isPresetDialogOpen && (\n        <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50\">\n          <Card className=\"w-full max-w-md\">\n            <CardHeader>\n              <CardTitle>Save Filter Preset</CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"preset-name\">Name</Label>\n                <Input\n                  id=\"preset-name\"\n                  value={newPresetName}\n                  onChange={(e) => setNewPresetName(e.target.value)}\n                  placeholder=\"Enter preset name\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"preset-description\">Description (optional)</Label>\n                <Input\n                  id=\"preset-description\"\n                  value={newPresetDescription}\n                  onChange={(e) => setNewPresetDescription(e.target.value)}\n                  placeholder=\"Enter preset description\"\n                />\n              </div>\n              <div className=\"flex justify-end gap-2\">\n                <Button\n                  variant=\"outline\"\n                  onClick={() => setIsPresetDialogOpen(false)}\n                >\n                  Cancel\n                </Button>\n                <Button onClick={handleSavePreset} disabled={!newPresetName.trim()}>\n                  Save Preset\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      )}\n    </Card>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/filter-context.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'removed' is assigned a value but never used.",
        "line": 54,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 54,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 387,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 387,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10418, 10421], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10418, 10421], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { createContext, useContext, useReducer, useEffect, useCallback } from 'react'\nimport { useRouter, useSearchParams } from 'next/navigation'\nimport { FilterState, FilterValue, FilterPreset, FilterConfiguration } from '@/types/dashboard'\n\n// Filter Actions\ntype FilterAction =\n  | { type: 'SET_FILTER'; key: string; value: FilterValue }\n  | { type: 'REMOVE_FILTER'; key: string }\n  | { type: 'CLEAR_FILTERS' }\n  | { type: 'SET_DATE_RANGE'; start: Date; end: Date }\n  | { type: 'SET_CATEGORIES'; categories: string[] }\n  | { type: 'SET_STATUS'; status: string[] }\n  | { type: 'SET_PRIORITY'; priority: string[] }\n  | { type: 'SET_PLATFORMS'; platforms: string[] }\n  | { type: 'SET_AGENTS'; agents: string[] }\n  | { type: 'APPLY_PRESET'; preset: FilterPreset }\n  | { type: 'LOAD_FROM_URL'; filters: FilterState }\n\n// Filter Context Interface\ninterface FilterContextValue {\n  filters: FilterState\n  configuration: FilterConfiguration\n  presets: FilterPreset[]\n  setFilter: (key: string, value: FilterValue) => void\n  removeFilter: (key: string) => void\n  clearFilters: () => void\n  setDateRange: (start: Date, end: Date) => void\n  setCategories: (categories: string[]) => void\n  setStatus: (status: string[]) => void\n  setPriority: (priority: string[]) => void\n  setPlatforms: (platforms: string[]) => void\n  setAgents: (agents: string[]) => void\n  applyPreset: (preset: FilterPreset) => void\n  savePreset: (name: string, description?: string) => void\n  deletePreset: (presetId: string) => void\n  isFiltered: boolean\n  activeFilterCount: number\n}\n\n// Filter Reducer\nfunction filterReducer(state: FilterState, action: FilterAction): FilterState {\n  switch (action.type) {\n    case 'SET_FILTER':\n      return {\n        ...state,\n        customFilters: {\n          ...state.customFilters,\n          [action.key]: action.value,\n        },\n      }\n    case 'REMOVE_FILTER':\n      const { [action.key]: removed, ...remainingFilters } = state.customFilters || {}\n      return {\n        ...state,\n        customFilters: remainingFilters,\n      }\n    case 'CLEAR_FILTERS':\n      return {}\n    case 'SET_DATE_RANGE':\n      return {\n        ...state,\n        dateRange: {\n          start: action.start,\n          end: action.end,\n        },\n      }\n    case 'SET_CATEGORIES':\n      return {\n        ...state,\n        categories: action.categories,\n      }\n    case 'SET_STATUS':\n      return {\n        ...state,\n        status: action.status,\n      }\n    case 'SET_PRIORITY':\n      return {\n        ...state,\n        priority: action.priority,\n      }\n    case 'SET_PLATFORMS':\n      return {\n        ...state,\n        platforms: action.platforms,\n      }\n    case 'SET_AGENTS':\n      return {\n        ...state,\n        agents: action.agents,\n      }\n    case 'APPLY_PRESET':\n      return action.preset.filters\n    case 'LOAD_FROM_URL':\n      return action.filters\n    default:\n      return state\n  }\n}\n\n// Create Context\nconst FilterContext = createContext<FilterContextValue | undefined>(undefined)\n\n// Default Configuration\nconst defaultConfiguration: FilterConfiguration = {\n  enabled: true,\n  persistent: true,\n  shareable: true,\n  presets: [],\n}\n\n// Default Presets\nconst defaultPresets: FilterPreset[] = [\n  {\n    id: 'last-7-days',\n    name: 'Last 7 Days',\n    description: 'Show data from the last 7 days',\n    filters: {\n      dateRange: {\n        start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n        end: new Date(),\n      },\n    },\n  },\n  {\n    id: 'last-30-days',\n    name: 'Last 30 Days',\n    description: 'Show data from the last 30 days',\n    filters: {\n      dateRange: {\n        start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),\n        end: new Date(),\n      },\n    },\n  },\n  {\n    id: 'high-priority',\n    name: 'High Priority',\n    description: 'Show only high and critical priority items',\n    filters: {\n      priority: ['high', 'critical'],\n    },\n  },\n  {\n    id: 'active-agents',\n    name: 'Active Agents',\n    description: 'Show only active agents and tasks',\n    filters: {\n      status: ['active', 'running'],\n    },\n  },\n]\n\n// Provider Props\ninterface FilterProviderProps {\n  children: React.ReactNode\n  configuration?: Partial<FilterConfiguration>\n  initialFilters?: FilterState\n  storageKey?: string\n  enableUrlSync?: boolean\n}\n\n// Utility Functions\nfunction serializeFilters(filters: FilterState): string {\n  const serializable = {\n    ...filters,\n    dateRange: filters.dateRange\n      ? {\n          start: filters.dateRange.start.toISOString(),\n          end: filters.dateRange.end.toISOString(),\n        }\n      : undefined,\n  }\n  return JSON.stringify(serializable)\n}\n\nfunction deserializeFilters(serialized: string): FilterState {\n  try {\n    const parsed = JSON.parse(serialized)\n    return {\n      ...parsed,\n      dateRange: parsed.dateRange\n        ? {\n            start: new Date(parsed.dateRange.start),\n            end: new Date(parsed.dateRange.end),\n          }\n        : undefined,\n    }\n  } catch {\n    return {}\n  }\n}\n\nfunction countActiveFilters(filters: FilterState): number {\n  let count = 0\n  if (filters.dateRange) count++\n  if (filters.categories?.length) count++\n  if (filters.status?.length) count++\n  if (filters.priority?.length) count++\n  if (filters.platforms?.length) count++\n  if (filters.agents?.length) count++\n  if (filters.customFilters) {\n    count += Object.keys(filters.customFilters).length\n  }\n  return count\n}\n\n// Filter Provider Component\nexport function FilterProvider({\n  children,\n  configuration = {},\n  initialFilters = {},\n  storageKey = 'dashboard-filters',\n  enableUrlSync = true,\n}: FilterProviderProps) {\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  \n  // Merge configuration with defaults\n  const config: FilterConfiguration = {\n    ...defaultConfiguration,\n    ...configuration,\n    presets: [...defaultPresets, ...(configuration.presets || [])],\n  }\n\n  // Initialize state\n  const [filters, dispatch] = useReducer(filterReducer, initialFilters)\n  const [presets, setPresets] = React.useState<FilterPreset[]>(config.presets || [])\n\n  // Load filters from localStorage on mount\n  useEffect(() => {\n    if (!config.persistent) return\n\n    try {\n      const stored = localStorage.getItem(storageKey)\n      if (stored) {\n        const storedFilters = deserializeFilters(stored)\n        dispatch({ type: 'LOAD_FROM_URL', filters: storedFilters })\n      }\n    } catch (error) {\n      console.warn('Failed to load filters from localStorage:', error)\n    }\n  }, [storageKey, config.persistent])\n\n  // Load filters from URL on mount\n  useEffect(() => {\n    if (!enableUrlSync) return\n\n    const filtersParam = searchParams.get('filters')\n    if (filtersParam) {\n      try {\n        const urlFilters = deserializeFilters(decodeURIComponent(filtersParam))\n        dispatch({ type: 'LOAD_FROM_URL', filters: urlFilters })\n      } catch (error) {\n        console.warn('Failed to load filters from URL:', error)\n      }\n    }\n  }, [searchParams, enableUrlSync])\n\n  // Save filters to localStorage when they change\n  useEffect(() => {\n    if (!config.persistent) return\n\n    try {\n      const serialized = serializeFilters(filters)\n      localStorage.setItem(storageKey, serialized)\n    } catch (error) {\n      console.warn('Failed to save filters to localStorage:', error)\n    }\n  }, [filters, storageKey, config.persistent])\n\n  // Update URL when filters change\n  useEffect(() => {\n    if (!enableUrlSync) return\n\n    const serialized = serializeFilters(filters)\n    const currentParams = new URLSearchParams(searchParams.toString())\n    \n    if (Object.keys(filters).length === 0) {\n      currentParams.delete('filters')\n    } else {\n      currentParams.set('filters', encodeURIComponent(serialized))\n    }\n\n    const newUrl = `${window.location.pathname}?${currentParams.toString()}`\n    router.replace(newUrl, { scroll: false })\n  }, [filters, router, searchParams, enableUrlSync])\n\n  // Context Methods\n  const setFilter = useCallback((key: string, value: FilterValue) => {\n    dispatch({ type: 'SET_FILTER', key, value })\n  }, [])\n\n  const removeFilter = useCallback((key: string) => {\n    dispatch({ type: 'REMOVE_FILTER', key })\n  }, [])\n\n  const clearFilters = useCallback(() => {\n    dispatch({ type: 'CLEAR_FILTERS' })\n  }, [])\n\n  const setDateRange = useCallback((start: Date, end: Date) => {\n    dispatch({ type: 'SET_DATE_RANGE', start, end })\n  }, [])\n\n  const setCategories = useCallback((categories: string[]) => {\n    dispatch({ type: 'SET_CATEGORIES', categories })\n  }, [])\n\n  const setStatus = useCallback((status: string[]) => {\n    dispatch({ type: 'SET_STATUS', status })\n  }, [])\n\n  const setPriority = useCallback((priority: string[]) => {\n    dispatch({ type: 'SET_PRIORITY', priority })\n  }, [])\n\n  const setPlatforms = useCallback((platforms: string[]) => {\n    dispatch({ type: 'SET_PLATFORMS', platforms })\n  }, [])\n\n  const setAgents = useCallback((agents: string[]) => {\n    dispatch({ type: 'SET_AGENTS', agents })\n  }, [])\n\n  const applyPreset = useCallback((preset: FilterPreset) => {\n    dispatch({ type: 'APPLY_PRESET', preset })\n  }, [])\n\n  const savePreset = useCallback((name: string, description?: string) => {\n    const newPreset: FilterPreset = {\n      id: `custom-${Date.now()}`,\n      name,\n      description,\n      filters: { ...filters },\n    }\n    setPresets(prev => [...prev, newPreset])\n  }, [filters])\n\n  const deletePreset = useCallback((presetId: string) => {\n    setPresets(prev => prev.filter(preset => preset.id !== presetId))\n  }, [])\n\n  // Computed Values\n  const isFiltered = countActiveFilters(filters) > 0\n  const activeFilterCount = countActiveFilters(filters)\n\n  const contextValue: FilterContextValue = {\n    filters,\n    configuration: config,\n    presets,\n    setFilter,\n    removeFilter,\n    clearFilters,\n    setDateRange,\n    setCategories,\n    setStatus,\n    setPriority,\n    setPlatforms,\n    setAgents,\n    applyPreset,\n    savePreset,\n    deletePreset,\n    isFiltered,\n    activeFilterCount,\n  }\n\n  return (\n    <FilterContext.Provider value={contextValue}>\n      {children}\n    </FilterContext.Provider>\n  )\n}\n\n// Hook to use filter context\nexport function useFilters() {\n  const context = useContext(FilterContext)\n  if (context === undefined) {\n    throw new Error('useFilters must be used within a FilterProvider')\n  }\n  return context\n}\n\n// Hook to use specific filter values\nexport function useFilterValue<T = any>(key: string): T | undefined {\n  const { filters } = useFilters()\n  return filters.customFilters?.[key]?.value as T\n}\n\n// Hook to check if a specific filter is active\nexport function useIsFilterActive(key: string): boolean {\n  const { filters } = useFilters()\n  return key in (filters.customFilters || {})\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/filter-controls.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 171,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 171,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6845, 6848], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6845, 6848], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 189,
        "column": 82,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 189,
        "endColumn": 85,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7843, 7846], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7843, 7846], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 257,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 257,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10390, 10393], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10390, 10393], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useState } from 'react'\nimport { Search, SlidersHorizontal, X, Plus } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\nimport { Input } from '@/components/ui/input'\nimport { Label } from '@/components/ui/label'\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'\nimport { Badge } from '@/components/ui/badge'\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'\nimport { useFilters } from './filter-context'\nimport { FilterValue } from '@/types/dashboard'\nimport { cn } from '@/lib/utils'\n\ninterface FilterControlsProps {\n  className?: string\n  searchPlaceholder?: string\n  showAdvancedFilters?: boolean\n  customFilterOptions?: Array<{\n    key: string\n    label: string\n    type: 'string' | 'number' | 'select'\n    options?: string[]\n  }>\n}\n\nexport function FilterControls({\n  className,\n  searchPlaceholder = 'Search...',\n  showAdvancedFilters = true,\n  customFilterOptions = [],\n}: FilterControlsProps) {\n  const { filters, setFilter, removeFilter, clearFilters, isFiltered } = useFilters()\n  const [searchValue, setSearchValue] = useState('')\n  const [isAdvancedOpen, setIsAdvancedOpen] = useState(false)\n  const [newFilterKey, setNewFilterKey] = useState('')\n  const [newFilterValue, setNewFilterValue] = useState('')\n  const [newFilterType, setNewFilterType] = useState<'string' | 'number' | 'boolean'>('string')\n  const [newFilterOperator, setNewFilterOperator] = useState<'equals' | 'contains' | 'greaterThan' | 'lessThan'>('contains')\n\n  // Handle search\n  const handleSearchChange = (value: string) => {\n    setSearchValue(value)\n    if (value.trim()) {\n      setFilter('search', {\n        type: 'string',\n        value: value.trim(),\n        operator: 'contains',\n      })\n    } else {\n      removeFilter('search')\n    }\n  }\n\n  // Handle adding custom filter\n  const handleAddCustomFilter = () => {\n    if (!newFilterKey.trim() || !newFilterValue.trim()) return\n\n    const filterValue: FilterValue = {\n      type: newFilterType,\n      value: newFilterType === 'number' ? Number(newFilterValue) : newFilterValue,\n      operator: newFilterOperator,\n    }\n\n    setFilter(newFilterKey.trim(), filterValue)\n    setNewFilterKey('')\n    setNewFilterValue('')\n    setIsAdvancedOpen(false)\n  }\n\n  // Handle predefined custom filter\n  const handleCustomFilterChange = (key: string, value: string, type: 'string' | 'number' | 'select') => {\n    if (value) {\n      const filterValue: FilterValue = {\n        type,\n        value: type === 'number' ? Number(value) : value,\n        operator: type === 'number' ? 'equals' : 'contains',\n      }\n      setFilter(key, filterValue)\n    } else {\n      removeFilter(key)\n    }\n  }\n\n  return (\n    <div className={cn('space-y-4', className)}>\n      {/* Search Bar */}\n      <div className=\"relative\">\n        <Search className=\"absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground\" />\n        <Input\n          placeholder={searchPlaceholder}\n          value={searchValue}\n          onChange={(e) => handleSearchChange(e.target.value)}\n          className=\"pl-9 pr-9\"\n        />\n        {searchValue && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={() => handleSearchChange('')}\n            className=\"absolute right-1 top-1/2 h-7 w-7 -translate-y-1/2 p-0\"\n          >\n            <X className=\"h-4 w-4\" />\n          </Button>\n        )}\n      </div>\n\n      {/* Quick Actions */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          {showAdvancedFilters && (\n            <Popover open={isAdvancedOpen} onOpenChange={setIsAdvancedOpen}>\n              <PopoverTrigger asChild>\n                <Button variant=\"outline\" size=\"sm\" className=\"gap-2\">\n                  <SlidersHorizontal className=\"h-4 w-4\" />\n                  Advanced\n                </Button>\n              </PopoverTrigger>\n              <PopoverContent className=\"w-80\" align=\"start\">\n                <Card className=\"border-0 shadow-none\">\n                  <CardHeader className=\"pb-3\">\n                    <CardTitle className=\"text-base\">Advanced Filters</CardTitle>\n                  </CardHeader>\n                  <CardContent className=\"space-y-4\">\n                    {/* Predefined Custom Filters */}\n                    {customFilterOptions.map((option) => (\n                      <div key={option.key} className=\"space-y-2\">\n                        <Label className=\"text-sm font-medium\">{option.label}</Label>\n                        {option.type === 'select' && option.options ? (\n                          <Select\n                            value={filters.customFilters?.[option.key]?.value || ''}\n                            onValueChange={(value) =>\n                              handleCustomFilterChange(option.key, value, option.type)\n                            }\n                          >\n                            <SelectTrigger>\n                              <SelectValue placeholder={`Select ${option.label.toLowerCase()}`} />\n                            </SelectTrigger>\n                            <SelectContent>\n                              <SelectItem value=\"\">All</SelectItem>\n                              {option.options.map((opt) => (\n                                <SelectItem key={opt} value={opt}>\n                                  {opt}\n                                </SelectItem>\n                              ))}\n                            </SelectContent>\n                          </Select>\n                        ) : (\n                          <Input\n                            type={option.type === 'number' ? 'number' : 'text'}\n                            placeholder={`Enter ${option.label.toLowerCase()}`}\n                            value={filters.customFilters?.[option.key]?.value || ''}\n                            onChange={(e) =>\n                              handleCustomFilterChange(option.key, e.target.value, option.type)\n                            }\n                          />\n                        )}\n                      </div>\n                    ))}\n\n                    {/* Custom Filter Builder */}\n                    <div className=\"space-y-3 border-t pt-4\">\n                      <Label className=\"text-sm font-medium\">Add Custom Filter</Label>\n                      <div className=\"grid grid-cols-2 gap-2\">\n                        <Input\n                          placeholder=\"Filter name\"\n                          value={newFilterKey}\n                          onChange={(e) => setNewFilterKey(e.target.value)}\n                        />\n                        <Select value={newFilterType} onValueChange={(value: any) => setNewFilterType(value)}>\n                          <SelectTrigger>\n                            <SelectValue />\n                          </SelectTrigger>\n                          <SelectContent>\n                            <SelectItem value=\"string\">Text</SelectItem>\n                            <SelectItem value=\"number\">Number</SelectItem>\n                            <SelectItem value=\"boolean\">Boolean</SelectItem>\n                          </SelectContent>\n                        </Select>\n                      </div>\n                      <div className=\"grid grid-cols-2 gap-2\">\n                        <Input\n                          placeholder=\"Filter value\"\n                          type={newFilterType === 'number' ? 'number' : 'text'}\n                          value={newFilterValue}\n                          onChange={(e) => setNewFilterValue(e.target.value)}\n                        />\n                        <Select value={newFilterOperator} onValueChange={(value: any) => setNewFilterOperator(value)}>\n                          <SelectTrigger>\n                            <SelectValue />\n                          </SelectTrigger>\n                          <SelectContent>\n                            <SelectItem value=\"equals\">Equals</SelectItem>\n                            <SelectItem value=\"contains\">Contains</SelectItem>\n                            {newFilterType === 'number' && (\n                              <>\n                                <SelectItem value=\"greaterThan\">Greater Than</SelectItem>\n                                <SelectItem value=\"lessThan\">Less Than</SelectItem>\n                              </>\n                            )}\n                          </SelectContent>\n                        </Select>\n                      </div>\n                      <Button\n                        onClick={handleAddCustomFilter}\n                        disabled={!newFilterKey.trim() || !newFilterValue.trim()}\n                        className=\"w-full gap-2\"\n                        size=\"sm\"\n                      >\n                        <Plus className=\"h-4 w-4\" />\n                        Add Filter\n                      </Button>\n                    </div>\n                  </CardContent>\n                </Card>\n              </PopoverContent>\n            </Popover>\n          )}\n        </div>\n\n        {isFiltered && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={clearFilters}\n            className=\"gap-2 text-muted-foreground hover:text-foreground\"\n          >\n            <X className=\"h-4 w-4\" />\n            Clear All\n          </Button>\n        )}\n      </div>\n\n      {/* Active Custom Filters */}\n      {filters.customFilters && Object.keys(filters.customFilters).length > 0 && (\n        <div className=\"space-y-2\">\n          <Label className=\"text-sm font-medium text-muted-foreground\">Active Filters</Label>\n          <div className=\"flex flex-wrap gap-2\">\n            {Object.entries(filters.customFilters).map(([key, filter]) => (\n              <Badge key={key} variant=\"secondary\" className=\"gap-1\">\n                {key}: {String(filter.value)}\n                <X\n                  className=\"h-3 w-3 cursor-pointer hover:text-destructive\"\n                  onClick={() => removeFilter(key)}\n                />\n              </Badge>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n\n// Hook for filtering data based on current filters\nexport function useFilteredData<T extends Record<string, any>>(\n  data: T[],\n  searchFields: (keyof T)[] = []\n): T[] {\n  const { filters } = useFilters()\n\n  return React.useMemo(() => {\n    if (!data) return []\n\n    return data.filter((item) => {\n      // Search filter\n      if (filters.customFilters?.search) {\n        const searchValue = filters.customFilters.search.value.toLowerCase()\n        const matchesSearch = searchFields.some((field) => {\n          const fieldValue = String(item[field] || '').toLowerCase()\n          return fieldValue.includes(searchValue)\n        })\n        if (!matchesSearch) return false\n      }\n\n      // Date range filter\n      if (filters.dateRange && item.createdAt) {\n        const itemDate = new Date(item.createdAt)\n        if (itemDate < filters.dateRange.start || itemDate > filters.dateRange.end) {\n          return false\n        }\n      }\n\n      // Category filter\n      if (filters.categories?.length && item.category) {\n        if (!filters.categories.includes(item.category)) return false\n      }\n\n      // Status filter\n      if (filters.status?.length && item.status) {\n        if (!filters.status.includes(item.status)) return false\n      }\n\n      // Priority filter\n      if (filters.priority?.length && item.priority) {\n        if (!filters.priority.includes(item.priority)) return false\n      }\n\n      // Platform filter\n      if (filters.platforms?.length && item.platform) {\n        if (!filters.platforms.includes(item.platform)) return false\n      }\n\n      // Agent filter\n      if (filters.agents?.length && item.agent) {\n        if (!filters.agents.includes(item.agent)) return false\n      }\n\n      // Custom filters\n      if (filters.customFilters) {\n        for (const [key, filter] of Object.entries(filters.customFilters)) {\n          if (key === 'search') continue // Already handled above\n\n          const itemValue = item[key]\n          if (itemValue === undefined || itemValue === null) continue\n\n          switch (filter.operator) {\n            case 'equals':\n              if (itemValue !== filter.value) return false\n              break\n            case 'contains':\n              if (!String(itemValue).toLowerCase().includes(String(filter.value).toLowerCase())) {\n                return false\n              }\n              break\n            case 'greaterThan':\n              if (Number(itemValue) <= Number(filter.value)) return false\n              break\n            case 'lessThan':\n              if (Number(itemValue) >= Number(filter.value)) return false\n              break\n          }\n        }\n      }\n\n      return true\n    })\n  }, [data, filters, searchFields])\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/filter-synchronizer.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'syncAcrossCards' is assigned a value but never used.",
        "line": 20,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 20,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'syncAcrossCharts' is assigned a value but never used.",
        "line": 21,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 21,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 143,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 143,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4266, 4269], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4266, 4269], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 233,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 233,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7397, 7400], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7397, 7400], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'searchFields' is assigned a value but never used.",
        "line": 248,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 248,
        "endColumn": 17
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook React.useMemo has a missing dependency: 'filters'. Either include it or remove the dependency array.",
        "line": 306,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 306,
        "endColumn": 80,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [data, filters, customLogic, enabledFilters, filterMappings]",
            "fix": {
              "range": [9790, 9864],
              "text": "[data, filters, customLogic, enabledFilters, filterMappings]"
            }
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.",
        "line": 139,
        "column": 16,
        "nodeType": "SpreadElement",
        "endLine": 139,
        "endColumn": 31,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useEffect, useCallback, useRef } from 'react'\nimport { useFilters } from './filter-context'\nimport type { FilterState, FilterValue } from '@/types/dashboard'\n\ninterface FilterSynchronizerProps {\n  children: React.ReactNode\n  // Synchronization options\n  syncAcrossCards?: boolean\n  syncAcrossCharts?: boolean\n  syncDelay?: number // Debounce delay in ms\n  onFilterChange?: (filters: FilterState) => void\n  onFilterApplied?: (key: string, value: FilterValue) => void\n  onFilterRemoved?: (key: string) => void\n}\n\nexport function FilterSynchronizer({\n  children,\n  syncAcrossCards = true,\n  syncAcrossCharts = true,\n  syncDelay = 300,\n  onFilterChange,\n  onFilterApplied,\n  onFilterRemoved,\n}: FilterSynchronizerProps) {\n  const { filters } = useFilters()\n  const previousFiltersRef = useRef<FilterState>({})\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined)\n\n  // Debounced filter change handler\n  const debouncedFilterChange = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current)\n    }\n\n    timeoutRef.current = setTimeout(() => {\n      onFilterChange?.(filters)\n    }, syncDelay)\n  }, [filters, syncDelay, onFilterChange])\n\n  // Track filter changes and call appropriate callbacks\n  useEffect(() => {\n    const previousFilters = previousFiltersRef.current\n    const currentFilters = filters\n\n    // Check for added/changed filters\n    if (currentFilters.customFilters) {\n      Object.entries(currentFilters.customFilters).forEach(([key, value]) => {\n        const previousValue = previousFilters.customFilters?.[key]\n        if (!previousValue || JSON.stringify(previousValue) !== JSON.stringify(value)) {\n          onFilterApplied?.(key, value)\n        }\n      })\n    }\n\n    // Check for removed filters\n    if (previousFilters.customFilters) {\n      Object.keys(previousFilters.customFilters).forEach((key) => {\n        if (!currentFilters.customFilters?.[key]) {\n          onFilterRemoved?.(key)\n        }\n      })\n    }\n\n    // Check for other filter changes\n    const filterKeys: (keyof FilterState)[] = [\n      'dateRange',\n      'categories',\n      'status',\n      'priority',\n      'platforms',\n      'agents',\n    ]\n\n    filterKeys.forEach((key) => {\n      const currentValue = currentFilters[key]\n      const previousValue = previousFilters[key]\n      \n      if (JSON.stringify(currentValue) !== JSON.stringify(previousValue)) {\n        if (currentValue && key !== 'dateRange') {\n          // For array filters, create a filter value\n          const filterValue: FilterValue = {\n            type: 'array',\n            value: currentValue,\n            operator: 'equals',\n          }\n          onFilterApplied?.(key, filterValue)\n        } else if (currentValue && key === 'dateRange') {\n          // For date range, create a special filter value\n          const filterValue: FilterValue = {\n            type: 'date',\n            value: currentValue,\n            operator: 'between',\n          }\n          onFilterApplied?.(key, filterValue)\n        } else if (!currentValue && previousValue) {\n          onFilterRemoved?.(key)\n        }\n      }\n    })\n\n    // Update previous filters reference\n    previousFiltersRef.current = { ...currentFilters }\n\n    // Call debounced change handler\n    debouncedFilterChange()\n  }, [filters, onFilterApplied, onFilterRemoved, debouncedFilterChange])\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n    }\n  }, [])\n\n  return <>{children}</>\n}\n\n// Hook for components to react to filter changes\nexport function useFilterSync(\n  callback: (filters: FilterState) => void,\n  dependencies: React.DependencyList = []\n) {\n  const { filters } = useFilters()\n  const callbackRef = useRef(callback)\n\n  // Update callback ref when callback changes\n  useEffect(() => {\n    callbackRef.current = callback\n  }, [callback])\n\n  // Call callback when filters change\n  useEffect(() => {\n    callbackRef.current(filters)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filters, ...dependencies])\n}\n\n// Hook for components to get filtered data that updates automatically\nexport function useSyncedFilteredData<T extends Record<string, any>>(\n  data: T[],\n  searchFields: (keyof T)[] = [],\n  customFilterLogic?: (item: T, filters: FilterState) => boolean\n): T[] {\n  const { filters } = useFilters()\n\n  return React.useMemo(() => {\n    if (!data) return []\n\n    return data.filter((item) => {\n      // Custom filter logic takes precedence\n      if (customFilterLogic) {\n        return customFilterLogic(item, filters)\n      }\n\n      // Search filter\n      if (filters.customFilters?.search) {\n        const searchValue = filters.customFilters.search.value.toLowerCase()\n        const matchesSearch = searchFields.some((field) => {\n          const fieldValue = String(item[field] || '').toLowerCase()\n          return fieldValue.includes(searchValue)\n        })\n        if (!matchesSearch) return false\n      }\n\n      // Date range filter\n      if (filters.dateRange && item.createdAt) {\n        const itemDate = new Date(item.createdAt)\n        if (itemDate < filters.dateRange.start || itemDate > filters.dateRange.end) {\n          return false\n        }\n      }\n\n      // Array-based filters\n      const arrayFilters: Array<{ key: keyof FilterState; itemKey: keyof T }> = [\n        { key: 'categories', itemKey: 'category' },\n        { key: 'status', itemKey: 'status' },\n        { key: 'priority', itemKey: 'priority' },\n        { key: 'platforms', itemKey: 'platform' },\n        { key: 'agents', itemKey: 'agent' },\n      ]\n\n      for (const { key, itemKey } of arrayFilters) {\n        const filterValues = filters[key] as string[] | undefined\n        if (filterValues?.length && item[itemKey]) {\n          if (!filterValues.includes(String(item[itemKey]))) return false\n        }\n      }\n\n      // Custom filters\n      if (filters.customFilters) {\n        for (const [key, filter] of Object.entries(filters.customFilters)) {\n          if (key === 'search') continue // Already handled above\n\n          const itemValue = item[key as keyof T]\n          if (itemValue === undefined || itemValue === null) continue\n\n          switch (filter.operator) {\n            case 'equals':\n              if (itemValue !== filter.value) return false\n              break\n            case 'contains':\n              if (!String(itemValue).toLowerCase().includes(String(filter.value).toLowerCase())) {\n                return false\n              }\n              break\n            case 'greaterThan':\n              if (Number(itemValue) <= Number(filter.value)) return false\n              break\n            case 'lessThan':\n              if (Number(itemValue) >= Number(filter.value)) return false\n              break\n            case 'between':\n              if (Array.isArray(filter.value) && filter.value.length === 2) {\n                const [min, max] = filter.value\n                const numValue = Number(itemValue)\n                if (numValue < Number(min) || numValue > Number(max)) return false\n              }\n              break\n          }\n        }\n      }\n\n      return true\n    })\n  }, [data, filters, searchFields, customFilterLogic])\n}\n\n// Hook for cross-card data filtering with enhanced capabilities\nexport function useCrossCardFiltering<T extends Record<string, any>>(\n  data: T[],\n  options: {\n    searchFields?: (keyof T)[]\n    filterMappings?: Record<string, (item: T, filterValue: FilterValue) => boolean>\n    enabledFilters?: string[]\n    customLogic?: (item: T, filters: FilterState) => boolean\n  } = {}\n): {\n  filteredData: T[]\n  activeFilters: Record<string, FilterValue>\n  filterCount: number\n} {\n  const { filters } = useFilters()\n  const {\n    searchFields = [],\n    filterMappings = {},\n    enabledFilters,\n    customLogic,\n  } = options\n\n  const result = React.useMemo(() => {\n    if (!data) return { filteredData: [], activeFilters: {}, filterCount: 0 }\n\n    const activeFilters = filters.customFilters || {}\n    const filterCount = Object.keys(activeFilters).length\n\n    // Filter data based on active filters\n    const filteredData = data.filter(item => {\n      // Custom logic takes precedence\n      if (customLogic) {\n        return customLogic(item, filters)\n      }\n\n      // Check each active filter\n      return Object.entries(activeFilters).every(([filterKey, filterValue]) => {\n        // Skip if this filter is not enabled\n        if (enabledFilters && !enabledFilters.includes(filterKey)) {\n          return true\n        }\n\n        // Use custom mapping if provided\n        if (filterMappings[filterKey]) {\n          return filterMappings[filterKey](item, filterValue)\n        }\n\n        // Default filtering logic\n        const itemValue = item[filterKey as keyof T]\n        \n        if (itemValue === undefined || itemValue === null) return true\n\n        switch (filterValue.operator) {\n          case 'equals':\n            return itemValue === filterValue.value\n          case 'contains':\n            return String(itemValue).toLowerCase().includes(String(filterValue.value).toLowerCase())\n          case 'greaterThan':\n            return Number(itemValue) > Number(filterValue.value)\n          case 'lessThan':\n            return Number(itemValue) < Number(filterValue.value)\n          case 'between':\n            if (Array.isArray(filterValue.value) && filterValue.value.length === 2) {\n              const [min, max] = filterValue.value\n              return Number(itemValue) >= Number(min) && Number(itemValue) <= Number(max)\n            }\n            return true\n          default:\n            return itemValue === filterValue.value\n        }\n      })\n    })\n\n    return { filteredData, activeFilters, filterCount }\n  }, [data, filters.customFilters, filterMappings, enabledFilters, customLogic])\n\n  return result\n}\n\n// Component for visual filter state indicators\nexport function FilterStateIndicator({\n  filterKey,\n  className,\n}: {\n  filterKey: string\n  className?: string\n}) {\n  const { filters, removeFilter } = useFilters()\n  const filterValue = filters.customFilters?.[filterKey]\n\n  if (!filterValue) return null\n\n  return (\n    <div className={`inline-flex items-center gap-1 px-2 py-1 bg-primary/10 text-primary text-xs rounded-full ${className}`}>\n      <span>{filterKey}: {String(filterValue.value)}</span>\n      <button\n        onClick={() => removeFilter(filterKey)}\n        className=\"hover:bg-primary/20 rounded-full p-0.5\"\n        aria-label={`Remove ${filterKey} filter`}\n      >\n        \n      </button>\n    </div>\n  )\n}\n\n// Component for displaying all active filters\nexport function ActiveFiltersDisplay({\n  className,\n  showClearAll = true,\n}: {\n  className?: string\n  showClearAll?: boolean\n}) {\n  const { filters, clearFilters } = useFilters()\n  const activeFilters = filters.customFilters || {}\n\n  if (Object.keys(activeFilters).length === 0) return null\n\n  return (\n    <div className={`flex flex-wrap items-center gap-2 ${className}`}>\n      <span className=\"text-sm text-muted-foreground\">Active filters:</span>\n      {Object.keys(activeFilters).map(key => (\n        <FilterStateIndicator key={key} filterKey={key} />\n      ))}\n      {showClearAll && (\n        <button\n          onClick={clearFilters}\n          className=\"text-xs text-muted-foreground hover:text-foreground underline\"\n        >\n          Clear all\n        </button>\n      )}\n    </div>\n  )\n}\n\n// Component for debugging filter state\nexport function FilterDebugger({ enabled = false }: { enabled?: boolean }) {\n  const { filters, isFiltered, activeFilterCount } = useFilters()\n\n  if (!enabled) return null\n\n  return (\n    <div className=\"fixed bottom-4 right-4 bg-background border border-border rounded-lg p-4 shadow-lg max-w-sm z-50\">\n      <h3 className=\"font-semibold text-sm mb-2\">Filter Debug</h3>\n      <div className=\"space-y-1 text-xs\">\n        <div>Active: {isFiltered ? 'Yes' : 'No'}</div>\n        <div>Count: {activeFilterCount}</div>\n        <details className=\"mt-2\">\n          <summary className=\"cursor-pointer font-medium\">Filter State</summary>\n          <pre className=\"mt-1 text-xs bg-muted p-2 rounded overflow-auto max-h-40\">\n            {JSON.stringify(filters, null, 2)}\n          </pre>\n        </details>\n      </div>\n    </div>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/filterable-card.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [498, 501], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [498, 501], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useCallback } from 'react'\nimport { DashboardCard } from '../cards/dashboard-card'\nimport { useFilters } from './filter-context'\nimport type { DashboardCardProps, FilterValue } from '@/types/dashboard'\n\ninterface FilterableCardProps extends DashboardCardProps {\n  // Filtering props\n  enableFiltering?: boolean\n  filterMappings?: {\n    cardClick?: () => Record<string, FilterValue>\n    metricClick?: () => Record<string, FilterValue>\n  }\n  filterData?: Record<string, any> // Data to use for filtering\n}\n\nexport function FilterableCard({\n  enableFiltering = true,\n  filterMappings,\n  filterData,\n  onClick,\n  onFilter,\n  ...cardProps\n}: FilterableCardProps) {\n  const { setFilter, removeFilter, filters } = useFilters()\n\n  // Handle card clicks with filtering\n  const handleCardClick = useCallback(() => {\n    // Call custom handler first\n    onClick?.()\n\n    if (!enableFiltering) return\n\n    // Apply default or custom filter mapping\n    let filtersToApply: Record<string, FilterValue> = {}\n\n    if (filterMappings?.cardClick) {\n      filtersToApply = filterMappings.cardClick()\n    } else if (filterData) {\n      // Default mapping: use filterData to create filters\n      Object.entries(filterData).forEach(([key, value]) => {\n        if (value !== null && value !== undefined) {\n          filtersToApply[key] = {\n            type: typeof value === 'number' ? 'number' : 'string',\n            value,\n            operator: 'equals',\n          }\n        }\n      })\n    } else if (cardProps.title) {\n      // Fallback: filter by card title\n      filtersToApply.cardTitle = {\n        type: 'string',\n        value: cardProps.title,\n        operator: 'equals',\n      }\n    }\n\n    // Apply filters\n    Object.entries(filtersToApply).forEach(([key, filterValue]) => {\n      // Toggle filter if it's already active with the same value\n      const existingFilter = filters.customFilters?.[key]\n      if (existingFilter && existingFilter.value === filterValue.value) {\n        removeFilter(key)\n      } else {\n        setFilter(key, filterValue)\n      }\n    })\n\n    // Call the onFilter callback if provided\n    if (Object.keys(filtersToApply).length > 0) {\n      const firstFilter = Object.values(filtersToApply)[0]\n      onFilter?.(firstFilter)\n    }\n  }, [\n    enableFiltering,\n    filterMappings,\n    filterData,\n    cardProps.title,\n    onClick,\n    onFilter,\n    setFilter,\n    removeFilter,\n    filters,\n  ])\n\n  return (\n    <DashboardCard\n      {...cardProps}\n      interactive={cardProps.interactive || enableFiltering}\n      onClick={handleCardClick}\n      onFilter={onFilter}\n    />\n  )\n}\n\n// Higher-order component for adding filtering to existing cards\nexport function withCardFiltering<T extends DashboardCardProps>(\n  WrappedComponent: React.ComponentType<T>,\n  defaultFilterMappings?: FilterableCardProps['filterMappings']\n) {\n  return function FilterableCardComponent(props: T & Partial<FilterableCardProps>) {\n    const {\n      enableFiltering = true,\n      filterMappings = defaultFilterMappings,\n      filterData,\n      onClick,\n      onFilter,\n      ...wrappedProps\n    } = props\n\n    const { setFilter, removeFilter, filters } = useFilters()\n\n    const handleCardClick = useCallback(() => {\n      onClick?.()\n\n      if (!enableFiltering) return\n\n      let filtersToApply: Record<string, FilterValue> = {}\n\n      if (filterMappings?.cardClick) {\n        filtersToApply = filterMappings.cardClick()\n      } else if (filterData) {\n        Object.entries(filterData).forEach(([key, value]) => {\n          if (value !== null && value !== undefined) {\n            filtersToApply[key] = {\n              type: typeof value === 'number' ? 'number' : 'string',\n              value,\n              operator: 'equals',\n            }\n          }\n        })\n      }\n\n      Object.entries(filtersToApply).forEach(([key, filterValue]) => {\n        const existingFilter = filters.customFilters?.[key]\n        if (existingFilter && existingFilter.value === filterValue.value) {\n          removeFilter(key)\n        } else {\n          setFilter(key, filterValue)\n        }\n      })\n\n      if (Object.keys(filtersToApply).length > 0) {\n        const firstFilter = Object.values(filtersToApply)[0]\n        onFilter?.(firstFilter)\n      }\n    }, [\n      enableFiltering,\n      filterMappings,\n      filterData,\n      onClick,\n      onFilter,\n      setFilter,\n      removeFilter,\n      filters,\n    ])\n\n    return (\n      <WrappedComponent\n        {...(wrappedProps as T)}\n        interactive={wrappedProps.interactive || enableFiltering}\n        onClick={handleCardClick}\n        onFilter={onFilter}\n      />\n    )\n  }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/filterable-chart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/filters/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/grid/__tests__/dashboard-grid.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/grid/__tests__/grid-utils.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/grid/dashboard-grid.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/grid/dashboard-grid.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'columns' is assigned a value but never used.",
        "line": 8,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 10
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { cn } from '@/lib/utils'\nimport { useIsMobile } from '../mobile/touch-interactions'\nimport type { DashboardGridProps } from '@/types/dashboard'\n\nexport function DashboardGrid({\n  children,\n  columns = 12,\n  gap,\n  className,\n  responsive = {\n    mobile: 1,\n    tablet: 6,\n    desktop: 12,\n  },\n  autoFlow = 'row',\n  alignItems = 'stretch',\n  justifyItems = 'stretch',\n}: DashboardGridProps) {\n  const isMobile = useIsMobile()\n  \n  // Use CSS custom properties for responsive behavior\n  const gridStyle = {\n    '--dashboard-grid-columns-mobile': responsive.mobile.toString(),\n    '--dashboard-grid-columns-tablet': responsive.tablet.toString(),\n    '--dashboard-grid-columns-desktop': responsive.desktop.toString(),\n    '--dashboard-grid-gap': gap ? `${gap}px` : 'var(--dashboard-grid-gap)',\n    gridAutoFlow: autoFlow,\n    alignItems,\n    justifyItems,\n  } as React.CSSProperties\n\n  return (\n    <div\n      className={cn(\n        'dashboard-grid',\n        'grid',\n        // Responsive grid columns using CSS custom properties\n        '[grid-template-columns:repeat(var(--dashboard-grid-columns-mobile),1fr)]',\n        'md:[grid-template-columns:repeat(var(--dashboard-grid-columns-tablet),1fr)]',\n        'lg:[grid-template-columns:repeat(var(--dashboard-grid-columns-desktop),1fr)]',\n        // Mobile-specific optimizations\n        isMobile && [\n          'px-4', // Add horizontal padding on mobile\n          'gap-4', // Reduce gap on mobile\n          'pb-20', // Add bottom padding for mobile navigation\n        ],\n        className\n      )}\n      style={gridStyle}\n    >\n      {children}\n    </div>\n  )\n}\n\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/grid/grid-item.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/grid/grid-utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/grid/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/__tests__/dashboard-layout-responsive.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 1,
        "message": "A `require()` style import is forbidden.",
        "line": 206,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 206,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { DashboardLayout } from '../dashboard-layout'\n\n// Mock the mobile hook\njest.mock('../../mobile/touch-interactions', () => ({\n  useIsMobile: jest.fn(() => false)\n}))\n\n// Mock localStorage\nconst mockLocalStorage = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n}\nObject.defineProperty(window, 'localStorage', {\n  value: mockLocalStorage\n})\n\n// Mock window.innerWidth\nObject.defineProperty(window, 'innerWidth', {\n  writable: true,\n  configurable: true,\n  value: 1280\n})\n\ndescribe('DashboardLayout Responsive Behavior', () => {\n  const mockHeader = <div data-testid=\"header\">Header Content</div>\n  const mockSidebar = <div data-testid=\"sidebar\">Sidebar Content</div>\n  const mockFooter = <div data-testid=\"footer\">Footer Content</div>\n  const mockChildren = <div data-testid=\"main-content\">Main Content</div>\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n    // Reset window width to desktop\n    window.innerWidth = 1280\n  })\n\n  describe('Desktop Layout (>= 1280px)', () => {\n    it('renders full grid layout with all regions', () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n          footer={mockFooter}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      expect(screen.getByTestId('header')).toBeInTheDocument()\n      expect(screen.getByTestId('sidebar')).toBeInTheDocument()\n      expect(screen.getByTestId('footer')).toBeInTheDocument()\n      expect(screen.getByTestId('main-content')).toBeInTheDocument()\n    })\n\n    it('applies correct grid template areas for desktop', () => {\n      const { container } = render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n          footer={mockFooter}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const layout = container.firstChild as HTMLElement\n      expect(layout).toHaveStyle({\n        gridTemplateColumns: '280px 1fr',\n        gridTemplateRows: '64px 1fr 48px'\n      })\n    })\n\n    it('shows sidebar toggle button', () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const toggleButton = screen.getByRole('button', { name: /collapse sidebar/i })\n      expect(toggleButton).toBeInTheDocument()\n      expect(toggleButton).toHaveAttribute('aria-expanded', 'true')\n    })\n\n    it('toggles sidebar when button is clicked', async () => {\n      const user = userEvent.setup()\n      const { container } = render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const toggleButton = screen.getByRole('button', { name: /collapse sidebar/i })\n      await user.click(toggleButton)\n\n      expect(toggleButton).toHaveAttribute('aria-expanded', 'false')\n      expect(toggleButton).toHaveAttribute('aria-label', 'Expand sidebar')\n\n      const layout = container.firstChild as HTMLElement\n      await waitFor(() => {\n        expect(layout).toHaveStyle({\n          gridTemplateColumns: '1fr'\n        })\n      })\n    })\n\n    it('persists sidebar state to localStorage', async () => {\n      const user = userEvent.setup()\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const toggleButton = screen.getByRole('button', { name: /collapse sidebar/i })\n      await user.click(toggleButton)\n\n      await waitFor(() => {\n        expect(mockLocalStorage.setItem).toHaveBeenCalledWith(\n          'dashboard-sidebar-collapsed',\n          'true'\n        )\n      })\n    })\n\n    it('restores sidebar state from localStorage', () => {\n      mockLocalStorage.getItem.mockReturnValue('true')\n\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const toggleButton = screen.getByRole('button', { name: /expand sidebar/i })\n      expect(toggleButton).toHaveAttribute('aria-expanded', 'false')\n    })\n  })\n\n  describe('Tablet Layout (768px - 1279px)', () => {\n    beforeEach(() => {\n      window.innerWidth = 1024\n    })\n\n    it('applies tablet-specific grid columns', async () => {\n      const { container } = render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Trigger resize event\n      fireEvent(window, new Event('resize'))\n\n      await waitFor(() => {\n        const layout = container.firstChild as HTMLElement\n        expect(layout).toHaveStyle({\n          gridTemplateColumns: '240px 1fr'\n        })\n      })\n    })\n\n    it('maintains sidebar functionality on tablet', async () => {\n      const user = userEvent.setup()\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Trigger resize to tablet\n      fireEvent(window, new Event('resize'))\n\n      const toggleButton = screen.getByRole('button', { name: /collapse sidebar/i })\n      await user.click(toggleButton)\n\n      expect(toggleButton).toHaveAttribute('aria-expanded', 'false')\n    })\n  })\n\n  describe('Mobile Layout (< 768px)', () => {\n    beforeEach(() => {\n      window.innerWidth = 600\n      // Mock mobile hook to return true\n      const { useIsMobile } = require('../../mobile/touch-interactions')\n      useIsMobile.mockReturnValue(true)\n    })\n\n    it('hides sidebar on mobile', async () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Trigger resize event\n      fireEvent(window, new Event('resize'))\n\n      await waitFor(() => {\n        expect(screen.queryByTestId('sidebar')).not.toBeInTheDocument()\n      })\n    })\n\n    it('applies single-column grid layout', async () => {\n      const { container } = render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Trigger resize event\n      fireEvent(window, new Event('resize'))\n\n      await waitFor(() => {\n        const layout = container.firstChild as HTMLElement\n        expect(layout).toHaveStyle({\n          gridTemplateColumns: '1fr'\n        })\n      })\n    })\n\n    it('hides sidebar toggle button on mobile', async () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Trigger resize event\n      fireEvent(window, new Event('resize'))\n\n      await waitFor(() => {\n        expect(screen.queryByRole('button', { name: /sidebar/i })).not.toBeInTheDocument()\n      })\n    })\n\n    it('shows mobile navigation when enabled', async () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n          showMobileNav={true}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Trigger resize event\n      fireEvent(window, new Event('resize'))\n\n      await waitFor(() => {\n        const mainContent = screen.getByRole('main')\n        expect(mainContent).toHaveClass('pb-20')\n      })\n    })\n\n    it('adds bottom padding to main content for mobile nav', async () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          showMobileNav={true}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Trigger resize event\n      fireEvent(window, new Event('resize'))\n\n      await waitFor(() => {\n        const mainContent = screen.getByRole('main')\n        expect(mainContent).toHaveClass('pb-20')\n      })\n    })\n  })\n\n  describe('Responsive Transitions', () => {\n    it('debounces resize events', async () => {\n      const { container } = render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Fire multiple resize events quickly\n      window.innerWidth = 800\n      fireEvent(window, new Event('resize'))\n      window.innerWidth = 900\n      fireEvent(window, new Event('resize'))\n      window.innerWidth = 1000\n      fireEvent(window, new Event('resize'))\n\n      // Wait for debounce delay\n      await waitFor(() => {\n        const layout = container.firstChild as HTMLElement\n        expect(layout).toHaveStyle({\n          gridTemplateColumns: '240px 1fr'\n        })\n      }, { timeout: 200 })\n    })\n\n    it('applies transition classes for smooth animations', () => {\n      const { container } = render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const layout = container.firstChild as HTMLElement\n      expect(layout).toHaveClass('transition-all', 'duration-300', 'ease-in-out')\n    })\n  })\n\n  describe('Custom Grid Configuration', () => {\n    it('accepts custom grid areas', () => {\n      const customGridAreas = {\n        header: 'top',\n        sidebar: 'nav',\n        main: 'content',\n        footer: 'bottom'\n      }\n\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n          footer={mockFooter}\n          gridAreas={customGridAreas}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const header = screen.getByRole('banner')\n      const sidebar = screen.getByRole('navigation')\n      const main = screen.getByRole('main')\n      const footer = screen.getByRole('contentinfo')\n\n      expect(header).toHaveStyle({ gridArea: 'top' })\n      expect(sidebar).toHaveStyle({ gridArea: 'nav' })\n      expect(main).toHaveStyle({ gridArea: 'content' })\n      expect(footer).toHaveStyle({ gridArea: 'bottom' })\n    })\n\n    it('accepts custom breakpoints', async () => {\n      const customBreakpoints = {\n        mobile: 600,\n        tablet: 900,\n        desktop: 1200\n      }\n\n      const { container } = render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n          breakpoints={customBreakpoints}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Test tablet breakpoint\n      window.innerWidth = 800\n      fireEvent(window, new Event('resize'))\n\n      await waitFor(() => {\n        const layout = container.firstChild as HTMLElement\n        expect(layout).toHaveStyle({\n          gridTemplateColumns: '240px 1fr'\n        })\n      })\n    })\n  })\n\n  describe('Accessibility Features', () => {\n    it('provides proper ARIA labels and roles', () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n          footer={mockFooter}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      expect(screen.getByRole('banner')).toBeInTheDocument()\n      expect(screen.getByRole('navigation')).toHaveAttribute('aria-label', 'Main navigation')\n      expect(screen.getByRole('main')).toBeInTheDocument()\n      expect(screen.getByRole('contentinfo')).toBeInTheDocument()\n    })\n\n    it('provides skip links for keyboard navigation', () => {\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n          footer={mockFooter}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      // Skip links are rendered by KeyboardNavigation component\n      // We can test that the component is rendered with proper props\n      const layout = screen.getByRole('grid')\n      expect(layout).toBeInTheDocument()\n    })\n\n    it('manages focus properly when sidebar is toggled', async () => {\n      const user = userEvent.setup()\n      render(\n        <DashboardLayout\n          header={mockHeader}\n          sidebar={mockSidebar}\n        >\n          {mockChildren}\n        </DashboardLayout>\n      )\n\n      const toggleButton = screen.getByRole('button', { name: /collapse sidebar/i })\n      \n      // Focus the toggle button\n      toggleButton.focus()\n      expect(toggleButton).toHaveFocus()\n\n      // Click to toggle sidebar\n      await user.click(toggleButton)\n\n      // Button should still be focusable and have updated aria attributes\n      expect(toggleButton).toHaveAttribute('aria-expanded', 'false')\n      expect(toggleButton).toHaveAttribute('aria-controls', 'dashboard-sidebar')\n    })\n  })\n\n  describe('Error Handling', () => {\n    it('handles missing localStorage gracefully', () => {\n      // Mock localStorage to throw an error\n      mockLocalStorage.getItem.mockImplementation(() => {\n        throw new Error('localStorage not available')\n      })\n\n      expect(() => {\n        render(\n          <DashboardLayout\n            header={mockHeader}\n            sidebar={mockSidebar}\n          >\n            {mockChildren}\n          </DashboardLayout>\n        )\n      }).not.toThrow()\n    })\n\n    it('handles invalid localStorage data gracefully', () => {\n      mockLocalStorage.getItem.mockReturnValue('invalid-json')\n\n      expect(() => {\n        render(\n          <DashboardLayout\n            header={mockHeader}\n            sidebar={mockSidebar}\n          >\n            {mockChildren}\n          </DashboardLayout>\n        )\n      }).not.toThrow()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/__tests__/mobile-navigation.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'onSwipeRight' is defined but never used.",
        "line": 15,
        "column": 47,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [579, 582], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [579, 582], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 27,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 27,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [825, 828], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [825, 828], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { useRouter, usePathname } from 'next/navigation'\nimport { MobileNavigation, defaultMobileNavItems, useMobileNavigation } from '../mobile-navigation'\nimport { useIsMobile } from '../../mobile/touch-interactions'\n\n// Mock Next.js navigation\njest.mock('next/navigation', () => ({\n  useRouter: jest.fn(),\n  usePathname: jest.fn(),\n}))\n\n// Mock mobile hooks\njest.mock('../../mobile/touch-interactions', () => ({\n  useIsMobile: jest.fn(),\n  TouchInteraction: ({ children, onSwipeLeft, onSwipeRight }: any) => (\n    <div \n      data-testid=\"touch-wrapper\"\n      onTouchStart={() => onSwipeLeft?.()}\n    >\n      {children}\n    </div>\n  ),\n}))\n\n// Mock mobile tooltip\njest.mock('../../mobile/mobile-tooltip', () => ({\n  MobileTooltip: ({ children }: any) => children,\n}))\n\nconst mockRouter = {\n  push: jest.fn(),\n  replace: jest.fn(),\n  back: jest.fn(),\n}\n\nconst mockUseRouter = useRouter as jest.MockedFunction<typeof useRouter>\nconst mockUsePathname = usePathname as jest.MockedFunction<typeof usePathname>\nconst mockUseIsMobile = useIsMobile as jest.MockedFunction<typeof useIsMobile>\n\ndescribe('MobileNavigation', () => {\n  beforeEach(() => {\n    mockUseRouter.mockReturnValue(mockRouter)\n    mockUsePathname.mockReturnValue('/dashboard')\n    mockUseIsMobile.mockReturnValue(true)\n    jest.clearAllMocks()\n  })\n\n  it('renders navigation items', () => {\n    render(<MobileNavigation items={defaultMobileNavItems} />)\n    \n    expect(screen.getByText('Dashboard')).toBeInTheDocument()\n    expect(screen.getByText('Agents')).toBeInTheDocument()\n    expect(screen.getByText('Tasks')).toBeInTheDocument()\n    expect(screen.getByText('Analytics')).toBeInTheDocument()\n    expect(screen.getByText('Settings')).toBeInTheDocument()\n  })\n\n  it('highlights active item based on pathname', () => {\n    mockUsePathname.mockReturnValue('/dashboard/agents')\n    \n    render(<MobileNavigation items={defaultMobileNavItems} />)\n    \n    // The component should render and the active state should be managed internally\n    // We can test that the component renders without errors when pathname matches\n    expect(screen.getByText('Agents')).toBeInTheDocument()\n    expect(screen.getByRole('button', { name: 'Agents' })).toBeInTheDocument()\n  })\n\n  it('navigates when item is clicked', () => {\n    const onItemClick = jest.fn()\n    \n    render(\n      <MobileNavigation \n        items={defaultMobileNavItems} \n        onItemClick={onItemClick}\n      />\n    )\n    \n    const agentsButton = screen.getByRole('button', { name: 'Agents' })\n    fireEvent.click(agentsButton)\n    \n    expect(mockRouter.push).toHaveBeenCalledWith('/dashboard/agents')\n    expect(onItemClick).toHaveBeenCalledWith(\n      expect.objectContaining({\n        id: 'agents',\n        href: '/dashboard/agents',\n      })\n    )\n  })\n\n  it('shows badge when item has badge', () => {\n    const itemsWithBadge = [\n      {\n        ...defaultMobileNavItems[0],\n        badge: 5,\n      },\n    ]\n    \n    render(<MobileNavigation items={itemsWithBadge} />)\n    \n    expect(screen.getByText('5')).toBeInTheDocument()\n    expect(screen.getByLabelText('5 notifications')).toBeInTheDocument()\n  })\n\n  it('handles disabled items', () => {\n    const itemsWithDisabled = [\n      {\n        ...defaultMobileNavItems[0],\n        disabled: true,\n      },\n    ]\n    \n    render(<MobileNavigation items={itemsWithDisabled} />)\n    \n    const disabledButton = screen.getByRole('button', { name: 'Dashboard' })\n    expect(disabledButton).toBeDisabled()\n    \n    fireEvent.click(disabledButton)\n    expect(mockRouter.push).not.toHaveBeenCalled()\n  })\n\n  it('shows 99+ for badges over 99', () => {\n    const itemsWithLargeBadge = [\n      {\n        ...defaultMobileNavItems[0],\n        badge: 150,\n      },\n    ]\n    \n    render(<MobileNavigation items={itemsWithLargeBadge} />)\n    \n    expect(screen.getByText('99+')).toBeInTheDocument()\n  })\n\n  it('does not render on desktop', () => {\n    mockUseIsMobile.mockReturnValue(false)\n    \n    const { container } = render(<MobileNavigation items={defaultMobileNavItems} />)\n    \n    expect(container.firstChild).toBeNull()\n  })\n\n  it('handles swipe navigation between sections', async () => {\n    const onItemClick = jest.fn()\n    \n    render(\n      <MobileNavigation \n        items={defaultMobileNavItems} \n        onItemClick={onItemClick}\n      />\n    )\n    \n    const touchWrapper = screen.getByTestId('touch-wrapper')\n    fireEvent.touchStart(touchWrapper)\n    \n    // Should navigate to next item\n    await waitFor(() => {\n      expect(onItemClick).toHaveBeenCalled()\n    })\n  })\n\n  it('prevents navigation during transitions', () => {\n    render(<MobileNavigation items={defaultMobileNavItems} />)\n    \n    const firstButton = screen.getByRole('button', { name: 'Dashboard' })\n    \n    // Click rapidly\n    fireEvent.click(firstButton)\n    fireEvent.click(firstButton)\n    \n    // Should only navigate once due to transition state\n    expect(mockRouter.push).toHaveBeenCalledTimes(1)\n  })\n\n  it('shows swipe indicator', () => {\n    render(<MobileNavigation items={defaultMobileNavItems} />)\n    \n    // Should show the swipe indicator line\n    const indicator = document.querySelector('.absolute.top-1')\n    expect(indicator).toBeInTheDocument()\n  })\n\n  it('provides screen reader instructions', () => {\n    render(<MobileNavigation items={defaultMobileNavItems} />)\n    \n    expect(screen.getByText(/Swipe left or right to navigate/)).toBeInTheDocument()\n    expect(screen.getByText(/Current section:/)).toBeInTheDocument()\n  })\n\n  it('applies touch-optimized styles', () => {\n    render(<MobileNavigation items={defaultMobileNavItems} />)\n    \n    const buttons = screen.getAllByRole('button')\n    buttons.forEach(button => {\n      expect(button).toHaveClass('min-h-[44px]') // Minimum touch target\n      expect(button).toHaveClass('touch-manipulation')\n      expect(button).toHaveClass('select-none')\n    })\n  })\n})\n\ndescribe('useMobileNavigation', () => {\n  it('shows navigation by default', () => {\n    const TestComponent = () => {\n      const { isVisible } = useMobileNavigation()\n      return <div data-testid=\"nav-visibility\">{isVisible ? 'visible' : 'hidden'}</div>\n    }\n    \n    render(<TestComponent />)\n    expect(screen.getByTestId('nav-visibility')).toHaveTextContent('visible')\n  })\n\n  it('provides visibility control', () => {\n    const TestComponent = () => {\n      const { isVisible, setIsVisible } = useMobileNavigation()\n      return (\n        <div>\n          <div data-testid=\"nav-visibility\">{isVisible ? 'visible' : 'hidden'}</div>\n          <button onClick={() => setIsVisible(false)}>Hide</button>\n        </div>\n      )\n    }\n    \n    render(<TestComponent />)\n    \n    expect(screen.getByTestId('nav-visibility')).toHaveTextContent('visible')\n    \n    fireEvent.click(screen.getByText('Hide'))\n    expect(screen.getByTestId('nav-visibility')).toHaveTextContent('hidden')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/__tests__/swipe-navigation.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 10,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 10,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [482, 485], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [482, 485], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { SwipeNavigation, useSwipeNavigation, createDashboardSections } from '../swipe-navigation'\nimport { useIsMobile } from '../../mobile/touch-interactions'\n\n// Mock the mobile hook\njest.mock('../../mobile/touch-interactions', () => ({\n  useIsMobile: jest.fn(),\n  TouchInteraction: ({ children, onSwipeLeft, onSwipeRight }: any) => (\n    <div \n      data-testid=\"touch-wrapper\"\n      onTouchStart={() => {\n        // Simulate swipe gestures for testing\n        if (Math.random() > 0.5) {\n          onSwipeLeft?.()\n        } else {\n          onSwipeRight?.()\n        }\n      }}\n    >\n      {children}\n    </div>\n  ),\n}))\n\nconst mockUseIsMobile = useIsMobile as jest.MockedFunction<typeof useIsMobile>\n\nconst mockSections = [\n  {\n    id: 'section1',\n    title: 'Section 1',\n    content: <div>Content 1</div>,\n  },\n  {\n    id: 'section2',\n    title: 'Section 2',\n    content: <div>Content 2</div>,\n  },\n  {\n    id: 'section3',\n    title: 'Section 3',\n    content: <div>Content 3</div>,\n    disabled: true,\n  },\n]\n\ndescribe('SwipeNavigation', () => {\n  beforeEach(() => {\n    mockUseIsMobile.mockReturnValue(true)\n    jest.clearAllMocks()\n  })\n\n  it('renders initial section correctly', () => {\n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        initialSection=\"section1\"\n      />\n    )\n\n    expect(screen.getByText('Content 1')).toBeInTheDocument()\n    expect(screen.queryByText('Content 2')).not.toBeInTheDocument()\n  })\n\n  it('shows section indicators when enabled', () => {\n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        showIndicators={true}\n      />\n    )\n\n    const indicators = screen.getAllByRole('tab')\n    expect(indicators).toHaveLength(3)\n    expect(indicators[0]).toHaveAttribute('aria-selected', 'true')\n  })\n\n  it('hides section indicators when disabled', () => {\n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        showIndicators={false}\n      />\n    )\n\n    expect(screen.queryByRole('tablist')).not.toBeInTheDocument()\n  })\n\n  it('navigates to section when indicator is clicked', async () => {\n    const onSectionChange = jest.fn()\n    \n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        onSectionChange={onSectionChange}\n        showIndicators={true}\n      />\n    )\n\n    const indicators = screen.getAllByRole('tab')\n    await userEvent.click(indicators[1])\n\n    await waitFor(() => {\n      expect(onSectionChange).toHaveBeenCalledWith('section2')\n    })\n  })\n\n  it('handles keyboard navigation', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        enableKeyboardNavigation={true}\n      />\n    )\n\n    const container = screen.getByRole('region')\n    container.focus()\n\n    // Navigate right\n    await user.keyboard('{ArrowRight}')\n    \n    await waitFor(() => {\n      expect(screen.getByText('Content 2')).toBeInTheDocument()\n    })\n\n    // Navigate left\n    await user.keyboard('{ArrowLeft}')\n    \n    await waitFor(() => {\n      expect(screen.getByText('Content 1')).toBeInTheDocument()\n    })\n  })\n\n  it('handles Home and End keys', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        initialSection=\"section2\"\n        enableKeyboardNavigation={true}\n      />\n    )\n\n    const container = screen.getByRole('region')\n    container.focus()\n\n    // Go to end\n    await user.keyboard('{End}')\n    \n    await waitFor(() => {\n      expect(screen.getByText('Content 3')).toBeInTheDocument()\n    })\n\n    // Go to home\n    await user.keyboard('{Home}')\n    \n    await waitFor(() => {\n      expect(screen.getByText('Content 1')).toBeInTheDocument()\n    })\n  })\n\n  it('skips disabled sections', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        initialSection=\"section2\"\n        enableKeyboardNavigation={true}\n      />\n    )\n\n    const container = screen.getByRole('region')\n    container.focus()\n\n    // Try to navigate to disabled section\n    await user.keyboard('{ArrowRight}')\n    \n    // Should stay on section2 since section3 is disabled\n    expect(screen.getByText('Content 2')).toBeInTheDocument()\n    expect(screen.queryByText('Content 3')).not.toBeInTheDocument()\n  })\n\n  it('prevents navigation during transitions', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        animationDuration={100}\n        enableKeyboardNavigation={true}\n      />\n    )\n\n    const container = screen.getByRole('region')\n    container.focus()\n\n    // Start navigation\n    await user.keyboard('{ArrowRight}')\n    \n    // Try to navigate again immediately (should be ignored)\n    await user.keyboard('{ArrowRight}')\n    \n    await waitFor(() => {\n      expect(screen.getByText('Content 2')).toBeInTheDocument()\n    })\n  })\n\n  it('renders desktop version when not mobile', () => {\n    mockUseIsMobile.mockReturnValue(false)\n    \n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        initialSection=\"section1\"\n      />\n    )\n\n    // Should render content directly without swipe functionality\n    expect(screen.getByText('Content 1')).toBeInTheDocument()\n    expect(screen.queryByRole('tablist')).not.toBeInTheDocument()\n  })\n\n  it('updates section when initialSection prop changes', async () => {\n    const { rerender } = render(\n      <SwipeNavigation\n        sections={mockSections}\n        initialSection=\"section1\"\n      />\n    )\n\n    expect(screen.getByText('Content 1')).toBeInTheDocument()\n\n    rerender(\n      <SwipeNavigation\n        sections={mockSections}\n        initialSection=\"section2\"\n      />\n    )\n\n    await waitFor(() => {\n      expect(screen.getByText('Content 2')).toBeInTheDocument()\n    })\n  })\n\n  it('shows section title during transitions', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <SwipeNavigation\n        sections={mockSections}\n        enableKeyboardNavigation={true}\n        animationDuration={200}\n      />\n    )\n\n    const container = screen.getByRole('region')\n    container.focus()\n\n    await user.keyboard('{ArrowRight}')\n\n    // Section title should be visible during transition\n    expect(screen.getByText('Section 2')).toBeInTheDocument()\n  })\n})\n\ndescribe('useSwipeNavigation', () => {\n  it('manages current section state', () => {\n    const TestComponent = () => {\n      const { currentSectionId, navigateToSection } = useSwipeNavigation(\n        mockSections,\n        'section1'\n      )\n      \n      return (\n        <div>\n          <div data-testid=\"current\">{currentSectionId}</div>\n          <button onClick={() => navigateToSection('section2')}>\n            Navigate\n          </button>\n        </div>\n      )\n    }\n\n    render(<TestComponent />)\n    \n    expect(screen.getByTestId('current')).toHaveTextContent('section1')\n    \n    fireEvent.click(screen.getByText('Navigate'))\n    \n    expect(screen.getByTestId('current')).toHaveTextContent('section2')\n  })\n\n  it('maintains navigation history', () => {\n    const TestComponent = () => {\n      const { currentSectionId, navigateToSection, goBack, canGoBack } = useSwipeNavigation(\n        mockSections,\n        'section1'\n      )\n      \n      return (\n        <div>\n          <div data-testid=\"current\">{currentSectionId}</div>\n          <div data-testid=\"can-go-back\">{canGoBack.toString()}</div>\n          <button onClick={() => navigateToSection('section2')}>\n            Navigate to 2\n          </button>\n          <button onClick={goBack} disabled={!canGoBack}>\n            Go Back\n          </button>\n        </div>\n      )\n    }\n\n    render(<TestComponent />)\n    \n    expect(screen.getByTestId('can-go-back')).toHaveTextContent('false')\n    \n    // Navigate to section 2\n    fireEvent.click(screen.getByText('Navigate to 2'))\n    \n    expect(screen.getByTestId('current')).toHaveTextContent('section2')\n    expect(screen.getByTestId('can-go-back')).toHaveTextContent('true')\n    \n    // Go back\n    fireEvent.click(screen.getByText('Go Back'))\n    \n    expect(screen.getByTestId('current')).toHaveTextContent('section1')\n    expect(screen.getByTestId('can-go-back')).toHaveTextContent('false')\n  })\n})\n\ndescribe('createDashboardSections', () => {\n  it('creates sections from dashboard pages', () => {\n    const TestComponent = () => <div>Test Component</div>\n    \n    const pages = [\n      {\n        id: 'page1',\n        title: 'Page 1',\n        component: TestComponent,\n      },\n      {\n        id: 'page2',\n        title: 'Page 2',\n        component: TestComponent,\n        disabled: true,\n      },\n    ]\n\n    const sections = createDashboardSections(pages)\n\n    expect(sections).toHaveLength(2)\n    expect(sections[0]).toMatchObject({\n      id: 'page1',\n      title: 'Page 1',\n      disabled: undefined,\n    })\n    expect(sections[1]).toMatchObject({\n      id: 'page2',\n      title: 'Page 2',\n      disabled: true,\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/dashboard-footer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/dashboard-header.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/dashboard-layout.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/dashboard-layout.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SwipeNavigation' is defined but never used.",
        "line": 7,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'useSwipeNavigation' is defined but never used.",
        "line": 7,
        "column": 27,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'SkipLinks' is defined but never used.",
        "line": 9,
        "column": 30,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'FocusManagement' is defined but never used.",
        "line": 10,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 10,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'enableSwipeNavigation' is assigned a value but never used.",
        "line": 36,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 36,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useState, useEffect, useCallback } from 'react'\nimport { cn } from '@/lib/utils'\nimport { DashboardLayoutProps } from '@/types/dashboard'\nimport { MobileNavigation, defaultMobileNavItems, useMobileNavigation } from './mobile-navigation'\nimport { SwipeNavigation, useSwipeNavigation } from './swipe-navigation'\nimport { useIsMobile } from '../mobile/touch-interactions'\nimport { KeyboardNavigation, SkipLinks } from '../accessibility/keyboard-navigation'\nimport { FocusManagement } from '../accessibility/focus-management'\nimport { ScreenReaderAnnouncer } from '../accessibility/screen-reader-announcer'\n\nconst defaultGridAreas = {\n  header: 'header',\n  sidebar: 'sidebar',\n  main: 'main',\n  footer: 'footer'\n}\n\nconst defaultBreakpoints = {\n  mobile: 768,\n  tablet: 1024,\n  desktop: 1280\n}\n\nexport function DashboardLayout({\n  children,\n  header,\n  sidebar,\n  footer,\n  className,\n  gridAreas = defaultGridAreas,\n  breakpoints = defaultBreakpoints,\n  mobileNavItems = defaultMobileNavItems,\n  showMobileNav = true,\n  enableSwipeNavigation = true,\n  ...props\n}: DashboardLayoutProps) {\n  const isMobileHook = useIsMobile()\n  const [isTablet, setIsTablet] = useState(false)\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false)\n  const [isInitialized, setIsInitialized] = useState(false)\n  const { isVisible: isMobileNavVisible } = useMobileNavigation()\n  \n  // Use the hook for mobile detection\n  const isMobile = isMobileHook\n\n  // Handle responsive breakpoints with debouncing\n  const handleResize = useCallback(() => {\n    const width = window.innerWidth\n    const newIsTablet = width >= breakpoints.mobile && width < breakpoints.desktop\n    \n    setIsTablet(newIsTablet)\n    \n    // Auto-collapse sidebar on mobile, but preserve user preference on desktop\n    if (isMobile && !sidebarCollapsed) {\n      setSidebarCollapsed(true)\n    } else if (!isMobile && !isInitialized) {\n      // Restore sidebar state from localStorage on desktop\n      const savedState = localStorage.getItem('dashboard-sidebar-collapsed')\n      if (savedState !== null) {\n        setSidebarCollapsed(JSON.parse(savedState))\n      }\n    }\n    \n    if (!isInitialized) {\n      setIsInitialized(true)\n    }\n  }, [breakpoints, sidebarCollapsed, isInitialized, isMobile])\n\n  useEffect(() => {\n    // Initial setup\n    handleResize()\n    \n    // Debounced resize handler\n    let timeoutId: NodeJS.Timeout\n    const debouncedResize = () => {\n      clearTimeout(timeoutId)\n      timeoutId = setTimeout(handleResize, 150)\n    }\n\n    window.addEventListener('resize', debouncedResize)\n    return () => {\n      window.removeEventListener('resize', debouncedResize)\n      clearTimeout(timeoutId)\n    }\n  }, [handleResize])\n\n  // Persist sidebar state to localStorage\n  useEffect(() => {\n    if (isInitialized && !isMobile) {\n      localStorage.setItem('dashboard-sidebar-collapsed', JSON.stringify(sidebarCollapsed))\n    }\n  }, [sidebarCollapsed, isMobile, isInitialized])\n\n  // Generate CSS Grid template areas based on screen size and sidebar state\n  const getGridTemplateAreas = () => {\n    if (isMobile) {\n      return `\n        \"${gridAreas.header}\"\n        \"${gridAreas.main}\"\n        ${footer ? `\"${gridAreas.footer}\"` : ''}\n      `.trim()\n    }\n\n    if (sidebarCollapsed || !sidebar) {\n      return `\n        \"${gridAreas.header} ${gridAreas.header}\"\n        \"${gridAreas.main} ${gridAreas.main}\"\n        ${footer ? `\"${gridAreas.footer} ${gridAreas.footer}\"` : ''}\n      `.trim()\n    }\n\n    return `\n      \"${gridAreas.header} ${gridAreas.header}\"\n      \"${gridAreas.sidebar} ${gridAreas.main}\"\n      ${footer ? `\"${gridAreas.footer} ${gridAreas.footer}\"` : ''}\n    `.trim()\n  }\n\n  // Generate CSS Grid template columns\n  const getGridTemplateColumns = () => {\n    if (isMobile) {\n      return '1fr'\n    }\n\n    if (sidebarCollapsed || !sidebar) {\n      return '1fr'\n    }\n\n    return isTablet ? '240px 1fr' : '280px 1fr'\n  }\n\n  // Generate CSS Grid template rows\n  const getGridTemplateRows = () => {\n    const headerHeight = '64px'\n    const footerHeight = footer ? '48px' : '0px'\n    \n    if (footer) {\n      return `${headerHeight} 1fr ${footerHeight}`\n    }\n    \n    return `${headerHeight} 1fr`\n  }\n\n  const gridStyles = {\n    gridTemplateAreas: getGridTemplateAreas(),\n    gridTemplateColumns: getGridTemplateColumns(),\n    gridTemplateRows: getGridTemplateRows(),\n  }\n\n  // Default skip links for accessibility\n  const defaultSkipLinks = [\n    { href: '#main-content', label: 'Skip to main content' },\n    { href: '#dashboard-sidebar', label: 'Skip to navigation' },\n    ...(footer ? [{ href: '#dashboard-footer', label: 'Skip to footer' }] : [])\n  ]\n\n  return (\n    <KeyboardNavigation\n      skipLinks={defaultSkipLinks}\n      className={cn(\n        'dashboard-layout',\n        'min-h-screen',\n        'grid',\n        'transition-all',\n        'duration-300',\n        'ease-in-out',\n        className\n      )}\n      style={gridStyles}\n      {...props}\n    >\n      {/* Header */}\n      {header && (\n        <header\n          id=\"dashboard-header\"\n          className={cn(\n            'dashboard-header',\n            'flex',\n            'items-center',\n            'justify-between',\n            'px-4',\n            'lg:px-6',\n            'border-b',\n            'border-dashboard-border',\n            'bg-dashboard-surface',\n            'z-10'\n          )}\n          style={{ gridArea: gridAreas.header }}\n          role=\"banner\"\n        >\n          {header}\n          \n          {/* Sidebar Toggle Button */}\n          {sidebar && !isMobile && (\n            <button\n              onClick={() => setSidebarCollapsed(!sidebarCollapsed)}\n              className={cn(\n                'p-2',\n                'rounded-md',\n                'hover:bg-dashboard-background',\n                'transition-colors',\n                'duration-200',\n                'focus:outline-none',\n                'focus:ring-2',\n                'focus:ring-dashboard-primary',\n                'focus:ring-offset-2',\n                'ml-auto' // Push to right side of header\n              )}\n              aria-label={sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}\n              aria-expanded={!sidebarCollapsed}\n              aria-controls=\"dashboard-sidebar\"\n            >\n              <svg\n                className={cn(\n                  'w-5 h-5',\n                  'text-dashboard-text-secondary',\n                  'transition-transform',\n                  'duration-300',\n                  'ease-in-out',\n                  sidebarCollapsed && 'rotate-180'\n                )}\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n                aria-hidden=\"true\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M11 19l-7-7 7-7m8 14l-7-7 7-7\"\n                />\n              </svg>\n            </button>\n          )}\n        </header>\n      )}\n\n      {/* Sidebar */}\n      {sidebar && !isMobile && (\n        <aside\n          id=\"dashboard-sidebar\"\n          className={cn(\n            'dashboard-sidebar',\n            'border-r',\n            'border-dashboard-border',\n            'bg-dashboard-surface',\n            'overflow-y-auto',\n            'transition-all',\n            'duration-300',\n            'ease-in-out',\n            'relative',\n            sidebarCollapsed && 'w-0 overflow-hidden'\n          )}\n          style={{ gridArea: gridAreas.sidebar }}\n          role=\"navigation\"\n          aria-label=\"Main navigation\"\n          aria-hidden={sidebarCollapsed}\n        >\n          <div className={cn(\n            'p-4',\n            'transition-opacity',\n            'duration-300',\n            'ease-in-out',\n            sidebarCollapsed && 'opacity-0'\n          )}>\n            {sidebar}\n          </div>\n          \n          {/* Sidebar resize handle for better UX */}\n          <div\n            className={cn(\n              'absolute',\n              'top-0',\n              'right-0',\n              'w-1',\n              'h-full',\n              'bg-transparent',\n              'hover:bg-dashboard-primary',\n              'transition-colors',\n              'duration-200',\n              'cursor-col-resize',\n              sidebarCollapsed && 'hidden'\n            )}\n            aria-hidden=\"true\"\n          />\n        </aside>\n      )}\n\n      {/* Main Content */}\n      <main\n        className={cn(\n          'dashboard-main',\n          'overflow-auto',\n          'bg-dashboard-background',\n          'min-h-0', // Prevents grid item from growing beyond container\n          // Add bottom padding on mobile to account for mobile navigation\n          isMobile && showMobileNav && 'pb-20'\n        )}\n        style={{ gridArea: gridAreas.main }}\n        role=\"main\"\n        id=\"main-content\"\n      >\n        {children}\n      </main>\n\n      {/* Footer */}\n      {footer && (\n        <footer\n          id=\"dashboard-footer\"\n          className={cn(\n            'dashboard-footer',\n            'flex',\n            'items-center',\n            'justify-between',\n            'px-4',\n            'lg:px-6',\n            'border-t',\n            'border-dashboard-border',\n            'bg-dashboard-surface',\n            'text-sm',\n            'text-dashboard-text-secondary'\n          )}\n          style={{ gridArea: gridAreas.footer }}\n          role=\"contentinfo\"\n        >\n          {footer}\n        </footer>\n      )}\n\n      {/* Mobile Navigation */}\n      {isMobile && showMobileNav && (\n        <div\n          className={cn(\n            'mobile-nav-container',\n            'transition-transform',\n            'duration-300',\n            'ease-in-out',\n            !isMobileNavVisible && 'translate-y-full'\n          )}\n        >\n          <MobileNavigation\n            items={mobileNavItems}\n            onItemClick={(item) => {\n              // Handle mobile navigation item clicks\n              console.log('Mobile nav item clicked:', item)\n            }}\n          />\n        </div>\n      )}\n\n\n\n      {/* Screen Reader Announcer */}\n      <ScreenReaderAnnouncer />\n    </KeyboardNavigation>\n  )\n}\n\n// Export additional layout components for composition\nexport function DashboardHeader({ children, className, ...props }: React.HTMLAttributes<HTMLElement>) {\n  return (\n    <div className={cn('flex items-center justify-between w-full', className)} {...props}>\n      {children}\n    </div>\n  )\n}\n\nexport function DashboardFooter({ children, className, ...props }: React.HTMLAttributes<HTMLElement>) {\n  return (\n    <div className={cn('flex items-center justify-between w-full', className)} {...props}>\n      {children}\n    </div>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/dashboard-sidebar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/mobile-navigation.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'index' is defined but never used.",
        "line": 124,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 124,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport React, { useState, useEffect, useRef, useCallback } from 'react'\nimport { cn } from '@/lib/utils'\nimport { useRouter, usePathname } from 'next/navigation'\nimport { TouchInteraction, useIsMobile } from '../mobile/touch-interactions'\nimport { MobileTooltip } from '../mobile/mobile-tooltip'\n\ninterface MobileNavigationItem {\n  id: string\n  label: string\n  href: string\n  icon: React.ComponentType<{ className?: string }>\n  badge?: string | number\n  disabled?: boolean\n}\n\ninterface MobileNavigationProps {\n  items: MobileNavigationItem[]\n  className?: string\n  onItemClick?: (item: MobileNavigationItem) => void\n}\n\nexport function MobileNavigation({\n  items,\n  className,\n  onItemClick,\n}: MobileNavigationProps) {\n  const router = useRouter()\n  const pathname = usePathname()\n  const isMobile = useIsMobile()\n  const [activeItem, setActiveItem] = useState<string>('')\n  const [isTransitioning, setIsTransitioning] = useState(false)\n  const navigationRef = useRef<HTMLElement>(null)\n\n  // Update active item based on current pathname\n  useEffect(() => {\n    const currentItem = items.find(item => \n      pathname === item.href || pathname.startsWith(item.href + '/')\n    )\n    if (currentItem) {\n      setActiveItem(currentItem.id)\n    }\n  }, [pathname, items])\n\n  const handleItemClick = useCallback((item: MobileNavigationItem) => {\n    if (item.disabled || isTransitioning) return\n    \n    setIsTransitioning(true)\n    setActiveItem(item.id)\n    onItemClick?.(item)\n    \n    if (item.href) {\n      router.push(item.href)\n      // Reset transition state after navigation\n      setTimeout(() => setIsTransitioning(false), 300)\n    } else {\n      setIsTransitioning(false)\n    }\n  }, [router, onItemClick, isTransitioning])\n\n  // Handle swipe navigation between sections\n  const handleSwipeLeft = useCallback(() => {\n    const currentIndex = items.findIndex(item => item.id === activeItem)\n    const nextIndex = (currentIndex + 1) % items.length\n    const nextItem = items[nextIndex]\n    \n    if (nextItem && !nextItem.disabled) {\n      handleItemClick(nextItem)\n    }\n  }, [items, activeItem, handleItemClick])\n\n  const handleSwipeRight = useCallback(() => {\n    const currentIndex = items.findIndex(item => item.id === activeItem)\n    const prevIndex = currentIndex === 0 ? items.length - 1 : currentIndex - 1\n    const prevItem = items[prevIndex]\n    \n    if (prevItem && !prevItem.disabled) {\n      handleItemClick(prevItem)\n    }\n  }, [items, activeItem, handleItemClick])\n\n  // Don't render on desktop\n  if (!isMobile) {\n    return null\n  }\n\n  return (\n    <TouchInteraction\n      onSwipeLeft={handleSwipeLeft}\n      onSwipeRight={handleSwipeRight}\n      swipeThreshold={50}\n      className=\"mobile-navigation-wrapper\"\n    >\n      <nav\n        ref={navigationRef}\n        className={cn(\n          'mobile-navigation',\n          'fixed',\n          'bottom-0',\n          'left-0',\n          'right-0',\n          'z-50',\n          'bg-dashboard-surface/95', // Semi-transparent for better visual hierarchy\n          'backdrop-blur-md', // Add blur effect\n          'border-t',\n          'border-dashboard-border',\n          'px-2',\n          'py-1',\n          'safe-area-inset-bottom', // Handle iPhone notch\n          // Smooth transitions\n          'transition-all',\n          'duration-300',\n          'ease-out',\n          // Shadow for depth\n          'shadow-lg',\n          'shadow-black/10',\n          className\n        )}\n        role=\"navigation\"\n        aria-label=\"Mobile navigation\"\n      >\n        <div className=\"flex items-center justify-around\">\n          {items.map((item, index) => {\n            const isActive = activeItem === item.id\n            const Icon = item.icon\n\n            const navButton = (\n              <button\n                key={item.id}\n                onClick={() => handleItemClick(item)}\n                disabled={item.disabled || isTransitioning}\n                className={cn(\n                  'mobile-nav-item',\n                  'flex',\n                  'flex-col',\n                  'items-center',\n                  'justify-center',\n                  'px-3',\n                  'py-2',\n                  'rounded-lg',\n                  'transition-all',\n                  'duration-200',\n                  'ease-in-out',\n                  'min-w-0',\n                  'flex-1',\n                  'max-w-20',\n                  'relative',\n                  // Minimum touch target size\n                  'min-h-[44px]',\n                  // Active state\n                  isActive && [\n                    'bg-dashboard-primary',\n                    'text-dashboard-text-inverse',\n                    'shadow-sm',\n                    'scale-105', // Slightly larger when active\n                  ],\n                  // Inactive state\n                  !isActive && [\n                    'text-dashboard-text-secondary',\n                    'hover:text-dashboard-text-primary',\n                    'hover:bg-dashboard-background/50',\n                    'active:scale-95', // Touch feedback\n                  ],\n                  // Disabled/transitioning state\n                  (item.disabled || isTransitioning) && [\n                    'opacity-50',\n                    'cursor-not-allowed',\n                    'hover:bg-transparent',\n                    'hover:text-dashboard-text-secondary'\n                  ],\n                  // Focus styles\n                  'focus:outline-none',\n                  'focus:ring-2',\n                  'focus:ring-dashboard-primary',\n                  'focus:ring-offset-2',\n                  'focus:ring-offset-dashboard-surface',\n                  // Touch optimizations\n                  'touch-manipulation',\n                  'select-none',\n                  '-webkit-tap-highlight-color: transparent'\n                )}\n                aria-label={item.label}\n                aria-current={isActive ? 'page' : undefined}\n                aria-describedby={`nav-item-${item.id}-description`}\n              >\n                {/* Icon */}\n                <div className=\"relative\">\n                  <Icon \n                    className={cn(\n                      'w-5 h-5',\n                      'transition-all',\n                      'duration-200',\n                      isActive && 'scale-110',\n                      isTransitioning && 'animate-pulse'\n                    )}\n                    aria-hidden=\"true\"\n                  />\n                  \n                  {/* Badge */}\n                  {item.badge && (\n                    <span\n                      className={cn(\n                        'absolute',\n                        '-top-1',\n                        '-right-1',\n                        'min-w-4',\n                        'h-4',\n                        'px-1',\n                        'text-xs',\n                        'font-medium',\n                        'text-white',\n                        'bg-dashboard-error',\n                        'rounded-full',\n                        'flex',\n                        'items-center',\n                        'justify-center',\n                        'leading-none',\n                        'animate-pulse'\n                      )}\n                      aria-label={`${item.badge} notifications`}\n                    >\n                      {typeof item.badge === 'number' && item.badge > 99 ? '99+' : item.badge}\n                    </span>\n                  )}\n                </div>\n                \n                {/* Label */}\n                <span\n                  className={cn(\n                    'text-xs',\n                    'font-medium',\n                    'mt-1',\n                    'truncate',\n                    'max-w-full',\n                    'transition-all',\n                    'duration-200',\n                    isActive && 'font-semibold'\n                  )}\n                >\n                  {item.label}\n                </span>\n\n                {/* Screen reader description */}\n                <span\n                  id={`nav-item-${item.id}-description`}\n                  className=\"sr-only\"\n                >\n                  {isActive ? `Current page: ${item.label}` : `Navigate to ${item.label}`}\n                  {item.badge ? `. ${item.badge} notifications` : ''}\n                </span>\n              </button>\n            )\n\n            // Wrap with tooltip for better accessibility on touch devices\n            return (\n              <MobileTooltip\n                key={item.id}\n                content={\n                  <div className=\"text-center\">\n                    <div className=\"font-medium\">{item.label}</div>\n                    {item.badge && (\n                      <div className=\"text-xs opacity-75 mt-1\">\n                        {item.badge} notifications\n                      </div>\n                    )}\n                  </div>\n                }\n                side=\"top\"\n                disabled={item.disabled}\n                tapToShow={false} // Only show on long press\n                delayDuration={500}\n              >\n                {navButton}\n              </MobileTooltip>\n            )\n          })}\n        </div>\n\n        {/* Swipe indicator */}\n        <div \n          className=\"absolute top-1 left-1/2 transform -translate-x-1/2 w-8 h-1 bg-dashboard-text-disabled/30 rounded-full\"\n          aria-hidden=\"true\"\n        />\n\n        {/* Navigation instructions for screen readers */}\n        <div className=\"sr-only\" aria-live=\"polite\">\n          Swipe left or right to navigate between sections. Current section: {\n            items.find(item => item.id === activeItem)?.label || 'Unknown'\n          }\n        </div>\n      </nav>\n    </TouchInteraction>\n  )\n}\n\n// Default navigation items for the dashboard\nexport const defaultMobileNavItems: MobileNavigationItem[] = [\n  {\n    id: 'dashboard',\n    label: 'Dashboard',\n    href: '/dashboard',\n    icon: ({ className }) => (\n      <svg className={className} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2-2z\" />\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 5a2 2 0 012-2h4a2 2 0 012 2v6H8V5z\" />\n      </svg>\n    ),\n  },\n  {\n    id: 'agents',\n    label: 'Agents',\n    href: '/dashboard/agents',\n    icon: ({ className }) => (\n      <svg className={className} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n      </svg>\n    ),\n  },\n  {\n    id: 'tasks',\n    label: 'Tasks',\n    href: '/dashboard/tasks',\n    icon: ({ className }) => (\n      <svg className={className} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01\" />\n      </svg>\n    ),\n  },\n  {\n    id: 'analytics',\n    label: 'Analytics',\n    href: '/dashboard/analytics',\n    icon: ({ className }) => (\n      <svg className={className} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\" />\n      </svg>\n    ),\n  },\n  {\n    id: 'settings',\n    label: 'Settings',\n    href: '/dashboard/settings',\n    icon: ({ className }) => (\n      <svg className={className} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n      </svg>\n    ),\n  },\n]\n\n// Hook for managing mobile navigation state\nexport function useMobileNavigation() {\n  const [isVisible, setIsVisible] = useState(false)\n  const [lastScrollY, setLastScrollY] = useState(0)\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const currentScrollY = window.scrollY\n      \n      // Show navigation when scrolling up, hide when scrolling down\n      if (currentScrollY < lastScrollY || currentScrollY < 100) {\n        setIsVisible(true)\n      } else {\n        setIsVisible(false)\n      }\n      \n      setLastScrollY(currentScrollY)\n    }\n\n    // Show navigation by default\n    setIsVisible(true)\n    \n    window.addEventListener('scroll', handleScroll, { passive: true })\n    return () => window.removeEventListener('scroll', handleScroll)\n  }, [lastScrollY])\n\n  return { isVisible, setIsVisible }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/layout/swipe-navigation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/mobile/__tests__/mobile-tooltip.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'user' is assigned a value but never used.",
        "line": 108,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 108,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'user' is assigned a value but never used.",
        "line": 139,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 139,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 258,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 258,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6731, 6734], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6731, 6734], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { MobileTooltip, ChartMobileTooltip } from '../mobile-tooltip'\nimport { useIsTouchDevice } from '../touch-interactions'\n\n// Mock the touch device hook\njest.mock('../touch-interactions', () => ({\n  useIsTouchDevice: jest.fn(),\n}))\n\nconst mockUseIsTouchDevice = useIsTouchDevice as jest.MockedFunction<typeof useIsTouchDevice>\n\ndescribe('MobileTooltip', () => {\n  beforeEach(() => {\n    mockUseIsTouchDevice.mockReturnValue(true)\n    jest.clearAllMocks()\n  })\n\n  it('renders trigger content correctly', () => {\n    render(\n      <MobileTooltip content=\"Tooltip content\">\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    expect(screen.getByText('Trigger')).toBeInTheDocument()\n  })\n\n  it('shows tooltip on touch for touch devices', async () => {\n    render(\n      <MobileTooltip content=\"Tooltip content\" tapToShow>\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    const trigger = screen.getByText('Trigger').parentElement!\n    \n    // Simulate touch start\n    fireEvent.touchStart(trigger)\n\n    await waitFor(() => {\n      expect(screen.getByText('Tooltip content')).toBeInTheDocument()\n    })\n  })\n\n  it('shows tooltip on hover for non-touch devices', async () => {\n    mockUseIsTouchDevice.mockReturnValue(false)\n    \n    render(\n      <MobileTooltip content=\"Tooltip content\">\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    const trigger = screen.getByText('Trigger').parentElement!\n    \n    fireEvent.mouseEnter(trigger)\n\n    await waitFor(() => {\n      expect(screen.getByText('Tooltip content')).toBeInTheDocument()\n    })\n  })\n\n  it('hides tooltip on touch when tapToHide is enabled', async () => {\n    render(\n      <MobileTooltip content=\"Tooltip content\" tapToShow tapToHide>\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    const trigger = screen.getByText('Trigger').parentElement!\n    \n    // Show tooltip\n    fireEvent.touchStart(trigger)\n    \n    await waitFor(() => {\n      expect(screen.getByText('Tooltip content')).toBeInTheDocument()\n    })\n\n    // Hide tooltip\n    fireEvent.touchStart(trigger)\n\n    await waitFor(() => {\n      expect(screen.queryByText('Tooltip content')).not.toBeInTheDocument()\n    })\n  })\n\n  it('shows tooltip on focus for keyboard accessibility', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <MobileTooltip content=\"Tooltip content\">\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    const wrapper = screen.getByText('Trigger').parentElement!\n    \n    await user.click(wrapper)\n\n    await waitFor(() => {\n      expect(screen.getByText('Tooltip content')).toBeInTheDocument()\n    })\n  })\n\n  it('hides tooltip on blur', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <div>\n        <MobileTooltip content=\"Tooltip content\">\n          <button>Trigger</button>\n        </MobileTooltip>\n        <button>Other button</button>\n      </div>\n    )\n\n    const wrapper = screen.getByText('Trigger').parentElement!\n    const otherButton = screen.getByRole('button', { name: 'Other button' })\n    \n    // Focus trigger to show tooltip\n    fireEvent.focus(wrapper)\n\n    await waitFor(() => {\n      expect(screen.getByText('Tooltip content')).toBeInTheDocument()\n    })\n\n    // Focus other button to hide tooltip\n    fireEvent.blur(wrapper)\n    fireEvent.focus(otherButton)\n\n    await waitFor(() => {\n      expect(screen.queryByText('Tooltip content')).not.toBeInTheDocument()\n    })\n  })\n\n  it('hides tooltip on escape key', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <MobileTooltip content=\"Tooltip content\">\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    const wrapper = screen.getByText('Trigger').parentElement!\n    \n    // Show tooltip\n    fireEvent.focus(wrapper)\n\n    await waitFor(() => {\n      expect(screen.getByText('Tooltip content')).toBeInTheDocument()\n    })\n\n    // Press escape\n    fireEvent.keyDown(wrapper, { key: 'Escape' })\n\n    await waitFor(() => {\n      expect(screen.queryByText('Tooltip content')).not.toBeInTheDocument()\n    })\n  })\n\n  it('respects disabled prop', async () => {\n    render(\n      <MobileTooltip content=\"Tooltip content\" disabled>\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    const wrapper = screen.getByText('Trigger').parentElement!\n    \n    fireEvent.touchStart(wrapper)\n    fireEvent.mouseEnter(wrapper)\n\n    // Wait a bit to ensure tooltip doesn't appear\n    await new Promise(resolve => setTimeout(resolve, 100))\n\n    expect(screen.queryByText('Tooltip content')).not.toBeInTheDocument()\n  })\n\n  it('applies custom positioning', async () => {\n    render(\n      <MobileTooltip content=\"Tooltip content\" side=\"bottom\" align=\"start\">\n        <button>Trigger</button>\n      </MobileTooltip>\n    )\n\n    const wrapper = screen.getByText('Trigger').parentElement!\n    \n    fireEvent.touchStart(wrapper)\n\n    await waitFor(() => {\n      const tooltip = screen.getByRole('tooltip')\n      expect(tooltip).toBeInTheDocument()\n    })\n  })\n\n  it('closes tooltip when clicking outside', async () => {\n    render(\n      <div>\n        <MobileTooltip content=\"Tooltip content\">\n          <button>Trigger</button>\n        </MobileTooltip>\n        <div data-testid=\"outside\">Outside</div>\n      </div>\n    )\n\n    const wrapper = screen.getByText('Trigger').parentElement!\n    const outside = screen.getByTestId('outside')\n    \n    // Show tooltip\n    fireEvent.touchStart(wrapper)\n\n    await waitFor(() => {\n      expect(screen.getByText('Tooltip content')).toBeInTheDocument()\n    })\n\n    // Click outside\n    fireEvent.mouseDown(outside)\n\n    await waitFor(() => {\n      expect(screen.queryByText('Tooltip content')).not.toBeInTheDocument()\n    })\n  })\n})\n\ndescribe('ChartMobileTooltip', () => {\n  beforeEach(() => {\n    mockUseIsTouchDevice.mockReturnValue(true)\n  })\n\n  it('renders with chart data', async () => {\n    const chartData = {\n      value: 100,\n      label: 'Test Data',\n    }\n\n    render(\n      <ChartMobileTooltip data={chartData}>\n        <div>Chart Element</div>\n      </ChartMobileTooltip>\n    )\n\n    const trigger = screen.getByText('Chart Element')\n    fireEvent.touchStart(trigger)\n\n    await waitFor(() => {\n      expect(screen.getByText('value:')).toBeInTheDocument()\n      expect(screen.getByText('100')).toBeInTheDocument()\n      expect(screen.getByText('label:')).toBeInTheDocument()\n      expect(screen.getByText('Test Data')).toBeInTheDocument()\n    })\n  })\n\n  it('uses custom formatter', async () => {\n    const chartData = { value: 100 }\n    const formatter = (data: any) => `Custom: ${data.value}`\n\n    render(\n      <ChartMobileTooltip data={chartData} formatter={formatter}>\n        <div>Chart Element</div>\n      </ChartMobileTooltip>\n    )\n\n    const trigger = screen.getByText('Chart Element')\n    fireEvent.touchStart(trigger)\n\n    await waitFor(() => {\n      expect(screen.getByText('Custom: 100')).toBeInTheDocument()\n    })\n  })\n\n  it('handles null data gracefully', () => {\n    render(\n      <ChartMobileTooltip data={null}>\n        <div>Chart Element</div>\n      </ChartMobileTooltip>\n    )\n\n    const trigger = screen.getByText('Chart Element')\n    fireEvent.touchStart(trigger)\n\n    // Should not show tooltip with null data\n    expect(screen.queryByRole('tooltip')).not.toBeInTheDocument()\n  })\n\n  it('handles primitive data types', async () => {\n    render(\n      <ChartMobileTooltip data=\"Simple string\">\n        <div>Chart Element</div>\n      </ChartMobileTooltip>\n    )\n\n    const trigger = screen.getByText('Chart Element')\n    fireEvent.touchStart(trigger)\n\n    await waitFor(() => {\n      expect(screen.getByText('Simple string')).toBeInTheDocument()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/mobile/__tests__/touch-interactions.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/mobile/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/mobile/mobile-tooltip.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 301,
        "column": 10,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 301,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8478, 8481], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8478, 8481], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 302,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 302,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8503, 8506], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8503, 8506], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useRef, useCallback } from 'react'\nimport { cn } from '@/lib/utils'\nimport { useIsTouchDevice } from './touch-interactions'\n\ninterface MobileTooltipProps {\n  children: React.ReactNode\n  content: React.ReactNode\n  side?: 'top' | 'bottom' | 'left' | 'right'\n  align?: 'start' | 'center' | 'end'\n  disabled?: boolean\n  className?: string\n  contentClassName?: string\n  delayDuration?: number\n  tapToShow?: boolean\n  tapToHide?: boolean\n}\n\nexport function MobileTooltip({\n  children,\n  content,\n  side = 'top',\n  align = 'center',\n  disabled = false,\n  className,\n  contentClassName,\n  delayDuration = 0,\n  tapToShow = true,\n  tapToHide = true,\n}: MobileTooltipProps) {\n  const [isVisible, setIsVisible] = useState(false)\n  const [position, setPosition] = useState({ x: 0, y: 0 })\n  const triggerRef = useRef<HTMLDivElement>(null)\n  const tooltipRef = useRef<HTMLDivElement>(null)\n  const timeoutRef = useRef<NodeJS.Timeout>()\n  const isTouchDevice = useIsTouchDevice()\n\n  // Calculate tooltip position\n  const calculatePosition = useCallback(() => {\n    if (!triggerRef.current || !tooltipRef.current) return\n\n    const triggerRect = triggerRef.current.getBoundingClientRect()\n    const tooltipRect = tooltipRef.current.getBoundingClientRect()\n    const viewport = {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    }\n\n    let x = 0\n    let y = 0\n\n    // Calculate base position based on side\n    switch (side) {\n      case 'top':\n        x = triggerRect.left + triggerRect.width / 2\n        y = triggerRect.top - tooltipRect.height - 8\n        break\n      case 'bottom':\n        x = triggerRect.left + triggerRect.width / 2\n        y = triggerRect.bottom + 8\n        break\n      case 'left':\n        x = triggerRect.left - tooltipRect.width - 8\n        y = triggerRect.top + triggerRect.height / 2\n        break\n      case 'right':\n        x = triggerRect.right + 8\n        y = triggerRect.top + triggerRect.height / 2\n        break\n    }\n\n    // Adjust for alignment\n    if (side === 'top' || side === 'bottom') {\n      switch (align) {\n        case 'start':\n          x = triggerRect.left\n          break\n        case 'end':\n          x = triggerRect.right - tooltipRect.width\n          break\n        case 'center':\n        default:\n          x = triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2\n          break\n      }\n    } else {\n      switch (align) {\n        case 'start':\n          y = triggerRect.top\n          break\n        case 'end':\n          y = triggerRect.bottom - tooltipRect.height\n          break\n        case 'center':\n        default:\n          y = triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2\n          break\n      }\n    }\n\n    // Keep tooltip within viewport bounds\n    x = Math.max(8, Math.min(x, viewport.width - tooltipRect.width - 8))\n    y = Math.max(8, Math.min(y, viewport.height - tooltipRect.height - 8))\n\n    setPosition({ x, y })\n  }, [side, align])\n\n  // Show tooltip\n  const showTooltip = useCallback(() => {\n    if (disabled) return\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current)\n    }\n\n    if (delayDuration > 0) {\n      timeoutRef.current = setTimeout(() => {\n        setIsVisible(true)\n        // Calculate position after showing to get accurate measurements\n        requestAnimationFrame(calculatePosition)\n      }, delayDuration)\n    } else {\n      setIsVisible(true)\n      requestAnimationFrame(calculatePosition)\n    }\n  }, [disabled, delayDuration, calculatePosition])\n\n  // Hide tooltip\n  const hideTooltip = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current)\n    }\n    setIsVisible(false)\n  }, [])\n\n  // Handle mouse events for non-touch devices\n  const handleMouseEnter = useCallback(() => {\n    if (!isTouchDevice) {\n      showTooltip()\n    }\n  }, [isTouchDevice, showTooltip])\n\n  const handleMouseLeave = useCallback(() => {\n    if (!isTouchDevice) {\n      hideTooltip()\n    }\n  }, [isTouchDevice, hideTooltip])\n\n  // Handle touch/click events\n  const handleTouchStart = useCallback((event: React.TouchEvent) => {\n    if (!isTouchDevice || !tapToShow) return\n    \n    event.preventDefault()\n    \n    if (isVisible && tapToHide) {\n      hideTooltip()\n    } else {\n      showTooltip()\n    }\n  }, [isTouchDevice, tapToShow, tapToHide, isVisible, showTooltip, hideTooltip])\n\n  const handleClick = useCallback((event: React.MouseEvent) => {\n    if (isTouchDevice) return // Touch events handle this\n    \n    if (tapToShow) {\n      event.preventDefault()\n      \n      if (isVisible && tapToHide) {\n        hideTooltip()\n      } else {\n        showTooltip()\n      }\n    }\n  }, [isTouchDevice, tapToShow, tapToHide, isVisible, showTooltip, hideTooltip])\n\n  // Handle focus events for keyboard accessibility\n  const handleFocus = useCallback(() => {\n    showTooltip()\n  }, [showTooltip])\n\n  const handleBlur = useCallback(() => {\n    hideTooltip()\n  }, [hideTooltip])\n\n  // Handle escape key\n  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {\n    if (event.key === 'Escape' && isVisible) {\n      hideTooltip()\n    }\n  }, [isVisible, hideTooltip])\n\n  // Close tooltip when clicking outside\n  React.useEffect(() => {\n    if (!isVisible) return\n\n    const handleClickOutside = (event: MouseEvent | TouchEvent) => {\n      if (\n        triggerRef.current &&\n        tooltipRef.current &&\n        !triggerRef.current.contains(event.target as Node) &&\n        !tooltipRef.current.contains(event.target as Node)\n      ) {\n        hideTooltip()\n      }\n    }\n\n    document.addEventListener('mousedown', handleClickOutside)\n    document.addEventListener('touchstart', handleClickOutside)\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside)\n      document.removeEventListener('touchstart', handleClickOutside)\n    }\n  }, [isVisible, hideTooltip])\n\n  // Clean up timeout on unmount\n  React.useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n    }\n  }, [])\n\n  return (\n    <>\n      <div\n        ref={triggerRef}\n        className={cn(\n          'mobile-tooltip-trigger',\n          isTouchDevice && 'cursor-pointer',\n          className\n        )}\n        onMouseEnter={handleMouseEnter}\n        onMouseLeave={handleMouseLeave}\n        onTouchStart={handleTouchStart}\n        onClick={handleClick}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        onKeyDown={handleKeyDown}\n        tabIndex={0}\n        role=\"button\"\n        aria-describedby={isVisible ? 'mobile-tooltip-content' : undefined}\n        aria-expanded={isVisible}\n      >\n        {children}\n      </div>\n\n      {/* Tooltip content */}\n      {isVisible && (\n        <div\n          ref={tooltipRef}\n          id=\"mobile-tooltip-content\"\n          className={cn(\n            'mobile-tooltip-content',\n            'fixed z-50 px-3 py-2 text-sm',\n            'bg-gray-900 text-white rounded-md shadow-lg',\n            'dark:bg-gray-100 dark:text-gray-900',\n            'max-w-xs break-words',\n            // Animation classes\n            'animate-in fade-in-0 zoom-in-95',\n            'data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95',\n            // Side-specific animations\n            side === 'top' && 'slide-in-from-bottom-2',\n            side === 'bottom' && 'slide-in-from-top-2',\n            side === 'left' && 'slide-in-from-right-2',\n            side === 'right' && 'slide-in-from-left-2',\n            contentClassName\n          )}\n          style={{\n            left: `${position.x}px`,\n            top: `${position.y}px`,\n          }}\n          role=\"tooltip\"\n          aria-live=\"polite\"\n        >\n          {content}\n          \n          {/* Tooltip arrow */}\n          <div\n            className={cn(\n              'absolute w-2 h-2 bg-gray-900 dark:bg-gray-100 rotate-45',\n              side === 'top' && 'bottom-[-4px] left-1/2 transform -translate-x-1/2',\n              side === 'bottom' && 'top-[-4px] left-1/2 transform -translate-x-1/2',\n              side === 'left' && 'right-[-4px] top-1/2 transform -translate-y-1/2',\n              side === 'right' && 'left-[-4px] top-1/2 transform -translate-y-1/2'\n            )}\n          />\n        </div>\n      )}\n    </>\n  )\n}\n\n// Utility component for chart tooltips\nexport function ChartMobileTooltip({\n  children,\n  data,\n  formatter,\n  ...props\n}: Omit<MobileTooltipProps, 'content'> & {\n  data?: any\n  formatter?: (data: any) => React.ReactNode\n}) {\n  const content = React.useMemo(() => {\n    if (!data) return null\n    \n    if (formatter) {\n      return formatter(data)\n    }\n    \n    // Default formatting for chart data\n    if (typeof data === 'object' && data !== null) {\n      return (\n        <div className=\"space-y-1\">\n          {Object.entries(data).map(([key, value]) => (\n            <div key={key} className=\"flex justify-between gap-2\">\n              <span className=\"font-medium\">{key}:</span>\n              <span>{String(value)}</span>\n            </div>\n          ))}\n        </div>\n      )\n    }\n    \n    return String(data)\n  }, [data, formatter])\n\n  if (!content) {\n    return <>{children}</>\n  }\n\n  return (\n    <MobileTooltip content={content} {...props}>\n      {children}\n    </MobileTooltip>\n  )\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/mobile/touch-interactions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/__tests__/core-web-vitals.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'callback' is defined but never used.",
        "line": 17,
        "column": 45,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 17,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 165,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 165,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4922, 4925], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4922, 4925], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen } from '@testing-library/react'\nimport { jest } from '@jest/globals'\nimport {\n  useCoreWebVitals,\n  getPerformanceRating,\n  PERFORMANCE_THRESHOLDS,\n  PerformanceMonitor,\n  PerformanceDashboard,\n  useComponentPerformance,\n  usePerformanceBudget,\n  useRealUserMonitoring,\n} from '../core-web-vitals'\n\n// Mock PerformanceObserver\nconst mockPerformanceObserver = jest.fn()\nmockPerformanceObserver.mockImplementation((callback) => ({\n  observe: jest.fn(),\n  disconnect: jest.fn(),\n}))\n\nObject.defineProperty(window, 'PerformanceObserver', {\n  value: mockPerformanceObserver,\n  writable: true,\n})\n\n// Mock performance API\nObject.defineProperty(window, 'performance', {\n  value: {\n    now: jest.fn(() => Date.now()),\n    getEntriesByType: jest.fn(() => []),\n    getEntriesByName: jest.fn(() => []),\n    mark: jest.fn(),\n    measure: jest.fn(),\n  },\n  writable: true,\n})\n\n// Mock fetch\nglobal.fetch = jest.fn(() =>\n  Promise.resolve({\n    ok: true,\n    json: () => Promise.resolve({}),\n  })\n) as jest.Mock\n\ndescribe('Core Web Vitals', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('getPerformanceRating', () => {\n    it('should return correct ratings for LCP', () => {\n      expect(getPerformanceRating('lcp', 2000)).toBe('good')\n      expect(getPerformanceRating('lcp', 3000)).toBe('needs-improvement')\n      expect(getPerformanceRating('lcp', 5000)).toBe('poor')\n    })\n\n    it('should return correct ratings for FID', () => {\n      expect(getPerformanceRating('fid', 50)).toBe('good')\n      expect(getPerformanceRating('fid', 200)).toBe('needs-improvement')\n      expect(getPerformanceRating('fid', 400)).toBe('poor')\n    })\n\n    it('should return correct ratings for CLS', () => {\n      expect(getPerformanceRating('cls', 0.05)).toBe('good')\n      expect(getPerformanceRating('cls', 0.15)).toBe('needs-improvement')\n      expect(getPerformanceRating('cls', 0.3)).toBe('poor')\n    })\n  })\n\n  describe('useCoreWebVitals', () => {\n    const TestComponent = () => {\n      const metrics = useCoreWebVitals()\n      \n      return (\n        <div>\n          <div data-testid=\"lcp\">{metrics.lcp || 'N/A'}</div>\n          <div data-testid=\"fid\">{metrics.fid || 'N/A'}</div>\n          <div data-testid=\"cls\">{metrics.cls || 'N/A'}</div>\n        </div>\n      )\n    }\n\n    it('should initialize with empty metrics', () => {\n      render(<TestComponent />)\n      \n      expect(screen.getByTestId('lcp')).toHaveTextContent('N/A')\n      expect(screen.getByTestId('fid')).toHaveTextContent('N/A')\n      expect(screen.getByTestId('cls')).toHaveTextContent('N/A')\n    })\n\n    it('should set up performance observers', () => {\n      render(<TestComponent />)\n      \n      // Should attempt to create observers for different metrics\n      expect(mockPerformanceObserver).toHaveBeenCalled()\n    })\n  })\n\n  describe('PerformanceMonitor', () => {\n    it('should render children and monitor performance', () => {\n      const onMetricsUpdate = jest.fn()\n      \n      render(\n        <PerformanceMonitor onMetricsUpdate={onMetricsUpdate}>\n          <div data-testid=\"child\">Child content</div>\n        </PerformanceMonitor>\n      )\n      \n      expect(screen.getByTestId('child')).toHaveTextContent('Child content')\n    })\n  })\n\n  describe('PerformanceDashboard', () => {\n    it('should not render in production by default', () => {\n      const originalEnv = process.env.NODE_ENV\n      process.env.NODE_ENV = 'production'\n      \n      render(<PerformanceDashboard />)\n      \n      // Should not render dashboard in production\n      expect(screen.queryByText('Core Web Vitals')).not.toBeInTheDocument()\n      \n      process.env.NODE_ENV = originalEnv\n    })\n\n    it('should render in development', () => {\n      const originalEnv = process.env.NODE_ENV\n      process.env.NODE_ENV = 'development'\n      \n      render(<PerformanceDashboard />)\n      \n      // Should render dashboard in development\n      expect(screen.getByText('Core Web Vitals')).toBeInTheDocument()\n      \n      process.env.NODE_ENV = originalEnv\n    })\n  })\n\n  describe('useComponentPerformance', () => {\n    const TestComponent = ({ name }: { name: string }) => {\n      const { renderCount, mountTime } = useComponentPerformance(name)\n      \n      return (\n        <div>\n          <div data-testid=\"render-count\">{renderCount}</div>\n          <div data-testid=\"mount-time\">{mountTime}</div>\n        </div>\n      )\n    }\n\n    it('should track component performance', () => {\n      const { rerender } = render(<TestComponent name=\"TestComponent\" />)\n      \n      expect(screen.getByTestId('render-count')).toHaveTextContent('1')\n      \n      // Re-render should increment count\n      rerender(<TestComponent name=\"TestComponent\" />)\n      expect(screen.getByTestId('render-count')).toHaveTextContent('2')\n    })\n  })\n\n  describe('usePerformanceBudget', () => {\n    const TestComponent = ({ budgets }: { budgets: any }) => {\n      const { violations, isWithinBudget } = usePerformanceBudget(budgets)\n      \n      return (\n        <div>\n          <div data-testid=\"within-budget\">{isWithinBudget.toString()}</div>\n          <div data-testid=\"violations\">{violations.length}</div>\n        </div>\n      )\n    }\n\n    it('should check performance budget', () => {\n      const budgets = {\n        lcp: 2000,\n        fid: 100,\n        cls: 0.1,\n      }\n      \n      render(<TestComponent budgets={budgets} />)\n      \n      // Should start within budget (no metrics yet)\n      expect(screen.getByTestId('within-budget')).toHaveTextContent('true')\n      expect(screen.getByTestId('violations')).toHaveTextContent('0')\n    })\n  })\n\n  describe('useRealUserMonitoring', () => {\n    const TestComponent = () => {\n      const rumData = useRealUserMonitoring()\n      \n      return (\n        <div>\n          <div data-testid=\"rum-data\">\n            {rumData ? 'Has Data' : 'No Data'}\n          </div>\n        </div>\n      )\n    }\n\n    it('should collect RUM data', () => {\n      // Mock navigation timing\n      Object.defineProperty(window.performance, 'getEntriesByType', {\n        value: jest.fn((type) => {\n          if (type === 'navigation') {\n            return [{\n              navigationStart: 0,\n              loadEventEnd: 1000,\n              domContentLoadedEventEnd: 500,\n            }]\n          }\n          if (type === 'resource') {\n            return [\n              { name: 'script.js', duration: 100 },\n              { name: 'style.css', duration: 50 },\n            ]\n          }\n          return []\n        }),\n        writable: true,\n      })\n      \n      render(<TestComponent />)\n      \n      // Should collect RUM data\n      expect(screen.getByTestId('rum-data')).toHaveTextContent('Has Data')\n    })\n  })\n\n  describe('PERFORMANCE_THRESHOLDS', () => {\n    it('should have correct threshold values', () => {\n      expect(PERFORMANCE_THRESHOLDS.lcp.good).toBe(2500)\n      expect(PERFORMANCE_THRESHOLDS.lcp.needsImprovement).toBe(4000)\n      \n      expect(PERFORMANCE_THRESHOLDS.fid.good).toBe(100)\n      expect(PERFORMANCE_THRESHOLDS.fid.needsImprovement).toBe(300)\n      \n      expect(PERFORMANCE_THRESHOLDS.cls.good).toBe(0.1)\n      expect(PERFORMANCE_THRESHOLDS.cls.needsImprovement).toBe(0.25)\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/__tests__/dynamic-imports.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 17,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 17,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [487, 490], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [487, 490], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 21,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 21,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [657, 660], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [657, 660], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 25,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 25,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [825, 828], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [825, 828], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 29,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 29,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1001, 1004], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1001, 1004], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 113,
        "column": 75,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 113,
        "endColumn": 78,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3555, 3558], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3555, 3558], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 207,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 207,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6588, 6591], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6588, 6591], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 212,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 212,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6697, 6700], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6697, 6700], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 235,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 235,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7362, 7365], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7362, 7365], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 256,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 256,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7964, 7967], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7964, 7967], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport { jest } from '@jest/globals'\nimport {\n  createDynamicChart,\n  withDynamicLoading,\n  DynamicAnalyticsDashboard,\n  DynamicPerformanceCharts,\n  DynamicTaskBoard,\n  preloadChartComponents,\n  preloadDashboardComponents,\n  trackDynamicImportPerformance,\n} from '../dynamic-imports'\n\n// Mock the chart components\njest.mock('../../charts/chart-types/line-chart', () => ({\n  LineChart: ({ data }: any) => <div data-testid=\"line-chart\">Line Chart: {data?.datasets?.[0]?.label}</div>\n}))\n\njest.mock('../../charts/chart-types/bar-chart', () => ({\n  BarChart: ({ data }: any) => <div data-testid=\"bar-chart\">Bar Chart: {data?.datasets?.[0]?.label}</div>\n}))\n\njest.mock('../../charts/chart-types/pie-chart', () => ({\n  PieChart: ({ data }: any) => <div data-testid=\"pie-chart\">Pie Chart: {data?.datasets?.[0]?.label}</div>\n}))\n\njest.mock('../../charts/chart-types/heatmap-chart', () => ({\n  HeatmapChart: ({ data }: any) => <div data-testid=\"heatmap-chart\">Heatmap Chart: {data?.datasets?.[0]?.label}</div>\n}))\n\n// Mock other components\njest.mock('../../../analytics/analytics-dashboard', () => ({\n  AnalyticsDashboard: () => <div data-testid=\"analytics-dashboard\">Analytics Dashboard</div>\n}))\n\njest.mock('../../../analytics/performance-charts', () => ({\n  PerformanceCharts: () => <div data-testid=\"performance-charts\">Performance Charts</div>\n}))\n\njest.mock('../../../kanban/task-board', () => ({\n  TaskBoard: () => <div data-testid=\"task-board\">Task Board</div>\n}))\n\nconst mockChartData = {\n  datasets: [\n    {\n      label: 'Test Dataset',\n      data: [\n        { x: 1, y: 10 },\n        { x: 2, y: 20 },\n        { x: 3, y: 15 },\n      ],\n    },\n  ],\n}\n\ndescribe('Dynamic Imports', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  describe('createDynamicChart', () => {\n    it('should create line chart component', async () => {\n      const DynamicLineChart = createDynamicChart('line')\n      \n      render(<DynamicLineChart data={mockChartData} />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('line-chart')).toBeInTheDocument()\n      })\n      \n      expect(screen.getByText('Line Chart: Test Dataset')).toBeInTheDocument()\n    })\n\n    it('should create bar chart component', async () => {\n      const DynamicBarChart = createDynamicChart('bar')\n      \n      render(<DynamicBarChart data={mockChartData} />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('bar-chart')).toBeInTheDocument()\n      })\n      \n      expect(screen.getByText('Bar Chart: Test Dataset')).toBeInTheDocument()\n    })\n\n    it('should create pie chart component', async () => {\n      const DynamicPieChart = createDynamicChart('pie')\n      \n      render(<DynamicPieChart data={mockChartData} />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('pie-chart')).toBeInTheDocument()\n      })\n      \n      expect(screen.getByText('Pie Chart: Test Dataset')).toBeInTheDocument()\n    })\n\n    it('should create heatmap chart component', async () => {\n      const DynamicHeatmapChart = createDynamicChart('heatmap')\n      \n      render(<DynamicHeatmapChart data={mockChartData} />)\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('heatmap-chart')).toBeInTheDocument()\n      })\n      \n      expect(screen.getByText('Heatmap Chart: Test Dataset')).toBeInTheDocument()\n    })\n\n    it('should handle unsupported chart types', () => {\n      const DynamicUnsupportedChart = createDynamicChart('unsupported' as any)\n      \n      render(<DynamicUnsupportedChart data={mockChartData} />)\n      \n      expect(screen.getByText('Chart failed to load')).toBeInTheDocument()\n    })\n\n    it('should show loading fallback while chart loads', () => {\n      const DynamicLineChart = createDynamicChart('line')\n      \n      render(<DynamicLineChart data={mockChartData} fallbackHeight={400} />)\n      \n      // Should show skeleton loading state initially\n      expect(screen.getByRole('status')).toBeInTheDocument()\n    })\n  })\n\n  describe('withDynamicLoading', () => {\n    it('should wrap component with dynamic loading', async () => {\n      const TestComponent = ({ message }: { message: string }) => (\n        <div data-testid=\"test-component\">{message}</div>\n      )\n\n      const DynamicTestComponent = withDynamicLoading(\n        () => Promise.resolve({ default: TestComponent }),\n        <div data-testid=\"loading\">Loading...</div>,\n        <div data-testid=\"error\">Error loading component</div>\n      )\n\n      render(<DynamicTestComponent message=\"Hello World\" />)\n\n      // Should show loading state initially\n      expect(screen.getByTestId('loading')).toBeInTheDocument()\n\n      // Should show component after loading\n      await waitFor(() => {\n        expect(screen.getByTestId('test-component')).toBeInTheDocument()\n      })\n\n      expect(screen.getByText('Hello World')).toBeInTheDocument()\n    })\n\n    it('should show error fallback on import failure', async () => {\n      const DynamicFailingComponent = withDynamicLoading(\n        () => Promise.reject(new Error('Import failed')),\n        <div data-testid=\"loading\">Loading...</div>,\n        <div data-testid=\"error\">Error loading component</div>\n      )\n\n      render(<DynamicFailingComponent />)\n\n      // Should show loading state initially\n      expect(screen.getByTestId('loading')).toBeInTheDocument()\n\n      // Should show error state after failure\n      await waitFor(() => {\n        expect(screen.getByTestId('error')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Pre-configured Dynamic Components', () => {\n    it('should render DynamicAnalyticsDashboard', async () => {\n      render(<DynamicAnalyticsDashboard />)\n\n      await waitFor(() => {\n        expect(screen.getByTestId('analytics-dashboard')).toBeInTheDocument()\n      })\n    })\n\n    it('should render DynamicPerformanceCharts', async () => {\n      render(<DynamicPerformanceCharts />)\n\n      await waitFor(() => {\n        expect(screen.getByTestId('performance-charts')).toBeInTheDocument()\n      })\n    })\n\n    it('should render DynamicTaskBoard', async () => {\n      render(<DynamicTaskBoard />)\n\n      await waitFor(() => {\n        expect(screen.getByTestId('task-board')).toBeInTheDocument()\n      })\n    })\n  })\n\n  describe('Preloading Functions', () => {\n    it('should preload chart components', () => {\n      // Mock dynamic import\n      const mockImport = jest.fn(() => Promise.resolve({}))\n      \n      // Replace global import with mock\n      const originalImport = global.import\n      ;(global as any).import = mockImport\n\n      preloadChartComponents()\n\n      // Restore original import\n      ;(global as any).import = originalImport\n\n      // Note: In a real test environment, we would verify that the imports were called\n      // but since we're mocking, we just ensure the function doesn't throw\n      expect(preloadChartComponents).not.toThrow()\n    })\n\n    it('should preload dashboard components', () => {\n      expect(preloadDashboardComponents).not.toThrow()\n    })\n  })\n\n  describe('Performance Tracking', () => {\n    beforeEach(() => {\n      // Mock performance API\n      Object.defineProperty(window, 'performance', {\n        value: {\n          now: jest.fn(() => Date.now()),\n        },\n        writable: true,\n      })\n\n      // Mock gtag\n      ;(window as any).gtag = jest.fn()\n    })\n\n    it('should track dynamic import performance', () => {\n      const mockNow = jest.fn()\n        .mockReturnValueOnce(1000) // start time\n        .mockReturnValueOnce(1150) // end time\n\n      Object.defineProperty(window, 'performance', {\n        value: { now: mockNow },\n        writable: true,\n      })\n\n      const tracker = trackDynamicImportPerformance('test-component')\n      tracker.end()\n\n      expect(mockNow).toHaveBeenCalledTimes(2)\n    })\n\n    it('should send analytics data when gtag is available', () => {\n      const mockGtag = jest.fn()\n      ;(window as any).gtag = mockGtag\n\n      const mockNow = jest.fn()\n        .mockReturnValueOnce(1000)\n        .mockReturnValueOnce(1200)\n\n      Object.defineProperty(window, 'performance', {\n        value: { now: mockNow },\n        writable: true,\n      })\n\n      const tracker = trackDynamicImportPerformance('test-component')\n      tracker.end()\n\n      expect(mockGtag).toHaveBeenCalledWith('event', 'dynamic_import_performance', {\n        component_name: 'test-component',\n        load_time: 200,\n      })\n    })\n\n    it('should handle missing performance API gracefully', () => {\n      // Remove performance API\n      Object.defineProperty(window, 'performance', {\n        value: undefined,\n        writable: true,\n      })\n\n      const tracker = trackDynamicImportPerformance('test-component')\n      \n      expect(() => tracker.end()).not.toThrow()\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/__tests__/lazy-card.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 315,
        "column": 60,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 315,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8022, 8025], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8022, 8025], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport { jest } from '@jest/globals'\nimport {\n  LazyCard,\n  withLazyLoading,\n  useLazyLoading,\n} from '../lazy-card'\n\n// Mock IntersectionObserver\nconst mockIntersectionObserver = jest.fn()\nmockIntersectionObserver.mockReturnValue({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn(),\n})\n\nObject.defineProperty(window, 'IntersectionObserver', {\n  writable: true,\n  configurable: true,\n  value: mockIntersectionObserver,\n})\n\nObject.defineProperty(global, 'IntersectionObserver', {\n  writable: true,\n  configurable: true,\n  value: mockIntersectionObserver,\n})\n\nconst TestComponent = ({ message }: { message: string }) => (\n  <div data-testid=\"test-component\">{message}</div>\n)\n\ndescribe('LazyCard', () => {\n  let mockObserve: jest.Mock\n  let mockDisconnect: jest.Mock\n  let mockCallback: (entries: IntersectionObserverEntry[]) => void\n\n  beforeEach(() => {\n    mockObserve = jest.fn()\n    mockDisconnect = jest.fn()\n    mockCallback = jest.fn()\n    \n    mockIntersectionObserver.mockImplementation((callback) => {\n      mockCallback = callback\n      return {\n        observe: mockObserve,\n        unobserve: jest.fn(),\n        disconnect: mockDisconnect,\n      }\n    })\n  })\n\n  afterEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('should show skeleton initially when not intersecting', () => {\n    render(\n      <LazyCard minHeight={300}>\n        <TestComponent message=\"Lazy content\" />\n      </LazyCard>\n    )\n\n    expect(screen.getByRole('status')).toBeInTheDocument()\n    expect(screen.getByLabelText('Loading card content')).toBeInTheDocument()\n    expect(screen.queryByTestId('test-component')).not.toBeInTheDocument()\n  })\n\n  it('should load content when intersecting', async () => {\n    const onIntersect = jest.fn()\n    const onLoad = jest.fn()\n\n    render(\n      <LazyCard\n        onIntersect={onIntersect}\n        onLoad={onLoad}\n      >\n        <TestComponent message=\"Lazy content\" />\n      </LazyCard>\n    )\n\n    // Simulate intersection\n    const mockEntry = {\n      isIntersecting: true,\n      target: document.createElement('div'),\n    } as IntersectionObserverEntry\n\n    act(() => {\n      mockCallback([mockEntry])\n    })\n\n    await waitFor(() => {\n      expect(onIntersect).toHaveBeenCalled()\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('test-component')).toBeInTheDocument()\n    })\n\n    expect(screen.getByText('Lazy content')).toBeInTheDocument()\n  })\n\n  it('should apply priority-based loading delays', async () => {\n    jest.useFakeTimers()\n\n    const onIntersect = jest.fn()\n\n    render(\n      <LazyCard priority=\"critical\" onIntersect={onIntersect}>\n        <TestComponent message=\"Critical content\" />\n      </LazyCard>\n    )\n\n    // Simulate intersection\n    const mockEntry = {\n      isIntersecting: true,\n      target: document.createElement('div'),\n    } as IntersectionObserverEntry\n\n    act(() => {\n      mockCallback([mockEntry])\n    })\n\n    // Critical priority should have no delay\n    await waitFor(() => {\n      expect(onIntersect).toHaveBeenCalled()\n    })\n\n    jest.useRealTimers()\n  })\n\n  it('should apply high priority delay', async () => {\n    jest.useFakeTimers()\n\n    const onIntersect = jest.fn()\n\n    render(\n      <LazyCard priority=\"high\" onIntersect={onIntersect}>\n        <TestComponent message=\"High priority content\" />\n      </LazyCard>\n    )\n\n    const mockEntry = {\n      isIntersecting: true,\n      target: document.createElement('div'),\n    } as IntersectionObserverEntry\n\n    mockCallback([mockEntry])\n\n    // Should not be called immediately\n    expect(onIntersect).not.toHaveBeenCalled()\n\n    // Should be called after 50ms delay\n    jest.advanceTimersByTime(50)\n    expect(onIntersect).toHaveBeenCalled()\n\n    jest.useRealTimers()\n  })\n\n  it('should apply low priority delay', async () => {\n    jest.useFakeTimers()\n\n    const onIntersect = jest.fn()\n\n    render(\n      <LazyCard priority=\"low\" onIntersect={onIntersect}>\n        <TestComponent message=\"Low priority content\" />\n      </LazyCard>\n    )\n\n    const mockEntry = {\n      isIntersecting: true,\n      target: document.createElement('div'),\n    } as IntersectionObserverEntry\n\n    mockCallback([mockEntry])\n\n    // Should not be called immediately\n    expect(onIntersect).not.toHaveBeenCalled()\n\n    // Should be called after 200ms delay\n    jest.advanceTimersByTime(200)\n    expect(onIntersect).toHaveBeenCalled()\n\n    jest.useRealTimers()\n  })\n\n  it('should use custom fallback component', () => {\n    const customFallback = <div data-testid=\"custom-fallback\">Custom loading...</div>\n\n    render(\n      <LazyCard fallback={customFallback}>\n        <TestComponent message=\"Content\" />\n      </LazyCard>\n    )\n\n    expect(screen.getByTestId('custom-fallback')).toBeInTheDocument()\n    expect(screen.getByText('Custom loading...')).toBeInTheDocument()\n  })\n\n  it('should apply custom root margin and threshold', () => {\n    render(\n      <LazyCard\n        rootMargin=\"100px\"\n        threshold={0.5}\n      >\n        <TestComponent message=\"Content\" />\n      </LazyCard>\n    )\n\n    expect(mockIntersectionObserver).toHaveBeenCalledWith(\n      expect.any(Function),\n      {\n        rootMargin: '100px',\n        threshold: 0.5,\n      }\n    )\n  })\n\n  it('should disconnect observer after intersection', async () => {\n    render(\n      <LazyCard>\n        <TestComponent message=\"Content\" />\n      </LazyCard>\n    )\n\n    const mockEntry = {\n      isIntersecting: true,\n      target: document.createElement('div'),\n    } as IntersectionObserverEntry\n\n    mockCallback([mockEntry])\n\n    await waitFor(() => {\n      expect(mockDisconnect).toHaveBeenCalled()\n    })\n  })\n\n  it('should apply priority-based CSS classes', () => {\n    const { container } = render(\n      <LazyCard priority=\"critical\" className=\"custom-class\">\n        <TestComponent message=\"Content\" />\n      </LazyCard>\n    )\n\n    const lazyContainer = container.firstChild as HTMLElement\n    expect(lazyContainer).toHaveClass('lazy-card-container')\n    expect(lazyContainer).toHaveClass('lazy-card-critical')\n    expect(lazyContainer).toHaveClass('custom-class')\n  })\n\n  it('should set minimum height correctly', () => {\n    const { container } = render(\n      <LazyCard minHeight={400}>\n        <TestComponent message=\"Content\" />\n      </LazyCard>\n    )\n\n    const lazyContainer = container.firstChild as HTMLElement\n    expect(lazyContainer).toHaveStyle('min-height: 400px')\n  })\n})\n\ndescribe('withLazyLoading', () => {\n  it('should wrap component with lazy loading', async () => {\n    const LazyTestComponent = withLazyLoading(TestComponent, {\n      priority: 'high',\n      minHeight: 250,\n    })\n\n    render(<LazyTestComponent message=\"Wrapped content\" />)\n\n    // Should show skeleton initially\n    expect(screen.getByRole('status')).toBeInTheDocument()\n\n    // Simulate intersection\n    const mockEntry = {\n      isIntersecting: true,\n      target: document.createElement('div'),\n    } as IntersectionObserverEntry\n\n    mockCallback([mockEntry])\n\n    await waitFor(() => {\n      expect(screen.getByTestId('test-component')).toBeInTheDocument()\n    })\n\n    expect(screen.getByText('Wrapped content')).toBeInTheDocument()\n  })\n\n  it('should preserve component display name', () => {\n    const NamedComponent = ({ message }: { message: string }) => (\n      <div>{message}</div>\n    )\n    NamedComponent.displayName = 'NamedComponent'\n\n    const LazyNamedComponent = withLazyLoading(NamedComponent)\n\n    expect(LazyNamedComponent.displayName).toBe('LazyLoaded(NamedComponent)')\n  })\n\n  it('should handle component without display name', () => {\n    const AnonymousComponent = ({ message }: { message: string }) => (\n      <div>{message}</div>\n    )\n\n    const LazyAnonymousComponent = withLazyLoading(AnonymousComponent)\n\n    expect(LazyAnonymousComponent.displayName).toBe('LazyLoaded(AnonymousComponent)')\n  })\n})\n\ndescribe('useLazyLoading', () => {\n  const TestHookComponent = ({ options = {} }: { options?: any }) => {\n    const { elementRef, isIntersecting, hasLoaded } = useLazyLoading(options)\n    \n    return (\n      <div>\n        <div ref={elementRef} data-testid=\"observed-element\">\n          Observed Element\n        </div>\n        <div data-testid=\"is-intersecting\">{isIntersecting.toString()}</div>\n        <div data-testid=\"has-loaded\">{hasLoaded.toString()}</div>\n      </div>\n    )\n  }\n\n  it('should track intersection state', async () => {\n    render(<TestHookComponent />)\n\n    expect(screen.getByTestId('is-intersecting')).toHaveTextContent('false')\n    expect(screen.getByTestId('has-loaded')).toHaveTextContent('false')\n\n    // Simulate intersection\n    const mockEntry = {\n      isIntersecting: true,\n      target: screen.getByTestId('observed-element'),\n    } as IntersectionObserverEntry\n\n    mockCallback([mockEntry])\n\n    await waitFor(() => {\n      expect(screen.getByTestId('is-intersecting')).toHaveTextContent('true')\n      expect(screen.getByTestId('has-loaded')).toHaveTextContent('true')\n    })\n  })\n\n  it('should apply priority-based delays', async () => {\n    jest.useFakeTimers()\n\n    render(<TestHookComponent options={{ priority: 'medium' }} />)\n\n    const mockEntry = {\n      isIntersecting: true,\n      target: screen.getByTestId('observed-element'),\n    } as IntersectionObserverEntry\n\n    mockCallback([mockEntry])\n\n    // Should not update immediately\n    expect(screen.getByTestId('is-intersecting')).toHaveTextContent('false')\n\n    // Should update after medium priority delay (100ms)\n    jest.advanceTimersByTime(100)\n\n    await waitFor(() => {\n      expect(screen.getByTestId('is-intersecting')).toHaveTextContent('true')\n    })\n\n    jest.useRealTimers()\n  })\n\n  it('should use custom root margin and threshold', () => {\n    render(\n      <TestHookComponent\n        options={{\n          rootMargin: '200px',\n          threshold: 0.8,\n        }}\n      />\n    )\n\n    expect(mockIntersectionObserver).toHaveBeenCalledWith(\n      expect.any(Function),\n      {\n        rootMargin: '200px',\n        threshold: 0.8,\n      }\n    )\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/__tests__/memoization.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/__tests__/progressive-loader.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 288,
        "column": 65,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 288,
        "endColumn": 68,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7892, 7895], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7892, 7895], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 300,
        "column": 13,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 300,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8178, 8181], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8178, 8181], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 301,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 301,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8200, 8203], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8200, 8203], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, waitFor, act } from '@testing-library/react'\nimport { jest } from '@jest/globals'\nimport {\n  ProgressiveLoader,\n  createSkeletonVariant,\n  useProgressiveLoading,\n} from '../progressive-loader'\n\n// Mock timers\njest.useFakeTimers()\n\nconst TestComponent = ({ message }: { message: string }) => (\n  <div data-testid=\"test-component\">{message}</div>\n)\n\nconst customStages = [\n  {\n    name: 'structure',\n    duration: 100,\n    skeleton: <div data-testid=\"structure-skeleton\">Loading structure...</div>,\n  },\n  {\n    name: 'content',\n    duration: 200,\n    skeleton: <div data-testid=\"content-skeleton\">Loading content...</div>,\n  },\n  {\n    name: 'details',\n    duration: 150,\n    skeleton: <div data-testid=\"details-skeleton\">Loading details...</div>,\n  },\n]\n\ndescribe('ProgressiveLoader', () => {\n  beforeEach(() => {\n    jest.clearAllTimers()\n  })\n\n  afterEach(() => {\n    jest.runOnlyPendingTimers()\n    jest.useRealTimers()\n    jest.useFakeTimers()\n  })\n\n  it('should show first stage skeleton initially', () => {\n    render(\n      <ProgressiveLoader stages={customStages}>\n        <TestComponent message=\"Final content\" />\n      </ProgressiveLoader>\n    )\n\n    expect(screen.getByTestId('structure-skeleton')).toBeInTheDocument()\n    expect(screen.getByText('Loading structure...')).toBeInTheDocument()\n    expect(screen.queryByTestId('test-component')).not.toBeInTheDocument()\n  })\n\n  it('should progress through all stages', async () => {\n    const onStageComplete = jest.fn()\n    const onAllStagesComplete = jest.fn()\n\n    render(\n      <ProgressiveLoader\n        stages={customStages}\n        onStageComplete={onStageComplete}\n        onAllStagesComplete={onAllStagesComplete}\n      >\n        <TestComponent message=\"Final content\" />\n      </ProgressiveLoader>\n    )\n\n    // Initial stage\n    expect(screen.getByTestId('structure-skeleton')).toBeInTheDocument()\n\n    // Progress to stage 1 (content)\n    await act(async () => {\n      jest.advanceTimersByTime(100)\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('content-skeleton')).toBeInTheDocument()\n    })\n    expect(onStageComplete).toHaveBeenCalledWith(1)\n\n    // Progress to stage 2 (details)\n    await act(async () => {\n      jest.advanceTimersByTime(200)\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('details-skeleton')).toBeInTheDocument()\n    })\n    expect(onStageComplete).toHaveBeenCalledWith(2)\n\n    // Complete all stages\n    await act(async () => {\n      jest.advanceTimersByTime(150)\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('test-component')).toBeInTheDocument()\n    })\n    expect(screen.getByText('Final content')).toBeInTheDocument()\n    expect(onAllStagesComplete).toHaveBeenCalled()\n  })\n\n  it('should apply priority-based timing adjustments', async () => {\n    const onStageComplete = jest.fn()\n\n    render(\n      <ProgressiveLoader\n        stages={customStages}\n        priority=\"critical\"\n        onStageComplete={onStageComplete}\n      >\n        <TestComponent message=\"Critical content\" />\n      </ProgressiveLoader>\n    )\n\n    // Critical priority should have 0.5x multiplier (50ms instead of 100ms)\n    act(() => {\n      jest.advanceTimersByTime(50)\n    })\n\n    await waitFor(() => {\n      expect(onStageComplete).toHaveBeenCalledWith(1)\n    })\n  })\n\n  it('should handle high priority timing', async () => {\n    const onStageComplete = jest.fn()\n\n    render(\n      <ProgressiveLoader\n        stages={customStages}\n        priority=\"high\"\n        onStageComplete={onStageComplete}\n      >\n        <TestComponent message=\"High priority content\" />\n      </ProgressiveLoader>\n    )\n\n    // High priority should have 0.7x multiplier (70ms instead of 100ms)\n    act(() => {\n      jest.advanceTimersByTime(70)\n    })\n\n    await waitFor(() => {\n      expect(onStageComplete).toHaveBeenCalledWith(1)\n    })\n  })\n\n  it('should handle low priority timing', async () => {\n    const onStageComplete = jest.fn()\n\n    render(\n      <ProgressiveLoader\n        stages={customStages}\n        priority=\"low\"\n        onStageComplete={onStageComplete}\n      >\n        <TestComponent message=\"Low priority content\" />\n      </ProgressiveLoader>\n    )\n\n    // Low priority should have 1.3x multiplier (130ms instead of 100ms)\n    act(() => {\n      jest.advanceTimersByTime(130)\n    })\n\n    await waitFor(() => {\n      expect(onStageComplete).toHaveBeenCalledWith(1)\n    })\n  })\n\n  it('should handle stages with delays', async () => {\n    const stagesWithDelay = [\n      {\n        name: 'delayed',\n        duration: 100,\n        delay: 50,\n        skeleton: <div data-testid=\"delayed-skeleton\">Delayed loading...</div>,\n      },\n    ]\n\n    const onStageComplete = jest.fn()\n\n    render(\n      <ProgressiveLoader\n        stages={stagesWithDelay}\n        onStageComplete={onStageComplete}\n      >\n        <TestComponent message=\"Delayed content\" />\n      </ProgressiveLoader>\n    )\n\n    // Should not complete until duration + delay\n    act(() => {\n      jest.advanceTimersByTime(100)\n    })\n\n    expect(onStageComplete).not.toHaveBeenCalled()\n\n    act(() => {\n      jest.advanceTimersByTime(50)\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('test-component')).toBeInTheDocument()\n    })\n  })\n\n  it('should apply correct CSS classes', () => {\n    const { container } = render(\n      <ProgressiveLoader\n        stages={customStages}\n        priority=\"high\"\n        className=\"custom-class\"\n      >\n        <TestComponent message=\"Content\" />\n      </ProgressiveLoader>\n    )\n\n    const loader = container.firstChild as HTMLElement\n    expect(loader).toHaveClass('progressive-loader')\n    expect(loader).toHaveClass('progressive-loader-stage-0')\n    expect(loader).toHaveClass('progressive-loader-priority-high')\n    expect(loader).toHaveClass('custom-class')\n  })\n\n  it('should have proper accessibility attributes', () => {\n    render(\n      <ProgressiveLoader stages={customStages}>\n        <TestComponent message=\"Content\" />\n      </ProgressiveLoader>\n    )\n\n    const loader = screen.getByRole('status')\n    expect(loader).toHaveAttribute('aria-label', 'Loading content - stage 1 of 3')\n  })\n})\n\ndescribe('createSkeletonVariant', () => {\n  it('should create card skeleton variant', () => {\n    const skeleton = createSkeletonVariant({ type: 'card', height: 300 })\n    const { container } = render(<div>{skeleton}</div>)\n    \n    expect(container.querySelector('.dashboard-card-skeleton')).toBeInTheDocument()\n  })\n\n  it('should create chart skeleton variant', () => {\n    const skeleton = createSkeletonVariant({ type: 'chart', height: 400 })\n    const { container } = render(<div>{skeleton}</div>)\n    \n    expect(container.querySelector('.dashboard-card-skeleton')).toBeInTheDocument()\n  })\n\n  it('should create table skeleton variant', () => {\n    const skeleton = createSkeletonVariant({ \n      type: 'table', \n      rows: 5, \n      columns: 3 \n    })\n    const { container } = render(<div>{skeleton}</div>)\n    \n    expect(container.querySelector('.dashboard-card-skeleton')).toBeInTheDocument()\n  })\n\n  it('should create metric skeleton variant', () => {\n    const skeleton = createSkeletonVariant({ type: 'metric' })\n    const { container } = render(<div>{skeleton}</div>)\n    \n    expect(container.querySelector('.dashboard-card-skeleton')).toBeInTheDocument()\n  })\n\n  it('should create custom skeleton variant', () => {\n    const customSkeleton = <div data-testid=\"custom-skeleton\">Custom</div>\n    const skeleton = createSkeletonVariant({ \n      type: 'custom', \n      customSkeleton \n    })\n    const { container } = render(<div>{skeleton}</div>)\n    \n    expect(container.querySelector('[data-testid=\"custom-skeleton\"]')).toBeInTheDocument()\n  })\n\n  it('should fallback to default skeleton for unknown types', () => {\n    const skeleton = createSkeletonVariant({ type: 'unknown' as any })\n    const { container } = render(<div>{skeleton}</div>)\n    \n    expect(container.querySelector('.dashboard-card-skeleton')).toBeInTheDocument()\n  })\n})\n\ndescribe('useProgressiveLoading', () => {\n  const TestHookComponent = ({ \n    stages, \n    options = {} \n  }: { \n    stages: any[], \n    options?: any \n  }) => {\n    const { currentStage, isComplete, currentSkeleton, reset } = useProgressiveLoading(stages, options)\n    \n    return (\n      <div>\n        <div data-testid=\"current-stage\">{currentStage}</div>\n        <div data-testid=\"is-complete\">{isComplete.toString()}</div>\n        <div data-testid=\"current-skeleton\">{currentSkeleton}</div>\n        <button onClick={reset} data-testid=\"reset-button\">Reset</button>\n      </div>\n    )\n  }\n\n  it('should progress through stages', async () => {\n    const onStageComplete = jest.fn()\n    const onAllStagesComplete = jest.fn()\n\n    render(\n      <TestHookComponent\n        stages={customStages}\n        options={{\n          onStageComplete,\n          onAllStagesComplete,\n        }}\n      />\n    )\n\n    expect(screen.getByTestId('current-stage')).toHaveTextContent('0')\n    expect(screen.getByTestId('is-complete')).toHaveTextContent('false')\n\n    // Progress through stages\n    act(() => {\n      jest.advanceTimersByTime(100)\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('current-stage')).toHaveTextContent('1')\n    })\n    expect(onStageComplete).toHaveBeenCalledWith(1)\n\n    act(() => {\n      jest.advanceTimersByTime(200)\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('current-stage')).toHaveTextContent('2')\n    })\n\n    act(() => {\n      jest.advanceTimersByTime(150)\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('is-complete')).toHaveTextContent('true')\n    })\n    expect(onAllStagesComplete).toHaveBeenCalled()\n  })\n\n  it('should reset loading state', async () => {\n    render(<TestHookComponent stages={customStages} />)\n\n    // Progress to completion\n    act(() => {\n      jest.advanceTimersByTime(450) // Total duration\n    })\n\n    await waitFor(() => {\n      expect(screen.getByTestId('is-complete')).toHaveTextContent('true')\n    })\n\n    // Reset\n    act(() => {\n      screen.getByTestId('reset-button').click()\n    })\n\n    expect(screen.getByTestId('current-stage')).toHaveTextContent('0')\n    expect(screen.getByTestId('is-complete')).toHaveTextContent('false')\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/__tests__/virtualization.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 38,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 38,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1030, 1033], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1030, 1033], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 60,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 60,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1663, 1666], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1663, 1666], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 83,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 83,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2292, 2295], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2292, 2295], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 89,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 89,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2483, 2486], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2483, 2486], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 177,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 177,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4956, 4959], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4956, 4959], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 177,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 177,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4967, 4970], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4967, 4970], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 198,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 198,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5487, 5490], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5487, 5490], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 222,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 222,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6187, 6190], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6187, 6190], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 246,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 246,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6816, 6819], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6816, 6819], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 247,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 247,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6863, 6866], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6863, 6866], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'getItemOffset' is assigned a value but never used.",
        "line": 249,
        "column": 60,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 249,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport { jest } from '@jest/globals'\nimport {\n  VirtualizedList,\n  VirtualizedTable,\n  VirtualizedGrid,\n  useDynamicSizing,\n  useVirtualizationPerformance,\n  calculateOptimalItemSize,\n  estimateVirtualizationMemory,\n} from '../virtualization'\n\n// Mock data\nconst mockListItems = Array.from({ length: 1000 }, (_, i) => ({\n  id: i,\n  name: `Item ${i}`,\n  value: Math.random() * 100,\n}))\n\nconst mockTableData = Array.from({ length: 1000 }, (_, i) => ({\n  id: i,\n  name: `Row ${i}`,\n  email: `user${i}@example.com`,\n  status: i % 2 === 0 ? 'active' : 'inactive',\n}))\n\nconst mockTableColumns = [\n  { key: 'id', header: 'ID', width: 60 },\n  { key: 'name', header: 'Name', width: 150 },\n  { key: 'email', header: 'Email', width: 200 },\n  { key: 'status', header: 'Status', width: 100 },\n]\n\ndescribe('Virtualization', () => {\n  describe('VirtualizedList', () => {\n    it('should render virtualized list', () => {\n      const renderItem = (item: any, index: number, style: React.CSSProperties) => (\n        <div style={style} data-testid={`item-${index}`}>\n          {item.name}\n        </div>\n      )\n\n      render(\n        <VirtualizedList\n          items={mockListItems.slice(0, 10)}\n          itemHeight={50}\n          containerHeight={300}\n          renderItem={renderItem}\n        />\n      )\n\n      // Should render visible items\n      expect(screen.getByTestId('item-0')).toBeInTheDocument()\n      expect(screen.getByText('Item 0')).toBeInTheDocument()\n    })\n\n    it('should handle scroll events', () => {\n      const onScroll = jest.fn()\n      const renderItem = (item: any, index: number, style: React.CSSProperties) => (\n        <div style={style} data-testid={`item-${index}`}>\n          {item.name}\n        </div>\n      )\n\n      render(\n        <VirtualizedList\n          items={mockListItems}\n          itemHeight={50}\n          containerHeight={300}\n          renderItem={renderItem}\n          onScroll={onScroll}\n        />\n      )\n\n      const container = screen.getByRole('list')\n      fireEvent.scroll(container, { target: { scrollTop: 100 } })\n\n      expect(onScroll).toHaveBeenCalledWith(100)\n    })\n\n    it('should use custom item key function', () => {\n      const renderItem = (item: any, index: number, style: React.CSSProperties) => (\n        <div style={style} data-testid={`item-${item.id}`}>\n          {item.name}\n        </div>\n      )\n\n      const getItemKey = (item: any) => `custom-${item.id}`\n\n      render(\n        <VirtualizedList\n          items={mockListItems.slice(0, 5)}\n          itemHeight={50}\n          containerHeight={300}\n          renderItem={renderItem}\n          getItemKey={getItemKey}\n        />\n      )\n\n      expect(screen.getByTestId('item-0')).toBeInTheDocument()\n    })\n  })\n\n  describe('VirtualizedTable', () => {\n    it('should render virtualized table', () => {\n      render(\n        <VirtualizedTable\n          data={mockTableData.slice(0, 10)}\n          columns={mockTableColumns}\n          rowHeight={40}\n          containerHeight={400}\n        />\n      )\n\n      // Should render table headers\n      expect(screen.getByText('ID')).toBeInTheDocument()\n      expect(screen.getByText('Name')).toBeInTheDocument()\n      expect(screen.getByText('Email')).toBeInTheDocument()\n      expect(screen.getByText('Status')).toBeInTheDocument()\n\n      // Should render first row\n      expect(screen.getByText('Row 0')).toBeInTheDocument()\n      expect(screen.getByText('user0@example.com')).toBeInTheDocument()\n    })\n\n    it('should handle row clicks', () => {\n      const onRowClick = jest.fn()\n\n      render(\n        <VirtualizedTable\n          data={mockTableData.slice(0, 10)}\n          columns={mockTableColumns}\n          rowHeight={40}\n          containerHeight={400}\n          onRowClick={onRowClick}\n        />\n      )\n\n      const firstRow = screen.getByText('Row 0').closest('[role=\"row\"]')\n      if (firstRow) {\n        fireEvent.click(firstRow)\n        expect(onRowClick).toHaveBeenCalledWith(mockTableData[0], 0)\n      }\n    })\n\n    it('should handle keyboard navigation', () => {\n      const onRowClick = jest.fn()\n\n      render(\n        <VirtualizedTable\n          data={mockTableData.slice(0, 10)}\n          columns={mockTableColumns}\n          rowHeight={40}\n          containerHeight={400}\n          onRowClick={onRowClick}\n        />\n      )\n\n      const firstRow = screen.getByText('Row 0').closest('[role=\"row\"]')\n      if (firstRow) {\n        fireEvent.keyDown(firstRow, { key: 'Enter' })\n        expect(onRowClick).toHaveBeenCalledWith(mockTableData[0], 0)\n\n        fireEvent.keyDown(firstRow, { key: ' ' })\n        expect(onRowClick).toHaveBeenCalledTimes(2)\n      }\n    })\n\n    it('should render custom cell content', () => {\n      const customColumns = [\n        ...mockTableColumns,\n        {\n          key: 'custom',\n          header: 'Custom',\n          width: 100,\n          render: (value: any, item: any) => (\n            <span data-testid={`custom-${item.id}`}>Custom {item.id}</span>\n          ),\n        },\n      ]\n\n      render(\n        <VirtualizedTable\n          data={mockTableData.slice(0, 5)}\n          columns={customColumns}\n          rowHeight={40}\n          containerHeight={400}\n        />\n      )\n\n      expect(screen.getByTestId('custom-0')).toHaveTextContent('Custom 0')\n    })\n  })\n\n  describe('VirtualizedGrid', () => {\n    it('should render virtualized grid', () => {\n      const renderItem = (item: any, index: number, style: React.CSSProperties) => (\n        <div style={style} data-testid={`grid-item-${index}`}>\n          {item.name}\n        </div>\n      )\n\n      render(\n        <VirtualizedGrid\n          items={mockListItems.slice(0, 20)}\n          itemWidth={150}\n          itemHeight={100}\n          containerWidth={600}\n          containerHeight={400}\n          columnsCount={4}\n          renderItem={renderItem}\n        />\n      )\n\n      // Should render visible grid items\n      expect(screen.getByTestId('grid-item-0')).toBeInTheDocument()\n      expect(screen.getByText('Item 0')).toBeInTheDocument()\n    })\n\n    it('should handle grid with gap', () => {\n      const renderItem = (item: any, index: number, style: React.CSSProperties) => (\n        <div style={style} data-testid={`grid-item-${index}`}>\n          {item.name}\n        </div>\n      )\n\n      render(\n        <VirtualizedGrid\n          items={mockListItems.slice(0, 12)}\n          itemWidth={150}\n          itemHeight={100}\n          containerWidth={600}\n          containerHeight={400}\n          columnsCount={3}\n          renderItem={renderItem}\n          gap={10}\n        />\n      )\n\n      expect(screen.getByTestId('grid-item-0')).toBeInTheDocument()\n    })\n  })\n\n  describe('useDynamicSizing', () => {\n    const TestComponent = ({ items }: { items: any[] }) => {\n      const measureItem = (item: any) => item.height || 50\n\n      const { itemHeights, totalHeight, measureItemHeight, getItemOffset } = useDynamicSizing(\n        items,\n        50,\n        measureItem\n      )\n\n      return (\n        <div>\n          <div data-testid=\"total-height\">{totalHeight}</div>\n          <div data-testid=\"item-heights\">{itemHeights.size}</div>\n          <button\n            onClick={() => measureItemHeight(0)}\n            data-testid=\"measure-button\"\n          >\n            Measure\n          </button>\n        </div>\n      )\n    }\n\n    it('should handle dynamic item sizing', () => {\n      const items = [\n        { id: 1, height: 60 },\n        { id: 2, height: 80 },\n        { id: 3, height: 40 },\n      ]\n\n      render(<TestComponent items={items} />)\n\n      // Initial total height should be estimated\n      expect(screen.getByTestId('total-height')).toHaveTextContent('150') // 3 * 50\n\n      // Measure an item\n      fireEvent.click(screen.getByTestId('measure-button'))\n\n      // Should have measured one item\n      expect(screen.getByTestId('item-heights')).toHaveTextContent('1')\n    })\n  })\n\n  describe('useVirtualizationPerformance', () => {\n    const TestComponent = ({ name }: { name: string }) => {\n      const { trackScroll } = useVirtualizationPerformance(name)\n\n      return (\n        <div>\n          <button onClick={trackScroll} data-testid=\"track-scroll\">\n            Track Scroll\n          </button>\n        </div>\n      )\n    }\n\n    it('should track virtualization performance', () => {\n      render(<TestComponent name=\"TestVirtualization\" />)\n\n      // Should not throw when tracking scroll\n      fireEvent.click(screen.getByTestId('track-scroll'))\n    })\n  })\n\n  describe('calculateOptimalItemSize', () => {\n    it('should calculate optimal item size', () => {\n      const result = calculateOptimalItemSize(1000, 10, 50, 200)\n      expect(result).toBe(100) // 1000 / 10 = 100, within min/max bounds\n\n      const resultWithMin = calculateOptimalItemSize(1000, 50, 50, 200)\n      expect(resultWithMin).toBe(50) // Would be 20, but clamped to min\n\n      const resultWithMax = calculateOptimalItemSize(1000, 2, 50, 200)\n      expect(resultWithMax).toBe(200) // Would be 500, but clamped to max\n    })\n  })\n\n  describe('estimateVirtualizationMemory', () => {\n    it('should estimate memory usage', () => {\n      const result = estimateVirtualizationMemory(1000, 50, 1024) // 1KB per item\n\n      expect(result.totalMemory).toBe(1024000) // 1000 * 1024\n      expect(result.virtualizedMemory).toBe(51200) // 50 * 1024\n      expect(result.memorySaved).toBe(972800) // totalMemory - virtualizedMemory\n      expect(result.savingsPercentage).toBe(95) // 95% savings\n    })\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/core-web-vitals.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'useCallback' is defined but never used.",
        "line": 1,
        "column": 46,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 69,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 69,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 77,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 77,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2504, 2507], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2504, 2507], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 88,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 88,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 97,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 97,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3114, 3117], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3114, 3117], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 110,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 110,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 131,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 131,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 145,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 145,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 153,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 153,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4922, 4925], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4922, 4925], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 167,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 167,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 186,
        "column": 16,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 186,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5782, 5785], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5782, 5785], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 215,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 215,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6610, 6613], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6610, 6613], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 217,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 217,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6716, 6719], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6716, 6719], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useEffect, useRef, useState, useCallback } from 'react'\n\n// Core Web Vitals metrics interface\nexport interface CoreWebVitalsMetrics {\n  lcp?: number // Largest Contentful Paint\n  fid?: number // First Input Delay\n  cls?: number // Cumulative Layout Shift\n  fcp?: number // First Contentful Paint\n  ttfb?: number // Time to First Byte\n  inp?: number // Interaction to Next Paint\n}\n\n// Performance thresholds (Google's recommended values)\nexport const PERFORMANCE_THRESHOLDS = {\n  lcp: { good: 2500, needsImprovement: 4000 },\n  fid: { good: 100, needsImprovement: 300 },\n  cls: { good: 0.1, needsImprovement: 0.25 },\n  fcp: { good: 1800, needsImprovement: 3000 },\n  ttfb: { good: 800, needsImprovement: 1800 },\n  inp: { good: 200, needsImprovement: 500 },\n} as const\n\n// Performance rating type\nexport type PerformanceRating = 'good' | 'needs-improvement' | 'poor'\n\n// Get performance rating for a metric\nexport function getPerformanceRating(\n  metric: keyof typeof PERFORMANCE_THRESHOLDS,\n  value: number\n): PerformanceRating {\n  const thresholds = PERFORMANCE_THRESHOLDS[metric]\n  if (value <= thresholds.good) return 'good'\n  if (value <= thresholds.needsImprovement) return 'needs-improvement'\n  return 'poor'\n}\n\n// Core Web Vitals tracking hook\nexport function useCoreWebVitals() {\n  const [metrics, setMetrics] = useState<CoreWebVitalsMetrics>({})\n  const observersRef = useRef<PerformanceObserver[]>([])\n\n  useEffect(() => {\n    // Only run in browser environment\n    if (typeof window === 'undefined' || !('PerformanceObserver' in window)) {\n      return\n    }\n\n    const observers: PerformanceObserver[] = []\n\n    // Track Largest Contentful Paint (LCP)\n    try {\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        const lastEntry = entries[entries.length - 1] as PerformanceEntry & {\n          startTime: number\n        }\n        \n        if (lastEntry) {\n          const lcp = lastEntry.startTime\n          setMetrics(prev => ({ ...prev, lcp }))\n          \n          // Send to analytics\n          sendToAnalytics('LCP', lcp)\n        }\n      })\n      \n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] })\n      observers.push(lcpObserver)\n    } catch (e) {\n      console.warn('LCP observation not supported')\n    }\n\n    // Track First Input Delay (FID)\n    try {\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        entries.forEach((entry: any) => {\n          const fid = entry.processingStart - entry.startTime\n          setMetrics(prev => ({ ...prev, fid }))\n          \n          // Send to analytics\n          sendToAnalytics('FID', fid)\n        })\n      })\n      \n      fidObserver.observe({ entryTypes: ['first-input'] })\n      observers.push(fidObserver)\n    } catch (e) {\n      console.warn('FID observation not supported')\n    }\n\n    // Track Cumulative Layout Shift (CLS)\n    try {\n      let clsValue = 0\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        entries.forEach((entry: any) => {\n          if (!entry.hadRecentInput) {\n            clsValue += entry.value\n            setMetrics(prev => ({ ...prev, cls: clsValue }))\n          }\n        })\n        \n        // Send to analytics (debounced)\n        debounce(() => sendToAnalytics('CLS', clsValue), 1000)()\n      })\n      \n      clsObserver.observe({ entryTypes: ['layout-shift'] })\n      observers.push(clsObserver)\n    } catch (e) {\n      console.warn('CLS observation not supported')\n    }\n\n    // Track First Contentful Paint (FCP)\n    try {\n      const fcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        entries.forEach((entry) => {\n          if (entry.name === 'first-contentful-paint') {\n            const fcp = entry.startTime\n            setMetrics(prev => ({ ...prev, fcp }))\n            \n            // Send to analytics\n            sendToAnalytics('FCP', fcp)\n          }\n        })\n      })\n      \n      fcpObserver.observe({ entryTypes: ['paint'] })\n      observers.push(fcpObserver)\n    } catch (e) {\n      console.warn('FCP observation not supported')\n    }\n\n    // Track Time to First Byte (TTFB)\n    try {\n      const navigationEntries = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[]\n      if (navigationEntries.length > 0) {\n        const ttfb = navigationEntries[0].responseStart - navigationEntries[0].requestStart\n        setMetrics(prev => ({ ...prev, ttfb }))\n        \n        // Send to analytics\n        sendToAnalytics('TTFB', ttfb)\n      }\n    } catch (e) {\n      console.warn('TTFB measurement not supported')\n    }\n\n    // Track Interaction to Next Paint (INP) - newer metric\n    try {\n      const inpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        entries.forEach((entry: any) => {\n          const inp = entry.processingEnd - entry.startTime\n          setMetrics(prev => ({ ...prev, inp }))\n          \n          // Send to analytics\n          sendToAnalytics('INP', inp)\n        })\n      })\n      \n      // INP is still experimental\n      if ('observe' in inpObserver) {\n        inpObserver.observe({ entryTypes: ['event'] })\n        observers.push(inpObserver)\n      }\n    } catch (e) {\n      console.warn('INP observation not supported')\n    }\n\n    observersRef.current = observers\n\n    // Cleanup observers\n    return () => {\n      observers.forEach(observer => observer.disconnect())\n    }\n  }, [])\n\n  return metrics\n}\n\n// Send metrics to analytics\nfunction sendToAnalytics(metricName: string, value: number) {\n  // Send to Google Analytics if available\n  if (typeof window !== 'undefined' && 'gtag' in window) {\n    (window as any).gtag('event', 'web_vitals', {\n      metric_name: metricName,\n      value: Math.round(value),\n      rating: getPerformanceRating(\n        metricName.toLowerCase() as keyof typeof PERFORMANCE_THRESHOLDS,\n        value\n      ),\n    })\n  }\n\n  // Send to custom analytics endpoint\n  if (typeof window !== 'undefined' && process.env.NODE_ENV === 'production') {\n    fetch('/api/analytics/web-vitals', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        metric: metricName,\n        value,\n        timestamp: Date.now(),\n        url: window.location.href,\n        userAgent: navigator.userAgent,\n      }),\n    }).catch(error => {\n      console.warn('Failed to send web vitals to analytics:', error)\n    })\n  }\n}\n\n// Debounce utility\nfunction debounce(func: (...args: any[]) => void, wait: number) {\n  let timeout: NodeJS.Timeout\n  return function executedFunction(...args: any[]) {\n    const later = () => {\n      clearTimeout(timeout)\n      func(...args)\n    }\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n}\n\n// Performance monitoring component\nexport function PerformanceMonitor({ \n  children,\n  onMetricsUpdate,\n}: { \n  children: React.ReactNode\n  onMetricsUpdate?: (metrics: CoreWebVitalsMetrics) => void\n}) {\n  const metrics = useCoreWebVitals()\n\n  useEffect(() => {\n    onMetricsUpdate?.(metrics)\n  }, [metrics, onMetricsUpdate])\n\n  return <>{children}</>\n}\n\n// Performance dashboard component\nexport function PerformanceDashboard() {\n  const metrics = useCoreWebVitals()\n  const [isVisible, setIsVisible] = useState(false)\n\n  // Only show in development or when explicitly enabled\n  useEffect(() => {\n    const shouldShow = \n      process.env.NODE_ENV === 'development' ||\n      localStorage.getItem('show-performance-dashboard') === 'true'\n    \n    setIsVisible(shouldShow)\n  }, [])\n\n  if (!isVisible) return null\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        top: 10,\n        right: 10,\n        background: 'rgba(0, 0, 0, 0.8)',\n        color: 'white',\n        padding: '10px',\n        borderRadius: '5px',\n        fontSize: '12px',\n        fontFamily: 'monospace',\n        zIndex: 9999,\n        minWidth: '200px',\n      }}\n    >\n      <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>\n        Core Web Vitals\n      </div>\n      \n      {Object.entries(metrics).map(([key, value]) => {\n        if (value === undefined) return null\n        \n        const rating = getPerformanceRating(\n          key as keyof typeof PERFORMANCE_THRESHOLDS,\n          value\n        )\n        \n        const color = \n          rating === 'good' ? '#4CAF50' :\n          rating === 'needs-improvement' ? '#FF9800' :\n          '#F44336'\n\n        return (\n          <div key={key} style={{ marginBottom: '2px' }}>\n            <span style={{ textTransform: 'uppercase' }}>{key}:</span>{' '}\n            <span style={{ color, fontWeight: 'bold' }}>\n              {Math.round(value)}\n              {key === 'cls' ? '' : 'ms'}\n            </span>\n          </div>\n        )\n      })}\n      \n      <div style={{ marginTop: '10px', fontSize: '10px', opacity: 0.7 }}>\n        Press F12  Console for details\n      </div>\n    </div>\n  )\n}\n\n// Hook for tracking component-specific performance\nexport function useComponentPerformance(componentName: string) {\n  const renderStartTime = useRef<number>(0)\n  const mountTime = useRef<number>(0)\n  const renderCount = useRef<number>(0)\n\n  // Track mount time\n  useEffect(() => {\n    mountTime.current = performance.now()\n    \n    return () => {\n      const unmountTime = performance.now()\n      const totalLifetime = unmountTime - mountTime.current\n      \n      console.log(\n        `${componentName} lifecycle: ${totalLifetime.toFixed(2)}ms total, ` +\n        `${renderCount.current} renders`\n      )\n    }\n  }, [componentName])\n\n  // Track render performance\n  renderStartTime.current = performance.now()\n  \n  useEffect(() => {\n    const renderEndTime = performance.now()\n    const renderTime = renderEndTime - renderStartTime.current\n    renderCount.current += 1\n    \n    if (renderTime > 16) { // Flag slow renders\n      console.warn(\n        `${componentName} slow render #${renderCount.current}: ${renderTime.toFixed(2)}ms`\n      )\n    }\n    \n    // Send to analytics for production monitoring\n    if (process.env.NODE_ENV === 'production' && renderTime > 50) {\n      sendToAnalytics('component_render_time', renderTime)\n    }\n  })\n\n  return {\n    renderCount: renderCount.current,\n    mountTime: mountTime.current,\n  }\n}\n\n// Performance budget checker\nexport function usePerformanceBudget(budgets: Partial<CoreWebVitalsMetrics>) {\n  const metrics = useCoreWebVitals()\n  const [violations, setViolations] = useState<string[]>([])\n\n  useEffect(() => {\n    const newViolations: string[] = []\n    \n    Object.entries(budgets).forEach(([metric, budget]) => {\n      const actualValue = metrics[metric as keyof CoreWebVitalsMetrics]\n      \n      if (actualValue !== undefined && budget !== undefined && actualValue > budget) {\n        newViolations.push(\n          `${metric.toUpperCase()}: ${Math.round(actualValue)}ms exceeds budget of ${budget}ms`\n        )\n      }\n    })\n    \n    setViolations(newViolations)\n    \n    // Log violations\n    if (newViolations.length > 0) {\n      console.warn('Performance budget violations:', newViolations)\n    }\n  }, [metrics, budgets])\n\n  return {\n    violations,\n    isWithinBudget: violations.length === 0,\n    metrics,\n  }\n}\n\n// Real User Monitoring (RUM) data collection\nexport function useRealUserMonitoring() {\n  const [rumData, setRumData] = useState<{\n    pageLoadTime: number\n    domContentLoaded: number\n    resourceLoadTimes: Array<{ name: string; duration: number }>\n    userInteractions: number\n    errors: number\n  } | null>(null)\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return\n\n    // Collect page load metrics\n    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming\n    if (navigation) {\n      const pageLoadTime = navigation.loadEventEnd - navigation.navigationStart\n      const domContentLoaded = navigation.domContentLoadedEventEnd - navigation.navigationStart\n      \n      // Collect resource load times\n      const resources = performance.getEntriesByType('resource') as PerformanceResourceTiming[]\n      const resourceLoadTimes = resources.map(resource => ({\n        name: resource.name,\n        duration: resource.duration,\n      }))\n\n      setRumData({\n        pageLoadTime,\n        domContentLoaded,\n        resourceLoadTimes,\n        userInteractions: 0,\n        errors: 0,\n      })\n    }\n\n    // Track user interactions\n    let interactionCount = 0\n    const trackInteraction = () => {\n      interactionCount += 1\n      setRumData(prev => prev ? { ...prev, userInteractions: interactionCount } : null)\n    }\n\n    // Track errors\n    let errorCount = 0\n    const trackError = () => {\n      errorCount += 1\n      setRumData(prev => prev ? { ...prev, errors: errorCount } : null)\n    }\n\n    // Add event listeners\n    ['click', 'keydown', 'scroll'].forEach(event => {\n      window.addEventListener(event, trackInteraction, { passive: true })\n    })\n\n    window.addEventListener('error', trackError)\n    window.addEventListener('unhandledrejection', trackError)\n\n    // Cleanup\n    return () => {\n      ['click', 'keydown', 'scroll'].forEach(event => {\n        window.removeEventListener(event, trackInteraction)\n      })\n      window.removeEventListener('error', trackError)\n      window.removeEventListener('unhandledrejection', trackError)\n    }\n  }, [])\n\n  return rumData\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/dynamic-imports.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'props' is defined but never used.",
        "line": 72,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 72,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 72,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 72,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2331, 2334], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2331, 2334], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'props' is defined but never used.",
        "line": 85,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 85,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 85,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 85,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2756, 2759], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2756, 2759], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 166,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 166,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5590, 5593], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5590, 5593], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 167,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 167,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5637, 5640], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5637, 5640], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 212,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 212,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6795, 6798], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6795, 6798], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 300,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 300,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9635, 9638], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9635, 9638], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { lazy, Suspense, ComponentType } from 'react'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { Card, CardContent, CardHeader } from '@/components/ui/card'\nimport type { ChartType } from '@/types/dashboard'\n\n// Dynamic imports for chart components with proper error boundaries\nconst LazyLineChart = lazy(() => \n  import('../charts/chart-types/line-chart')\n    .then(module => ({ default: module.LineChart }))\n    .catch(error => {\n      console.error('Failed to load LineChart:', error)\n      return { default: ChartErrorFallback }\n    })\n)\n\nconst LazyBarChart = lazy(() => \n  import('../charts/chart-types/bar-chart')\n    .then(module => ({ default: module.BarChart }))\n    .catch(error => {\n      console.error('Failed to load BarChart:', error)\n      return { default: ChartErrorFallback }\n    })\n)\n\nconst LazyPieChart = lazy(() => \n  import('../charts/chart-types/pie-chart')\n    .then(module => ({ default: module.PieChart }))\n    .catch(error => {\n      console.error('Failed to load PieChart:', error)\n      return { default: ChartErrorFallback }\n    })\n)\n\nconst LazyHeatmapChart = lazy(() => \n  import('../charts/chart-types/heatmap-chart')\n    .then(module => ({ default: module.HeatmapChart }))\n    .catch(error => {\n      console.error('Failed to load HeatmapChart:', error)\n      return { default: ChartErrorFallback }\n    })\n)\n\n// Dynamic imports for other heavy components\nconst LazyAnalyticsDashboard = lazy(() => \n  import('../../analytics/analytics-dashboard')\n    .then(module => ({ default: module.AnalyticsDashboard }))\n    .catch(error => {\n      console.error('Failed to load AnalyticsDashboard:', error)\n      return { default: ComponentErrorFallback }\n    })\n)\n\nconst LazyPerformanceCharts = lazy(() => \n  import('../../analytics/performance-charts')\n    .then(module => ({ default: module.PerformanceCharts }))\n    .catch(error => {\n      console.error('Failed to load PerformanceCharts:', error)\n      return { default: ComponentErrorFallback }\n    })\n)\n\nconst LazyTaskBoard = lazy(() => \n  import('../../kanban/task-board')\n    .then(module => ({ default: module.TaskBoard }))\n    .catch(error => {\n      console.error('Failed to load TaskBoard:', error)\n      return { default: ComponentErrorFallback }\n    })\n)\n\n// Error fallback components\nfunction ChartErrorFallback(props: any) {\n  return (\n    <Card className=\"border-red-200 bg-red-50 dark:bg-red-950/20\">\n      <CardContent className=\"p-6\">\n        <div className=\"text-center text-red-600 dark:text-red-400\">\n          <p className=\"font-medium\">Chart failed to load</p>\n          <p className=\"text-sm mt-1\">Please refresh the page to try again</p>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\nfunction ComponentErrorFallback(props: any) {\n  return (\n    <Card className=\"border-red-200 bg-red-50 dark:bg-red-950/20\">\n      <CardContent className=\"p-6\">\n        <div className=\"text-center text-red-600 dark:text-red-400\">\n          <p className=\"font-medium\">Component failed to load</p>\n          <p className=\"text-sm mt-1\">Please refresh the page to try again</p>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\n// Loading fallbacks for different component types\nfunction ChartLoadingFallback({ height = 300 }: { height?: number }) {\n  return (\n    <Card className=\"dashboard-card-skeleton\">\n      <CardHeader>\n        <div className=\"flex items-center justify-between\">\n          <Skeleton className=\"h-5 w-32\" />\n          <Skeleton className=\"h-8 w-8 rounded\" />\n        </div>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-4\">\n          <div className=\"flex justify-between items-end\" style={{ height: `${height}px` }}>\n            {Array.from({ length: 8 }).map((_, i) => (\n              <Skeleton\n                key={i}\n                className=\"w-8\"\n                style={{ height: `${Math.random() * 80 + 20}%` }}\n              />\n            ))}\n          </div>\n          <div className=\"flex justify-center space-x-4\">\n            {Array.from({ length: 3 }).map((_, i) => (\n              <div key={i} className=\"flex items-center space-x-2\">\n                <Skeleton className=\"h-3 w-3 rounded-full\" />\n                <Skeleton className=\"h-3 w-16\" />\n              </div>\n            ))}\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\nfunction DashboardLoadingFallback() {\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n        {Array.from({ length: 6 }).map((_, i) => (\n          <Card key={i} className=\"dashboard-card-skeleton\">\n            <CardHeader>\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-2\">\n                  <Skeleton className=\"h-5 w-5 rounded\" />\n                  <Skeleton className=\"h-4 w-24\" />\n                </div>\n                <Skeleton className=\"h-8 w-8 rounded\" />\n              </div>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-3\">\n                <div className=\"flex items-baseline space-x-2\">\n                  <Skeleton className=\"h-8 w-16\" />\n                  <Skeleton className=\"h-4 w-8\" />\n                </div>\n                <Skeleton className=\"h-20 w-full rounded\" />\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n    </div>\n  )\n}\n\n// Chart component factory with dynamic loading\nexport function createDynamicChart(type: ChartType) {\n  const ChartComponent = ({ fallbackHeight = 300, ...props }: any) => {\n    let LazyComponent: ComponentType<any>\n    \n    switch (type) {\n      case 'line':\n      case 'area':\n      case 'scatter':\n        LazyComponent = LazyLineChart\n        break\n      case 'bar':\n        LazyComponent = LazyBarChart\n        break\n      case 'pie':\n        LazyComponent = LazyPieChart\n        break\n      case 'heatmap':\n        LazyComponent = LazyHeatmapChart\n        break\n      default:\n        return <ChartErrorFallback />\n    }\n\n    return (\n      <Suspense fallback={<ChartLoadingFallback height={fallbackHeight} />}>\n        <LazyComponent {...props} />\n      </Suspense>\n    )\n  }\n\n  ChartComponent.displayName = `DynamicChart(${type})`\n  return ChartComponent\n}\n\n// Higher-order component for adding dynamic loading to any component\nexport function withDynamicLoading<T extends object>(\n  importFn: () => Promise<{ default: ComponentType<T> }>,\n  fallback?: React.ReactNode,\n  errorFallback?: React.ReactNode\n) {\n  const LazyComponent = lazy(() => \n    importFn().catch(error => {\n      console.error('Dynamic import failed:', error)\n      return { default: () => errorFallback || <ComponentErrorFallback /> }\n    })\n  )\n\n  const DynamicComponent = React.forwardRef<any, T>((props, ref) => (\n    <Suspense fallback={fallback || <DashboardLoadingFallback />}>\n      <LazyComponent {...props} ref={ref} />\n    </Suspense>\n  ))\n\n  DynamicComponent.displayName = 'DynamicComponent'\n  return DynamicComponent\n}\n\n// Pre-configured dynamic components\nexport const DynamicAnalyticsDashboard = withDynamicLoading(\n  () => import('../../analytics/analytics-dashboard').then(m => ({ default: m.AnalyticsDashboard })),\n  <DashboardLoadingFallback />,\n  <ComponentErrorFallback />\n)\n\nexport const DynamicPerformanceCharts = withDynamicLoading(\n  () => import('../../analytics/performance-charts').then(m => ({ default: m.PerformanceCharts })),\n  <ChartLoadingFallback />,\n  <ChartErrorFallback />\n)\n\nexport const DynamicTaskBoard = withDynamicLoading(\n  () => import('../../kanban/task-board').then(m => ({ default: m.TaskBoard })),\n  <DashboardLoadingFallback />,\n  <ComponentErrorFallback />\n)\n\n// Bundle splitting utilities\nexport const ChartBundle = {\n  LineChart: LazyLineChart,\n  BarChart: LazyBarChart,\n  PieChart: LazyPieChart,\n  HeatmapChart: LazyHeatmapChart,\n}\n\nexport const DashboardBundle = {\n  AnalyticsDashboard: LazyAnalyticsDashboard,\n  PerformanceCharts: LazyPerformanceCharts,\n  TaskBoard: LazyTaskBoard,\n}\n\n// Preload functions for critical components\nexport function preloadChartComponents() {\n  // Preload critical chart components\n  import('../charts/chart-types/line-chart')\n  import('../charts/chart-types/bar-chart')\n}\n\nexport function preloadDashboardComponents() {\n  // Preload critical dashboard components\n  import('../../analytics/analytics-dashboard')\n}\n\n// Resource hints for better loading performance\nexport function addResourceHints() {\n  if (typeof window !== 'undefined') {\n    // Add prefetch hints for chart components\n    const chartPrefetch = document.createElement('link')\n    chartPrefetch.rel = 'prefetch'\n    chartPrefetch.href = '/chunks/chart-components.js'\n    document.head.appendChild(chartPrefetch)\n\n    // Add preload hints for critical components\n    const criticalPreload = document.createElement('link')\n    criticalPreload.rel = 'preload'\n    criticalPreload.href = '/chunks/dashboard-critical.js'\n    criticalPreload.as = 'script'\n    document.head.appendChild(criticalPreload)\n  }\n}\n\n// Performance monitoring for dynamic imports\nexport function trackDynamicImportPerformance(componentName: string) {\n  if (typeof window !== 'undefined' && 'performance' in window) {\n    const startTime = performance.now()\n    \n    return {\n      end: () => {\n        const endTime = performance.now()\n        const loadTime = endTime - startTime\n        \n        // Log performance metrics\n        console.log(`Dynamic import ${componentName}: ${loadTime.toFixed(2)}ms`)\n        \n        // Send to analytics if available\n        if ('gtag' in window) {\n          (window as any).gtag('event', 'dynamic_import_performance', {\n            component_name: componentName,\n            load_time: Math.round(loadTime),\n          })\n        }\n      }\n    }\n  }\n  \n  return { end: () => {} }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/index.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'setMetrics' is assigned a value but never used.",
        "line": 101,
        "column": 19,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 101,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 120,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 120,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2924, 2927], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2924, 2927], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 168,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 168,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4159, 4162], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4159, 4162], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 186,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 186,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4597, 4600], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4597, 4600], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 195,
        "column": 12,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 195,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 206,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 206,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5132, 5135], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5132, 5135], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 216,
        "column": 12,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 216,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 224,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 224,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5562, 5565], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5562, 5565], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 231,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 231,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5704, 5707], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5704, 5707], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used.",
        "line": 240,
        "column": 12,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 240,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Performance optimization components and utilities\nexport {\n  createDynamicChart,\n  withDynamicLoading,\n  DynamicAnalyticsDashboard,\n  DynamicPerformanceCharts,\n  DynamicTaskBoard,\n  ChartBundle,\n  DashboardBundle,\n  preloadChartComponents,\n  preloadDashboardComponents,\n  addResourceHints,\n  trackDynamicImportPerformance,\n} from './dynamic-imports'\n\nexport {\n  ProgressiveLoader,\n  createSkeletonVariant,\n  useProgressiveLoading,\n} from './progressive-loader'\n\nexport {\n  LazyCard,\n  withLazyLoading,\n  useLazyLoading,\n} from './lazy-card'\n\nexport {\n  ViewportSkeleton,\n  withViewportSkeleton,\n} from './viewport-skeleton'\n\nexport {\n  useIntersectionObserver,\n  withIntersectionObserver,\n  BatchIntersectionObserver,\n  getGlobalBatchObserver,\n  useBatchIntersectionObserver,\n  trackIntersectionPerformance,\n  getViewportBasedPriority,\n  useScrollDirectionOptimization,\n} from './intersection-observer'\n\nexport {\n  createMemoizedComponent,\n  MemoizedDashboardCard,\n  MemoizedChartWrapper,\n  MemoizedMetricCard,\n  useMemoizedCalculation,\n  useMemoizedCallback,\n  useStableObject,\n  withPerformanceMonitoring,\n  RenderOptimizer,\n  useOptimizedRender,\n  RenderBarrier,\n  useRenderPerformance,\n} from './memoization'\n\nexport {\n  VirtualizedList,\n  VirtualizedTable,\n  VirtualizedGrid,\n  useDynamicSizing,\n  useVirtualizationPerformance,\n  calculateOptimalItemSize,\n  estimateVirtualizationMemory,\n} from './virtualization'\n\nexport {\n  useCoreWebVitals,\n  getPerformanceRating,\n  PERFORMANCE_THRESHOLDS,\n  PerformanceMonitor,\n  PerformanceDashboard,\n  useComponentPerformance,\n  usePerformanceBudget,\n  useRealUserMonitoring,\n  type CoreWebVitalsMetrics,\n  type PerformanceRating,\n} from './core-web-vitals'\n\n// Performance monitoring utilities\nexport interface PerformanceMetrics {\n  renderTime: number\n  chartLoadTime: number\n  dataFetchTime: number\n  interactionLatency: number\n  memoryUsage: number\n  bundleSize: number\n}\n\nexport interface PerformanceThresholds {\n  renderTime: number\n  chartLoadTime: number\n  dataFetchTime: number\n  interactionLatency: number\n}\n\n// Performance monitoring hook\nexport function usePerformanceMonitoring() {\n  const [metrics, setMetrics] = React.useState<PerformanceMetrics | null>(null)\n  \n  const startMeasurement = React.useCallback((name: string) => {\n    if (typeof window !== 'undefined' && 'performance' in window) {\n      performance.mark(`${name}-start`)\n    }\n  }, [])\n  \n  const endMeasurement = React.useCallback((name: string) => {\n    if (typeof window !== 'undefined' && 'performance' in window) {\n      performance.mark(`${name}-end`)\n      performance.measure(name, `${name}-start`, `${name}-end`)\n      \n      const measure = performance.getEntriesByName(name)[0]\n      if (measure) {\n        console.log(`Performance: ${name} took ${measure.duration.toFixed(2)}ms`)\n        \n        // Send to analytics if available\n        if ('gtag' in window) {\n          (window as any).gtag('event', 'performance_measurement', {\n            measurement_name: name,\n            duration: Math.round(measure.duration),\n          })\n        }\n      }\n    }\n  }, [])\n  \n  const measureComponent = React.useCallback((componentName: string) => {\n    return {\n      start: () => startMeasurement(componentName),\n      end: () => endMeasurement(componentName),\n    }\n  }, [startMeasurement, endMeasurement])\n  \n  return {\n    metrics,\n    startMeasurement,\n    endMeasurement,\n    measureComponent,\n  }\n}\n\n// Bundle size monitoring\nexport function getBundleSize(): Promise<number> {\n  if (typeof window === 'undefined' || !('performance' in window)) {\n    return Promise.resolve(0)\n  }\n  \n  return new Promise((resolve) => {\n    // Use Navigation Timing API to estimate bundle size\n    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming\n    if (navigation) {\n      const transferSize = navigation.transferSize || 0\n      resolve(transferSize)\n    } else {\n      resolve(0)\n    }\n  })\n}\n\n// Memory usage monitoring\nexport function getMemoryUsage(): number {\n  if (typeof window === 'undefined' || !('performance' in window)) {\n    return 0\n  }\n  \n  const memory = (performance as any).memory\n  if (memory) {\n    return memory.usedJSHeapSize || 0\n  }\n  \n  return 0\n}\n\n// Core Web Vitals monitoring\nexport function trackCoreWebVitals() {\n  if (typeof window === 'undefined') return\n  \n  // Track Largest Contentful Paint (LCP)\n  const observer = new PerformanceObserver((list) => {\n    const entries = list.getEntries()\n    const lastEntry = entries[entries.length - 1]\n    \n    if ('gtag' in window) {\n      (window as any).gtag('event', 'web_vitals', {\n        metric_name: 'LCP',\n        value: Math.round(lastEntry.startTime),\n      })\n    }\n  })\n  \n  try {\n    observer.observe({ entryTypes: ['largest-contentful-paint'] })\n  } catch (e) {\n    // LCP not supported\n  }\n  \n  // Track First Input Delay (FID)\n  const fidObserver = new PerformanceObserver((list) => {\n    const entries = list.getEntries()\n    entries.forEach((entry) => {\n      const fid = entry.processingStart - entry.startTime\n      \n      if ('gtag' in window) {\n        (window as any).gtag('event', 'web_vitals', {\n          metric_name: 'FID',\n          value: Math.round(fid),\n        })\n      }\n    })\n  })\n  \n  try {\n    fidObserver.observe({ entryTypes: ['first-input'] })\n  } catch (e) {\n    // FID not supported\n  }\n  \n  // Track Cumulative Layout Shift (CLS)\n  let clsValue = 0\n  const clsObserver = new PerformanceObserver((list) => {\n    const entries = list.getEntries()\n    entries.forEach((entry: any) => {\n      if (!entry.hadRecentInput) {\n        clsValue += entry.value\n      }\n    })\n    \n    if ('gtag' in window) {\n      (window as any).gtag('event', 'web_vitals', {\n        metric_name: 'CLS',\n        value: Math.round(clsValue * 1000) / 1000,\n      })\n    }\n  })\n  \n  try {\n    clsObserver.observe({ entryTypes: ['layout-shift'] })\n  } catch (e) {\n    // CLS not supported\n  }\n}\n\n// Performance budget checker\nexport function checkPerformanceBudget(thresholds: PerformanceThresholds): boolean {\n  if (typeof window === 'undefined' || !('performance' in window)) {\n    return true // Assume passing if we can't measure\n  }\n  \n  const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming\n  if (!navigation) return true\n  \n  const loadTime = navigation.loadEventEnd - navigation.navigationStart\n  const renderTime = navigation.domContentLoadedEventEnd - navigation.navigationStart\n  \n  const withinBudget = {\n    renderTime: renderTime <= thresholds.renderTime,\n    loadTime: loadTime <= thresholds.chartLoadTime,\n  }\n  \n  const allWithinBudget = Object.values(withinBudget).every(Boolean)\n  \n  if (!allWithinBudget) {\n    console.warn('Performance budget exceeded:', {\n      actual: { renderTime, loadTime },\n      thresholds,\n      withinBudget,\n    })\n  }\n  \n  return allWithinBudget\n}\n\n// Default performance thresholds (in milliseconds)\nexport const DEFAULT_PERFORMANCE_THRESHOLDS: PerformanceThresholds = {\n  renderTime: 1000,      // 1 second for initial render\n  chartLoadTime: 2000,   // 2 seconds for chart loading\n  dataFetchTime: 3000,   // 3 seconds for data fetching\n  interactionLatency: 100, // 100ms for interactions\n}\n\nimport React from 'react'",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/intersection-observer.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 102,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 102,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2866, 2869], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2866, 2869], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 171,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 171,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4426, 4429], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4426, 4429], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 300,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 300,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7974, 7977], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7974, 7977], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useRef, useState, useCallback } from 'react'\n\ninterface IntersectionObserverOptions {\n  root?: Element | null\n  rootMargin?: string\n  threshold?: number | number[]\n  triggerOnce?: boolean\n  skip?: boolean\n  initialInView?: boolean\n  delay?: number\n  trackVisibility?: boolean\n  fallbackInView?: boolean\n}\n\ninterface IntersectionObserverEntry {\n  boundingClientRect: DOMRectReadOnly\n  intersectionRatio: number\n  intersectionRect: DOMRectReadOnly\n  isIntersecting: boolean\n  rootBounds: DOMRectReadOnly | null\n  target: Element\n  time: number\n}\n\ninterface UseIntersectionObserverResult {\n  ref: (node?: Element | null) => void\n  inView: boolean\n  entry?: IntersectionObserverEntry\n}\n\n// Polyfill for environments without IntersectionObserver\nconst hasIntersectionObserver = typeof window !== 'undefined' && 'IntersectionObserver' in window\n\nfunction createIntersectionObserver(\n  callback: (entries: IntersectionObserverEntry[]) => void,\n  options: IntersectionObserverOptions = {}\n): IntersectionObserver | null {\n  if (!hasIntersectionObserver) {\n    return null\n  }\n\n  return new IntersectionObserver(callback, {\n    root: options.root,\n    rootMargin: options.rootMargin || '0px',\n    threshold: options.threshold || 0,\n  })\n}\n\n// Hook for using intersection observer\nexport function useIntersectionObserver(\n  options: IntersectionObserverOptions = {}\n): UseIntersectionObserverResult {\n  const {\n    threshold = 0,\n    root = null,\n    rootMargin = '0px',\n    triggerOnce = false,\n    skip = false,\n    initialInView = false,\n    delay = 0,\n    trackVisibility = false,\n    fallbackInView = false,\n  } = options\n\n  const [inView, setInView] = useState(initialInView)\n  const [entry, setEntry] = useState<IntersectionObserverEntry>()\n  const elementRef = useRef<Element | null>(null)\n  const observerRef = useRef<IntersectionObserver | null>(null)\n  const timeoutRef = useRef<NodeJS.Timeout>()\n\n  const setRef = useCallback(\n    (node: Element | null) => {\n      if (elementRef.current) {\n        // Clean up previous observer\n        if (observerRef.current) {\n          observerRef.current.unobserve(elementRef.current)\n        }\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current)\n        }\n      }\n\n      elementRef.current = node\n\n      if (skip || !node) return\n\n      // Fallback for environments without IntersectionObserver\n      if (!hasIntersectionObserver) {\n        if (!triggerOnce || !inView) {\n          setInView(fallbackInView)\n        }\n        return\n      }\n\n      observerRef.current = createIntersectionObserver(\n        (entries) => {\n          const [observerEntry] = entries\n          const isIntersecting = observerEntry.isIntersecting\n\n          // Handle visibility tracking\n          if (trackVisibility && 'isVisible' in observerEntry) {\n            const isVisible = (observerEntry as any).isVisible\n            if (!isVisible) return\n          }\n\n          const handleIntersection = () => {\n            setInView(isIntersecting)\n            setEntry(observerEntry)\n\n            if (isIntersecting && triggerOnce && observerRef.current) {\n              observerRef.current.unobserve(node)\n              observerRef.current = null\n            }\n          }\n\n          if (delay > 0 && isIntersecting) {\n            timeoutRef.current = setTimeout(handleIntersection, delay)\n          } else {\n            handleIntersection()\n          }\n        },\n        {\n          threshold,\n          root,\n          rootMargin,\n          // Enable visibility tracking if supported\n          ...(trackVisibility && { trackVisibility: true, delay: 100 }),\n        }\n      )\n\n      if (observerRef.current && node) {\n        observerRef.current.observe(node)\n      }\n    },\n    [\n      threshold,\n      root,\n      rootMargin,\n      triggerOnce,\n      skip,\n      delay,\n      trackVisibility,\n      fallbackInView,\n      inView,\n    ]\n  )\n\n  useEffect(() => {\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current)\n      }\n    }\n  }, [])\n\n  return {\n    ref: setRef,\n    inView,\n    entry,\n  }\n}\n\n// Higher-order component for intersection observer\nexport function withIntersectionObserver<T extends object>(\n  Component: React.ComponentType<T>,\n  options: IntersectionObserverOptions = {}\n) {\n  const WrappedComponent = React.forwardRef<any, T & { onIntersect?: (inView: boolean) => void }>((props, ref) => {\n    const { onIntersect, ...componentProps } = props\n    const { ref: intersectionRef, inView } = useIntersectionObserver(options)\n\n    useEffect(() => {\n      onIntersect?.(inView)\n    }, [inView, onIntersect])\n\n    return (\n      <div ref={intersectionRef}>\n        <Component {...(componentProps as T)} ref={ref} />\n      </div>\n    )\n  })\n\n  WrappedComponent.displayName = `WithIntersectionObserver(${Component.displayName || Component.name})`\n  \n  return WrappedComponent\n}\n\n// Utility for batch intersection observer\nexport class BatchIntersectionObserver {\n  private observer: IntersectionObserver | null = null\n  private callbacks = new Map<Element, (entry: IntersectionObserverEntry) => void>()\n\n  constructor(private options: IntersectionObserverOptions = {}) {\n    if (hasIntersectionObserver) {\n      this.observer = createIntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            const callback = this.callbacks.get(entry.target)\n            if (callback) {\n              callback(entry)\n            }\n          })\n        },\n        options\n      )\n    }\n  }\n\n  observe(element: Element, callback: (entry: IntersectionObserverEntry) => void) {\n    if (!this.observer) {\n      // Fallback behavior\n      callback({\n        isIntersecting: this.options.fallbackInView || false,\n        target: element,\n      } as IntersectionObserverEntry)\n      return\n    }\n\n    this.callbacks.set(element, callback)\n    this.observer.observe(element)\n  }\n\n  unobserve(element: Element) {\n    if (this.observer) {\n      this.observer.unobserve(element)\n    }\n    this.callbacks.delete(element)\n  }\n\n  disconnect() {\n    if (this.observer) {\n      this.observer.disconnect()\n    }\n    this.callbacks.clear()\n  }\n}\n\n// Singleton batch observer for performance optimization\nlet globalBatchObserver: BatchIntersectionObserver | null = null\n\nexport function getGlobalBatchObserver(options: IntersectionObserverOptions = {}) {\n  if (!globalBatchObserver) {\n    globalBatchObserver = new BatchIntersectionObserver(options)\n  }\n  return globalBatchObserver\n}\n\n// Hook for using the global batch observer\nexport function useBatchIntersectionObserver(\n  callback: (entry: IntersectionObserverEntry) => void,\n  options: IntersectionObserverOptions = {}\n) {\n  const elementRef = useRef<Element | null>(null)\n  const batchObserver = getGlobalBatchObserver(options)\n\n  const setRef = useCallback(\n    (node: Element | null) => {\n      if (elementRef.current) {\n        batchObserver.unobserve(elementRef.current)\n      }\n\n      elementRef.current = node\n\n      if (node) {\n        batchObserver.observe(node, callback)\n      }\n    },\n    [batchObserver, callback]\n  )\n\n  useEffect(() => {\n    return () => {\n      if (elementRef.current) {\n        batchObserver.unobserve(elementRef.current)\n      }\n    }\n  }, [batchObserver])\n\n  return { ref: setRef }\n}\n\n// Performance monitoring for intersection observer\nexport function trackIntersectionPerformance(elementId: string) {\n  if (typeof window !== 'undefined' && 'performance' in window) {\n    const startTime = performance.now()\n    \n    return {\n      end: () => {\n        const endTime = performance.now()\n        const observationTime = endTime - startTime\n        \n        // Log performance metrics\n        console.log(`Intersection observation ${elementId}: ${observationTime.toFixed(2)}ms`)\n        \n        // Send to analytics if available\n        if ('gtag' in window) {\n          (window as any).gtag('event', 'intersection_performance', {\n            element_id: elementId,\n            observation_time: Math.round(observationTime),\n          })\n        }\n      }\n    }\n  }\n  \n  return { end: () => {} }\n}\n\n// Utility for creating viewport-based loading priorities\nexport function getViewportBasedPriority(element: Element): 'critical' | 'high' | 'medium' | 'low' {\n  if (typeof window === 'undefined') return 'medium'\n\n  const rect = element.getBoundingClientRect()\n  const viewportHeight = window.innerHeight\n  const viewportWidth = window.innerWidth\n\n  // Critical: Above the fold and in center of viewport\n  if (\n    rect.top >= 0 && \n    rect.bottom <= viewportHeight &&\n    rect.left >= viewportWidth * 0.25 &&\n    rect.right <= viewportWidth * 0.75\n  ) {\n    return 'critical'\n  }\n\n  // High: Above the fold\n  if (rect.top >= 0 && rect.top <= viewportHeight) {\n    return 'high'\n  }\n\n  // Medium: Within 2x viewport height\n  if (rect.top <= viewportHeight * 2) {\n    return 'medium'\n  }\n\n  // Low: Beyond 2x viewport height\n  return 'low'\n}\n\n// Utility for preloading elements based on scroll direction\nexport function useScrollDirectionOptimization() {\n  const [scrollDirection, setScrollDirection] = useState<'up' | 'down' | null>(null)\n  const lastScrollY = useRef(0)\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const currentScrollY = window.scrollY\n      \n      if (currentScrollY > lastScrollY.current) {\n        setScrollDirection('down')\n      } else if (currentScrollY < lastScrollY.current) {\n        setScrollDirection('up')\n      }\n      \n      lastScrollY.current = currentScrollY\n    }\n\n    window.addEventListener('scroll', handleScroll, { passive: true })\n    \n    return () => {\n      window.removeEventListener('scroll', handleScroll)\n    }\n  }, [])\n\n  return scrollDirection\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/lazy-card.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 182,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 182,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4852, 4855], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4852, 4855], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useRef, useEffect, Suspense } from 'react'\nimport { cn } from '@/lib/utils'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { Card, CardContent, CardHeader } from '@/components/ui/card'\n\ninterface LazyCardProps {\n  children: React.ReactNode\n  className?: string\n  fallback?: React.ReactNode\n  rootMargin?: string\n  threshold?: number\n  minHeight?: number\n  onIntersect?: () => void\n  onLoad?: () => void\n  priority?: 'low' | 'medium' | 'high' | 'critical'\n}\n\ninterface LazyCardSkeletonProps {\n  minHeight?: number\n  className?: string\n}\n\nfunction LazyCardSkeleton({ minHeight = 200, className }: LazyCardSkeletonProps) {\n  return (\n    <Card \n      className={cn('dashboard-card-skeleton', className)}\n      style={{ minHeight: `${minHeight}px` }}\n      role=\"status\"\n      aria-label=\"Loading card content\"\n    >\n      <CardHeader className=\"space-y-2\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <Skeleton className=\"h-5 w-5 rounded\" />\n            <div className=\"space-y-2\">\n              <Skeleton className=\"h-4 w-24\" />\n              <Skeleton className=\"h-3 w-16\" />\n            </div>\n          </div>\n          <Skeleton className=\"h-8 w-8 rounded\" />\n        </div>\n      </CardHeader>\n      <CardContent className=\"space-y-3\">\n        <div className=\"flex items-baseline space-x-2\">\n          <Skeleton className=\"h-8 w-16\" />\n          <Skeleton className=\"h-4 w-8\" />\n          <Skeleton className=\"h-6 w-12 rounded-full\" />\n        </div>\n        <Skeleton className=\"h-20 w-full rounded\" />\n      </CardContent>\n    </Card>\n  )\n}\n\nexport function LazyCard({\n  children,\n  className,\n  fallback,\n  rootMargin = '50px',\n  threshold = 0.1,\n  minHeight = 200,\n  onIntersect,\n  onLoad,\n  priority = 'medium',\n}: LazyCardProps) {\n  const [isIntersecting, setIsIntersecting] = useState(false)\n  const [hasLoaded, setHasLoaded] = useState(false)\n  const cardRef = useRef<HTMLDivElement>(null)\n  const observerRef = useRef<IntersectionObserver | null>(null)\n\n  // Priority-based loading delay\n  const getLoadingDelay = (priority: string) => {\n    switch (priority) {\n      case 'critical':\n        return 0\n      case 'high':\n        return 50\n      case 'medium':\n        return 100\n      case 'low':\n        return 200\n      default:\n        return 100\n    }\n  }\n\n  useEffect(() => {\n    const currentRef = cardRef.current\n    if (!currentRef) return\n\n    // Create intersection observer\n    observerRef.current = new IntersectionObserver(\n      (entries) => {\n        const [entry] = entries\n        if (entry.isIntersecting && !isIntersecting) {\n          // Add priority-based delay\n          const delay = getLoadingDelay(priority)\n          \n          setTimeout(() => {\n            setIsIntersecting(true)\n            onIntersect?.()\n            \n            // Disconnect observer after first intersection\n            if (observerRef.current) {\n              observerRef.current.disconnect()\n            }\n          }, delay)\n        }\n      },\n      {\n        rootMargin,\n        threshold,\n      }\n    )\n\n    observerRef.current.observe(currentRef)\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect()\n      }\n    }\n  }, [isIntersecting, rootMargin, threshold, priority, onIntersect])\n\n  // Handle load completion\n  useEffect(() => {\n    if (isIntersecting && !hasLoaded) {\n      // Small delay to ensure smooth loading\n      const timer = setTimeout(() => {\n        setHasLoaded(true)\n        onLoad?.()\n      }, 50)\n\n      return () => clearTimeout(timer)\n    }\n  }, [isIntersecting, hasLoaded, onLoad])\n\n  const defaultFallback = fallback || (\n    <LazyCardSkeleton \n      minHeight={minHeight} \n      className={className}\n    />\n  )\n\n  return (\n    <div\n      ref={cardRef}\n      className={cn(\n        'lazy-card-container',\n        // Priority-based styling\n        priority === 'critical' && 'lazy-card-critical',\n        priority === 'high' && 'lazy-card-high',\n        priority === 'medium' && 'lazy-card-medium',\n        priority === 'low' && 'lazy-card-low',\n        className\n      )}\n      style={{ minHeight: isIntersecting ? 'auto' : `${minHeight}px` }}\n    >\n      {isIntersecting ? (\n        <Suspense fallback={defaultFallback}>\n          <div className=\"lazy-card-content\">\n            {children}\n          </div>\n        </Suspense>\n      ) : (\n        defaultFallback\n      )}\n    </div>\n  )\n}\n\n// Higher-order component for wrapping existing cards with lazy loading\nexport function withLazyLoading<T extends object>(\n  Component: React.ComponentType<T>,\n  options?: {\n    rootMargin?: string\n    threshold?: number\n    minHeight?: number\n    priority?: 'low' | 'medium' | 'high' | 'critical'\n  }\n) {\n  const LazyWrappedComponent = React.forwardRef<any, T>((props, ref) => {\n    return (\n      <LazyCard\n        rootMargin={options?.rootMargin}\n        threshold={options?.threshold}\n        minHeight={options?.minHeight}\n        priority={options?.priority}\n      >\n        <Component {...props} ref={ref} />\n      </LazyCard>\n    )\n  })\n\n  LazyWrappedComponent.displayName = `LazyLoaded(${Component.displayName || Component.name})`\n  \n  return LazyWrappedComponent\n}\n\n// Hook for manual lazy loading control\nexport function useLazyLoading(\n  options: {\n    rootMargin?: string\n    threshold?: number\n    priority?: 'low' | 'medium' | 'high' | 'critical'\n  } = {}\n) {\n  const [isIntersecting, setIsIntersecting] = useState(false)\n  const [hasLoaded, setHasLoaded] = useState(false)\n  const elementRef = useRef<HTMLElement>(null)\n\n  useEffect(() => {\n    const currentRef = elementRef.current\n    if (!currentRef) return\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const [entry] = entries\n        if (entry.isIntersecting && !isIntersecting) {\n          const delay = options.priority === 'critical' ? 0 : \n                       options.priority === 'high' ? 50 :\n                       options.priority === 'medium' ? 100 : 200\n\n          setTimeout(() => {\n            setIsIntersecting(true)\n            setHasLoaded(true)\n            observer.disconnect()\n          }, delay)\n        }\n      },\n      {\n        rootMargin: options.rootMargin || '50px',\n        threshold: options.threshold || 0.1,\n      }\n    )\n\n    observer.observe(currentRef)\n\n    return () => observer.disconnect()\n  }, [isIntersecting, options.rootMargin, options.threshold, options.priority])\n\n  return {\n    elementRef,\n    isIntersecting,\n    hasLoaded,\n  }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/memoization.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'title' is defined but never used.",
        "line": 16,
        "column": 6,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'data' is defined but never used.",
        "line": 16,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'loading' is defined but never used.",
        "line": 16,
        "column": 19,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 16,
        "column": 28,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 16,
        "column": 68,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 16,
        "endColumn": 71,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [662, 665], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [662, 665], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'type' is defined but never used.",
        "line": 39,
        "column": 6,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 39,
        "endColumn": 10
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'data' is defined but never used.",
        "line": 39,
        "column": 12,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 39,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'config' is defined but never used.",
        "line": 39,
        "column": 18,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 39,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 39,
        "column": 57,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 39,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1349, 1352], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1349, 1352], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 62,
        "column": 57,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 62,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2106, 2109], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2106, 2109], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 143,
        "column": 57,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 143,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4343, 4346], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4343, 4346], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 143,
        "column": 67,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 143,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4353, 4356], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4353, 4356], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead.",
        "line": 147,
        "column": 10,
        "nodeType": "Identifier",
        "endLine": 147,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 184,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 184,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5316, 5319], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5316, 5319], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 239,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 239,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7078, 7081], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7078, 7081], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 369,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 369,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10534, 10537], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10534, 10537], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { memo, useMemo, useCallback, useRef, useEffect } from 'react'\nimport { cn } from '@/lib/utils'\n\n// Performance-optimized memo wrapper with custom comparison\nexport function createMemoizedComponent<T extends object>(\n  Component: React.ComponentType<T>,\n  customCompare?: (prevProps: T, nextProps: T) => boolean\n) {\n  const MemoizedComponent = memo(Component, customCompare)\n  MemoizedComponent.displayName = `Memoized(${Component.displayName || Component.name})`\n  return MemoizedComponent\n}\n\n// Dashboard-specific memoization for cards\nexport const MemoizedDashboardCard = memo(\n  ({ title, data, loading, error, children, className, ...props }: any) => {\n    return (\n      <div className={cn('dashboard-card', className)} {...props}>\n        {children}\n      </div>\n    )\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison for dashboard cards\n    return (\n      prevProps.title === nextProps.title &&\n      prevProps.loading === nextProps.loading &&\n      prevProps.error === nextProps.error &&\n      JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data) &&\n      prevProps.className === nextProps.className\n    )\n  }\n)\n\nMemoizedDashboardCard.displayName = 'MemoizedDashboardCard'\n\n// Chart-specific memoization\nexport const MemoizedChartWrapper = memo(\n  ({ type, data, config, height, className, ...props }: any) => {\n    return (\n      <div className={cn('chart-wrapper', className)} style={{ height }} {...props}>\n        {/* Chart content would go here */}\n      </div>\n    )\n  },\n  (prevProps, nextProps) => {\n    // Deep comparison for chart data and config\n    return (\n      prevProps.type === nextProps.type &&\n      prevProps.height === nextProps.height &&\n      prevProps.className === nextProps.className &&\n      JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data) &&\n      JSON.stringify(prevProps.config) === JSON.stringify(nextProps.config)\n    )\n  }\n)\n\nMemoizedChartWrapper.displayName = 'MemoizedChartWrapper'\n\n// Metric card memoization\nexport const MemoizedMetricCard = memo(\n  ({ metric, trend, unit, label, className, ...props }: any) => {\n    return (\n      <div className={cn('metric-card', className)} {...props}>\n        <div className=\"metric-value\">{metric}</div>\n        <div className=\"metric-label\">{label}</div>\n        {trend && <div className=\"metric-trend\">{trend}</div>}\n        {unit && <div className=\"metric-unit\">{unit}</div>}\n      </div>\n    )\n  },\n  (prevProps, nextProps) => {\n    // Shallow comparison for metric cards\n    return (\n      prevProps.metric === nextProps.metric &&\n      prevProps.trend === nextProps.trend &&\n      prevProps.unit === nextProps.unit &&\n      prevProps.label === nextProps.label &&\n      prevProps.className === nextProps.className\n    )\n  }\n)\n\nMemoizedMetricCard.displayName = 'MemoizedMetricCard'\n\n// Hook for memoizing expensive calculations\nexport function useMemoizedCalculation<T>(\n  calculation: () => T,\n  dependencies: React.DependencyList,\n  options?: {\n    maxAge?: number // Cache duration in milliseconds\n    key?: string    // Cache key for debugging\n  }\n): T {\n  const cacheRef = useRef<{\n    value: T\n    timestamp: number\n    deps: React.DependencyList\n  } | null>(null)\n\n  return useMemo(() => {\n    const now = Date.now()\n    const cache = cacheRef.current\n\n    // Check if we have a valid cache\n    if (\n      cache &&\n      (!options?.maxAge || now - cache.timestamp < options.maxAge) &&\n      dependencies.length === cache.deps.length &&\n      dependencies.every((dep, index) => dep === cache.deps[index])\n    ) {\n      if (options?.key) {\n        console.log(`Cache hit for ${options.key}`)\n      }\n      return cache.value\n    }\n\n    // Calculate new value\n    if (options?.key) {\n      console.log(`Cache miss for ${options.key}, recalculating...`)\n    }\n\n    const startTime = performance.now()\n    const value = calculation()\n    const endTime = performance.now()\n\n    if (options?.key) {\n      console.log(`Calculation ${options.key} took ${(endTime - startTime).toFixed(2)}ms`)\n    }\n\n    // Update cache\n    cacheRef.current = {\n      value,\n      timestamp: now,\n      deps: [...dependencies],\n    }\n\n    return value\n  }, [calculation, dependencies, options?.key, options?.maxAge])\n}\n\n// Hook for memoizing callback functions\nexport function useMemoizedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  dependencies: React.DependencyList\n): T {\n  return useCallback(callback, dependencies)\n}\n\n// Hook for stable object references\nexport function useStableObject<T extends object>(obj: T): T {\n  const stableRef = useRef<T>(obj)\n  \n  // Only update if the object has actually changed\n  const hasChanged = useMemo(() => {\n    const current = stableRef.current\n    \n    // Shallow comparison\n    if (Object.keys(current).length !== Object.keys(obj).length) {\n      return true\n    }\n    \n    for (const key in obj) {\n      if (current[key] !== obj[key]) {\n        return true\n      }\n    }\n    \n    return false\n  }, [obj])\n  \n  if (hasChanged) {\n    stableRef.current = obj\n  }\n  \n  return stableRef.current\n}\n\n// Performance monitoring for memoized components\nexport function withPerformanceMonitoring<T extends object>(\n  Component: React.ComponentType<T>,\n  componentName?: string\n) {\n  const PerformanceMonitoredComponent = React.forwardRef<any, T>((props, ref) => {\n    const renderCountRef = useRef(0)\n    const lastRenderTime = useRef(0)\n    \n    useEffect(() => {\n      renderCountRef.current += 1\n      const now = performance.now()\n      \n      if (lastRenderTime.current > 0) {\n        const timeSinceLastRender = now - lastRenderTime.current\n        console.log(\n          `${componentName || Component.displayName || Component.name} render #${renderCountRef.current} ` +\n          `(${timeSinceLastRender.toFixed(2)}ms since last render)`\n        )\n      }\n      \n      lastRenderTime.current = now\n    })\n    \n    const renderStart = performance.now()\n    \n    useEffect(() => {\n      const renderEnd = performance.now()\n      const renderTime = renderEnd - renderStart\n      \n      if (renderTime > 16) { // Flag slow renders (>16ms = <60fps)\n        console.warn(\n          `Slow render detected: ${componentName || Component.displayName || Component.name} ` +\n          `took ${renderTime.toFixed(2)}ms to render`\n        )\n      }\n    })\n    \n    return <Component {...props} ref={ref} />\n  })\n  \n  PerformanceMonitoredComponent.displayName = `WithPerformanceMonitoring(${componentName || Component.displayName || Component.name})`\n  \n  return PerformanceMonitoredComponent\n}\n\n// Render optimization utilities\nexport class RenderOptimizer {\n  private static renderQueue: Array<() => void> = []\n  private static isProcessing = false\n  \n  // Batch multiple state updates\n  static batchUpdates(updates: Array<() => void>) {\n    this.renderQueue.push(...updates)\n    \n    if (!this.isProcessing) {\n      this.isProcessing = true\n      \n      // Use scheduler if available, otherwise fallback to setTimeout\n      if (typeof window !== 'undefined' && 'scheduler' in window) {\n        (window as any).scheduler.postTask(() => {\n          this.processQueue()\n        }, { priority: 'user-blocking' })\n      } else {\n        setTimeout(() => {\n          this.processQueue()\n        }, 0)\n      }\n    }\n  }\n  \n  private static processQueue() {\n    const updates = [...this.renderQueue]\n    this.renderQueue.length = 0\n    \n    // Execute all updates in a single batch\n    React.unstable_batchedUpdates(() => {\n      updates.forEach(update => update())\n    })\n    \n    this.isProcessing = false\n    \n    // Process any new updates that were added during processing\n    if (this.renderQueue.length > 0) {\n      this.batchUpdates([])\n    }\n  }\n  \n  // Debounce rapid updates\n  static debounceUpdate(\n    updateFn: () => void,\n    delay: number = 100,\n    key: string = 'default'\n  ) {\n    const timers = this.debounceTimers || (this.debounceTimers = new Map())\n    \n    if (timers.has(key)) {\n      clearTimeout(timers.get(key))\n    }\n    \n    timers.set(key, setTimeout(() => {\n      updateFn()\n      timers.delete(key)\n    }, delay))\n  }\n  \n  private static debounceTimers: Map<string, NodeJS.Timeout>\n  \n  // Throttle high-frequency updates\n  static throttleUpdate(\n    updateFn: () => void,\n    delay: number = 16, // ~60fps\n    key: string = 'default'\n  ) {\n    const lastExecution = this.throttleTimestamps || (this.throttleTimestamps = new Map())\n    const now = Date.now()\n    const lastTime = lastExecution.get(key) || 0\n    \n    if (now - lastTime >= delay) {\n      updateFn()\n      lastExecution.set(key, now)\n    }\n  }\n  \n  private static throttleTimestamps: Map<string, number>\n}\n\n// Hook for optimized re-renders\nexport function useOptimizedRender() {\n  const [, forceRender] = React.useReducer(x => x + 1, 0)\n  \n  const scheduleUpdate = useCallback((priority: 'low' | 'normal' | 'high' = 'normal') => {\n    switch (priority) {\n      case 'high':\n        // Immediate update\n        forceRender()\n        break\n      case 'normal':\n        // Batched update\n        RenderOptimizer.batchUpdates([forceRender])\n        break\n      case 'low':\n        // Debounced update\n        RenderOptimizer.debounceUpdate(forceRender, 100)\n        break\n    }\n  }, [])\n  \n  return { scheduleUpdate }\n}\n\n// Component for preventing unnecessary re-renders of children\nexport const RenderBarrier = memo(({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>\n})\n\nRenderBarrier.displayName = 'RenderBarrier'\n\n// Hook for tracking render performance\nexport function useRenderPerformance(componentName: string) {\n  const renderCount = useRef(0)\n  const renderTimes = useRef<number[]>([])\n  const startTime = useRef(0)\n  \n  // Mark render start\n  startTime.current = performance.now()\n  \n  useEffect(() => {\n    const endTime = performance.now()\n    const renderTime = endTime - startTime.current\n    \n    renderCount.current += 1\n    renderTimes.current.push(renderTime)\n    \n    // Keep only last 10 render times\n    if (renderTimes.current.length > 10) {\n      renderTimes.current.shift()\n    }\n    \n    const avgRenderTime = renderTimes.current.reduce((a, b) => a + b, 0) / renderTimes.current.length\n    \n    if (renderTime > 16) {\n      console.warn(\n        `${componentName} slow render: ${renderTime.toFixed(2)}ms ` +\n        `(avg: ${avgRenderTime.toFixed(2)}ms, count: ${renderCount.current})`\n      )\n    }\n    \n    // Send performance data to analytics\n    if (typeof window !== 'undefined' && 'gtag' in window) {\n      (window as any).gtag('event', 'component_render_performance', {\n        component_name: componentName,\n        render_time: Math.round(renderTime),\n        render_count: renderCount.current,\n        avg_render_time: Math.round(avgRenderTime),\n      })\n    }\n  })\n  \n  return {\n    renderCount: renderCount.current,\n    averageRenderTime: renderTimes.current.length > 0 \n      ? renderTimes.current.reduce((a, b) => a + b, 0) / renderTimes.current.length \n      : 0,\n  }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/progressive-loader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/viewport-skeleton.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'getViewportBasedPriority' is defined but never used.",
        "line": 5,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 499,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 499,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14805, 14808], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14805, 14808], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useMemo } from 'react'\nimport { cn } from '@/lib/utils'\nimport { Skeleton } from '@/components/ui/skeleton'\nimport { Card, CardContent, CardHeader } from '@/components/ui/card'\nimport { useIntersectionObserver, getViewportBasedPriority } from './intersection-observer'\n\ninterface ViewportSkeletonProps {\n  children: React.ReactNode\n  className?: string\n  variant?: 'card' | 'chart' | 'table' | 'metric' | 'list' | 'grid'\n  priority?: 'critical' | 'high' | 'medium' | 'low' | 'auto'\n  height?: number\n  width?: number\n  rows?: number\n  columns?: number\n  animated?: boolean\n  showShimmer?: boolean\n  adaptiveComplexity?: boolean\n  onVisibilityChange?: (visible: boolean) => void\n}\n\ninterface SkeletonConfig {\n  baseDelay: number\n  complexityMultiplier: number\n  animationDuration: string\n  shimmerIntensity: number\n}\n\n// Priority-based skeleton configurations\nconst SKELETON_CONFIGS: Record<string, SkeletonConfig> = {\n  critical: {\n    baseDelay: 0,\n    complexityMultiplier: 1,\n    animationDuration: '1s',\n    shimmerIntensity: 0.8,\n  },\n  high: {\n    baseDelay: 50,\n    complexityMultiplier: 0.8,\n    animationDuration: '1.2s',\n    shimmerIntensity: 0.6,\n  },\n  medium: {\n    baseDelay: 100,\n    complexityMultiplier: 0.6,\n    animationDuration: '1.5s',\n    shimmerIntensity: 0.4,\n  },\n  low: {\n    baseDelay: 200,\n    complexityMultiplier: 0.4,\n    animationDuration: '2s',\n    shimmerIntensity: 0.2,\n  },\n}\n\nexport function ViewportSkeleton({\n  children,\n  className,\n  variant = 'card',\n  priority = 'auto',\n  height = 200,\n  width,\n  rows = 3,\n  columns = 3,\n  animated = true,\n  showShimmer = true,\n  adaptiveComplexity = true,\n  onVisibilityChange,\n}: ViewportSkeletonProps) {\n  const { ref, inView } = useIntersectionObserver({\n    threshold: 0.1,\n    rootMargin: '50px',\n    triggerOnce: true,\n  })\n\n  // Determine priority automatically based on viewport position\n  const effectivePriority = useMemo(() => {\n    if (priority !== 'auto') return priority\n    \n    // Get priority based on viewport position when element is available\n    return 'medium' // Default fallback\n  }, [priority])\n\n  const config = SKELETON_CONFIGS[effectivePriority]\n\n  // Handle visibility changes\n  React.useEffect(() => {\n    onVisibilityChange?.(inView)\n  }, [inView, onVisibilityChange])\n\n  // Render appropriate skeleton based on variant\n  const skeletonContent = useMemo(() => {\n    const baseProps = {\n      animated,\n      showShimmer,\n      config,\n      adaptiveComplexity,\n    }\n\n    switch (variant) {\n      case 'card':\n        return <CardSkeleton {...baseProps} height={height} />\n      case 'chart':\n        return <ChartSkeleton {...baseProps} height={height} />\n      case 'table':\n        return <TableSkeleton {...baseProps} rows={rows} columns={columns} />\n      case 'metric':\n        return <MetricSkeleton {...baseProps} />\n      case 'list':\n        return <ListSkeleton {...baseProps} rows={rows} />\n      case 'grid':\n        return <GridSkeleton {...baseProps} rows={rows} columns={columns} />\n      default:\n        return <CardSkeleton {...baseProps} height={height} />\n    }\n  }, [variant, height, rows, columns, animated, showShimmer, config, adaptiveComplexity])\n\n  // Render content if in view\n  if (inView) {\n    return <div className={className}>{children}</div>\n  }\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        'viewport-skeleton',\n        `viewport-skeleton-${variant}`,\n        `viewport-skeleton-priority-${effectivePriority}`,\n        className\n      )}\n      style={{\n        minHeight: height,\n        width: width ? `${width}px` : undefined,\n      }}\n      role=\"status\"\n      aria-label={`Loading ${variant} content`}\n    >\n      {skeletonContent}\n    </div>\n  )\n}\n\n// Individual skeleton components\ninterface SkeletonComponentProps {\n  animated: boolean\n  showShimmer: boolean\n  config: SkeletonConfig\n  adaptiveComplexity: boolean\n}\n\nfunction CardSkeleton({ \n  animated, \n  showShimmer, \n  config, \n  adaptiveComplexity,\n  height = 200 \n}: SkeletonComponentProps & { height?: number }) {\n  const complexity = adaptiveComplexity ? config.complexityMultiplier : 1\n  const elementCount = Math.max(1, Math.floor(3 * complexity))\n\n  return (\n    <Card \n      className={cn(\n        'dashboard-card-skeleton',\n        showShimmer && 'skeleton-shimmer',\n        !animated && 'skeleton-no-animation'\n      )}\n      style={{ \n        minHeight: `${height}px`,\n        '--skeleton-animation-duration': config.animationDuration,\n        '--skeleton-shimmer-intensity': config.shimmerIntensity,\n      } as React.CSSProperties}\n    >\n      <CardHeader className=\"space-y-2\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <Skeleton className=\"h-5 w-5 rounded\" />\n            <div className=\"space-y-2\">\n              <Skeleton className=\"h-4 w-24\" />\n              {complexity > 0.5 && <Skeleton className=\"h-3 w-16\" />}\n            </div>\n          </div>\n          <Skeleton className=\"h-8 w-8 rounded\" />\n        </div>\n      </CardHeader>\n      <CardContent className=\"space-y-3\">\n        {complexity > 0.7 && (\n          <div className=\"flex items-baseline space-x-2\">\n            <Skeleton className=\"h-8 w-16\" />\n            <Skeleton className=\"h-4 w-8\" />\n            <Skeleton className=\"h-6 w-12 rounded-full\" />\n          </div>\n        )}\n        <div className=\"space-y-2\">\n          {Array.from({ length: elementCount }).map((_, i) => (\n            <Skeleton \n              key={i} \n              className=\"h-4 w-full\" \n              style={{ \n                width: `${Math.random() * 40 + 60}%`,\n                animationDelay: `${i * 100}ms`\n              }} \n            />\n          ))}\n        </div>\n        <Skeleton className=\"h-20 w-full rounded\" />\n      </CardContent>\n    </Card>\n  )\n}\n\nfunction ChartSkeleton({ \n  animated, \n  showShimmer, \n  config, \n  adaptiveComplexity,\n  height = 300 \n}: SkeletonComponentProps & { height?: number }) {\n  const complexity = adaptiveComplexity ? config.complexityMultiplier : 1\n  const barCount = Math.max(3, Math.floor(8 * complexity))\n  const legendCount = Math.max(1, Math.floor(3 * complexity))\n\n  return (\n    <Card \n      className={cn(\n        'dashboard-card-skeleton',\n        showShimmer && 'skeleton-shimmer',\n        !animated && 'skeleton-no-animation'\n      )}\n      style={{\n        '--skeleton-animation-duration': config.animationDuration,\n        '--skeleton-shimmer-intensity': config.shimmerIntensity,\n      } as React.CSSProperties}\n    >\n      <CardHeader>\n        <div className=\"flex items-center justify-between\">\n          <Skeleton className=\"h-5 w-32\" />\n          <Skeleton className=\"h-8 w-8 rounded\" />\n        </div>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-4\">\n          {/* Chart area */}\n          <div \n            className=\"flex justify-between items-end\" \n            style={{ height: `${height}px` }}\n          >\n            {Array.from({ length: barCount }).map((_, i) => (\n              <Skeleton\n                key={i}\n                className=\"w-8\"\n                style={{ \n                  height: `${Math.random() * 80 + 20}%`,\n                  animationDelay: `${i * 50}ms`\n                }}\n              />\n            ))}\n          </div>\n          \n          {/* Legend */}\n          {complexity > 0.5 && (\n            <div className=\"flex justify-center space-x-4\">\n              {Array.from({ length: legendCount }).map((_, i) => (\n                <div key={i} className=\"flex items-center space-x-2\">\n                  <Skeleton className=\"h-3 w-3 rounded-full\" />\n                  <Skeleton className=\"h-3 w-16\" />\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\nfunction TableSkeleton({ \n  animated, \n  showShimmer, \n  config, \n  adaptiveComplexity,\n  rows = 5,\n  columns = 4 \n}: SkeletonComponentProps & { rows?: number; columns?: number }) {\n  const complexity = adaptiveComplexity ? config.complexityMultiplier : 1\n  const effectiveRows = Math.max(1, Math.floor(rows * complexity))\n  const effectiveColumns = Math.max(1, Math.floor(columns * complexity))\n\n  return (\n    <Card \n      className={cn(\n        'dashboard-card-skeleton',\n        showShimmer && 'skeleton-shimmer',\n        !animated && 'skeleton-no-animation'\n      )}\n      style={{\n        '--skeleton-animation-duration': config.animationDuration,\n        '--skeleton-shimmer-intensity': config.shimmerIntensity,\n      } as React.CSSProperties}\n    >\n      <CardHeader>\n        <Skeleton className=\"h-5 w-32\" />\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-3\">\n          {/* Table header */}\n          <div \n            className=\"grid gap-4\" \n            style={{ gridTemplateColumns: `repeat(${effectiveColumns}, 1fr)` }}\n          >\n            {Array.from({ length: effectiveColumns }).map((_, i) => (\n              <Skeleton \n                key={i} \n                className=\"h-4 w-full\" \n                style={{ animationDelay: `${i * 50}ms` }}\n              />\n            ))}\n          </div>\n          \n          {/* Table rows */}\n          {Array.from({ length: effectiveRows }).map((_, rowIndex) => (\n            <div \n              key={rowIndex} \n              className=\"grid gap-4\" \n              style={{ gridTemplateColumns: `repeat(${effectiveColumns}, 1fr)` }}\n            >\n              {Array.from({ length: effectiveColumns }).map((_, colIndex) => (\n                <Skeleton \n                  key={colIndex} \n                  className=\"h-4 w-full\" \n                  style={{ \n                    animationDelay: `${(rowIndex * effectiveColumns + colIndex) * 25}ms` \n                  }}\n                />\n              ))}\n            </div>\n          ))}\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\nfunction MetricSkeleton({ \n  animated, \n  showShimmer, \n  config, \n  adaptiveComplexity \n}: SkeletonComponentProps) {\n  const complexity = adaptiveComplexity ? config.complexityMultiplier : 1\n\n  return (\n    <Card \n      className={cn(\n        'dashboard-card-skeleton',\n        showShimmer && 'skeleton-shimmer',\n        !animated && 'skeleton-no-animation'\n      )}\n      style={{\n        '--skeleton-animation-duration': config.animationDuration,\n        '--skeleton-shimmer-intensity': config.shimmerIntensity,\n      } as React.CSSProperties}\n    >\n      <CardHeader>\n        <div className=\"flex items-center space-x-2\">\n          <Skeleton className=\"h-5 w-5 rounded\" />\n          <Skeleton className=\"h-4 w-24\" />\n        </div>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-3\">\n          <div className=\"flex items-baseline space-x-2\">\n            <Skeleton className=\"h-8 w-16\" />\n            <Skeleton className=\"h-4 w-8\" />\n            {complexity > 0.6 && <Skeleton className=\"h-6 w-12 rounded-full\" />}\n          </div>\n          {complexity > 0.4 && <Skeleton className=\"h-4 w-3/4\" />}\n          {complexity > 0.7 && (\n            <div className=\"flex space-x-2\">\n              <Skeleton className=\"h-3 w-3 rounded-full\" />\n              <Skeleton className=\"h-3 w-16\" />\n            </div>\n          )}\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\nfunction ListSkeleton({ \n  animated, \n  showShimmer, \n  config, \n  adaptiveComplexity,\n  rows = 5 \n}: SkeletonComponentProps & { rows?: number }) {\n  const complexity = adaptiveComplexity ? config.complexityMultiplier : 1\n  const effectiveRows = Math.max(1, Math.floor(rows * complexity))\n\n  return (\n    <Card \n      className={cn(\n        'dashboard-card-skeleton',\n        showShimmer && 'skeleton-shimmer',\n        !animated && 'skeleton-no-animation'\n      )}\n      style={{\n        '--skeleton-animation-duration': config.animationDuration,\n        '--skeleton-shimmer-intensity': config.shimmerIntensity,\n      } as React.CSSProperties}\n    >\n      <CardHeader>\n        <Skeleton className=\"h-5 w-32\" />\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-3\">\n          {Array.from({ length: effectiveRows }).map((_, i) => (\n            <div key={i} className=\"flex items-center space-x-3\">\n              {complexity > 0.5 && <Skeleton className=\"h-8 w-8 rounded-full\" />}\n              <div className=\"flex-1 space-y-2\">\n                <Skeleton \n                  className=\"h-4 w-full\" \n                  style={{ \n                    width: `${Math.random() * 40 + 60}%`,\n                    animationDelay: `${i * 100}ms`\n                  }}\n                />\n                {complexity > 0.7 && (\n                  <Skeleton \n                    className=\"h-3 w-full\" \n                    style={{ \n                      width: `${Math.random() * 30 + 40}%`,\n                      animationDelay: `${i * 100 + 50}ms`\n                    }}\n                  />\n                )}\n              </div>\n              {complexity > 0.6 && <Skeleton className=\"h-6 w-6 rounded\" />}\n            </div>\n          ))}\n        </div>\n      </CardContent>\n    </Card>\n  )\n}\n\nfunction GridSkeleton({ \n  animated, \n  showShimmer, \n  config, \n  adaptiveComplexity,\n  rows = 3,\n  columns = 3 \n}: SkeletonComponentProps & { rows?: number; columns?: number }) {\n  const complexity = adaptiveComplexity ? config.complexityMultiplier : 1\n  const effectiveRows = Math.max(1, Math.floor(rows * complexity))\n  const effectiveColumns = Math.max(1, Math.floor(columns * complexity))\n\n  return (\n    <div \n      className={cn(\n        'grid gap-4',\n        showShimmer && 'skeleton-shimmer',\n        !animated && 'skeleton-no-animation'\n      )}\n      style={{ \n        gridTemplateColumns: `repeat(${effectiveColumns}, 1fr)`,\n        '--skeleton-animation-duration': config.animationDuration,\n        '--skeleton-shimmer-intensity': config.shimmerIntensity,\n      } as React.CSSProperties}\n    >\n      {Array.from({ length: effectiveRows * effectiveColumns }).map((_, i) => (\n        <Card key={i} className=\"dashboard-card-skeleton\">\n          <CardContent className=\"p-4\">\n            <div className=\"space-y-2\">\n              <Skeleton \n                className=\"h-4 w-3/4\" \n                style={{ animationDelay: `${i * 50}ms` }}\n              />\n              <Skeleton \n                className=\"h-16 w-full rounded\" \n                style={{ animationDelay: `${i * 50 + 25}ms` }}\n              />\n            </div>\n          </CardContent>\n        </Card>\n      ))}\n    </div>\n  )\n}\n\n// Higher-order component for adding viewport-based skeleton loading\nexport function withViewportSkeleton<T extends object>(\n  Component: React.ComponentType<T>,\n  skeletonOptions: Omit<ViewportSkeletonProps, 'children'> = {}\n) {\n  const WrappedComponent = React.forwardRef<any, T>((props, ref) => {\n    return (\n      <ViewportSkeleton {...skeletonOptions}>\n        <Component {...props} ref={ref} />\n      </ViewportSkeleton>\n    )\n  })\n\n  WrappedComponent.displayName = `WithViewportSkeleton(${Component.displayName || Component.name})`\n  \n  return WrappedComponent\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/performance/virtualization.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 21,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 21,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [584, 587], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [584, 587], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'totalWidth' is assigned a value but never used.",
        "line": 170,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 170,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'index' is defined but never used.",
        "line": 187,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 187,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 254,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 254,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6922, 6925], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6922, 6925], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 255,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 255,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6976, 6979], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6976, 6979], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react'\nimport { cn } from '@/lib/utils'\n\ninterface VirtualizedListProps<T> {\n  items: T[]\n  itemHeight: number\n  containerHeight: number\n  renderItem: (item: T, index: number, style: React.CSSProperties) => React.ReactNode\n  overscan?: number\n  className?: string\n  onScroll?: (scrollTop: number) => void\n  getItemKey?: (item: T, index: number) => string | number\n}\n\ninterface VirtualizedTableProps<T> {\n  data: T[]\n  columns: Array<{\n    key: string\n    header: string\n    width?: number\n    render?: (value: any, item: T, index: number) => React.ReactNode\n  }>\n  rowHeight: number\n  containerHeight: number\n  overscan?: number\n  className?: string\n  onRowClick?: (item: T, index: number) => void\n  getRowKey?: (item: T, index: number) => string | number\n}\n\ninterface VirtualizedGridProps<T> {\n  items: T[]\n  itemWidth: number\n  itemHeight: number\n  containerWidth: number\n  containerHeight: number\n  columnsCount: number\n  renderItem: (item: T, index: number, style: React.CSSProperties) => React.ReactNode\n  overscan?: number\n  className?: string\n  gap?: number\n  getItemKey?: (item: T, index: number) => string | number\n}\n\n// Virtualized List Component\nexport function VirtualizedList<T>({\n  items,\n  itemHeight,\n  containerHeight,\n  renderItem,\n  overscan = 5,\n  className,\n  onScroll,\n  getItemKey,\n}: VirtualizedListProps<T>) {\n  const [scrollTop, setScrollTop] = useState(0)\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  // Calculate visible range\n  const { startIndex, endIndex, totalHeight } = useMemo(() => {\n    const visibleStart = Math.floor(scrollTop / itemHeight)\n    const visibleEnd = Math.min(\n      items.length - 1,\n      Math.ceil((scrollTop + containerHeight) / itemHeight)\n    )\n\n    return {\n      startIndex: Math.max(0, visibleStart - overscan),\n      endIndex: Math.min(items.length - 1, visibleEnd + overscan),\n      totalHeight: items.length * itemHeight,\n    }\n  }, [scrollTop, itemHeight, containerHeight, items.length, overscan])\n\n  // Handle scroll events\n  const handleScroll = useCallback((event: React.UIEvent<HTMLDivElement>) => {\n    const newScrollTop = event.currentTarget.scrollTop\n    setScrollTop(newScrollTop)\n    onScroll?.(newScrollTop)\n  }, [onScroll])\n\n  // Render visible items\n  const visibleItems = useMemo(() => {\n    const items_to_render = []\n    \n    for (let i = startIndex; i <= endIndex; i++) {\n      const item = items[i]\n      if (!item) continue\n\n      const style: React.CSSProperties = {\n        position: 'absolute',\n        top: i * itemHeight,\n        left: 0,\n        right: 0,\n        height: itemHeight,\n      }\n\n      const key = getItemKey ? getItemKey(item, i) : i\n\n      items_to_render.push(\n        <div key={key} style={style}>\n          {renderItem(item, i, style)}\n        </div>\n      )\n    }\n\n    return items_to_render\n  }, [items, startIndex, endIndex, itemHeight, renderItem, getItemKey])\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn('virtualized-list', className)}\n      style={{\n        height: containerHeight,\n        overflow: 'auto',\n        position: 'relative',\n      }}\n      onScroll={handleScroll}\n      role=\"list\"\n      aria-label={`Virtualized list with ${items.length} items`}\n    >\n      <div\n        style={{\n          height: totalHeight,\n          position: 'relative',\n        }}\n      >\n        {visibleItems}\n      </div>\n    </div>\n  )\n}\n\n// Virtualized Table Component\nexport function VirtualizedTable<T>({\n  data,\n  columns,\n  rowHeight,\n  containerHeight,\n  overscan = 5,\n  className,\n  onRowClick,\n  getRowKey,\n}: VirtualizedTableProps<T>) {\n  const [scrollTop, setScrollTop] = useState(0)\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  // Calculate visible range\n  const { startIndex, endIndex, totalHeight } = useMemo(() => {\n    const visibleStart = Math.floor(scrollTop / rowHeight)\n    const visibleEnd = Math.min(\n      data.length - 1,\n      Math.ceil((scrollTop + containerHeight) / rowHeight)\n    )\n\n    return {\n      startIndex: Math.max(0, visibleStart - overscan),\n      endIndex: Math.min(data.length - 1, visibleEnd + overscan),\n      totalHeight: data.length * rowHeight,\n    }\n  }, [scrollTop, rowHeight, containerHeight, data.length, overscan])\n\n  // Handle scroll events\n  const handleScroll = useCallback((event: React.UIEvent<HTMLDivElement>) => {\n    const newScrollTop = event.currentTarget.scrollTop\n    setScrollTop(newScrollTop)\n  }, [])\n\n  // Calculate column widths\n  const totalWidth = columns.reduce((sum, col) => sum + (col.width || 100), 0)\n\n  // Render table header\n  const tableHeader = (\n    <div\n      className=\"virtualized-table-header\"\n      style={{\n        position: 'sticky',\n        top: 0,\n        zIndex: 1,\n        backgroundColor: 'var(--dashboard-surface)',\n        borderBottom: '1px solid var(--dashboard-border)',\n        display: 'flex',\n        height: rowHeight,\n        alignItems: 'center',\n      }}\n    >\n      {columns.map((column, index) => (\n        <div\n          key={column.key}\n          className=\"table-header-cell\"\n          style={{\n            width: column.width || 100,\n            padding: '0 8px',\n            fontWeight: 'var(--dashboard-font-semibold)',\n            fontSize: 'var(--dashboard-text-sm)',\n          }}\n        >\n          {column.header}\n        </div>\n      ))}\n    </div>\n  )\n\n  // Render visible rows\n  const visibleRows = useMemo(() => {\n    const rows = []\n    \n    for (let i = startIndex; i <= endIndex; i++) {\n      const item = data[i]\n      if (!item) continue\n\n      const key = getRowKey ? getRowKey(item, i) : i\n\n      rows.push(\n        <div\n          key={key}\n          className=\"virtualized-table-row\"\n          style={{\n            position: 'absolute',\n            top: i * rowHeight,\n            left: 0,\n            right: 0,\n            height: rowHeight,\n            display: 'flex',\n            alignItems: 'center',\n            borderBottom: '1px solid var(--dashboard-border)',\n            cursor: onRowClick ? 'pointer' : 'default',\n          }}\n          onClick={() => onRowClick?.(item, i)}\n          role=\"row\"\n          tabIndex={onRowClick ? 0 : -1}\n          onKeyDown={(e) => {\n            if (onRowClick && (e.key === 'Enter' || e.key === ' ')) {\n              e.preventDefault()\n              onRowClick(item, i)\n            }\n          }}\n        >\n          {columns.map((column) => (\n            <div\n              key={column.key}\n              className=\"table-cell\"\n              style={{\n                width: column.width || 100,\n                padding: '0 8px',\n                fontSize: 'var(--dashboard-text-sm)',\n                overflow: 'hidden',\n                textOverflow: 'ellipsis',\n                whiteSpace: 'nowrap',\n              }}\n              role=\"cell\"\n            >\n              {column.render \n                ? column.render((item as any)[column.key], item, i)\n                : (item as any)[column.key]\n              }\n            </div>\n          ))}\n        </div>\n      )\n    }\n\n    return rows\n  }, [data, columns, startIndex, endIndex, rowHeight, onRowClick, getRowKey])\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn('virtualized-table', className)}\n      style={{\n        height: containerHeight,\n        overflow: 'auto',\n        position: 'relative',\n        border: '1px solid var(--dashboard-border)',\n        borderRadius: 'var(--dashboard-radius-md)',\n      }}\n      onScroll={handleScroll}\n      role=\"table\"\n      aria-label={`Virtualized table with ${data.length} rows`}\n    >\n      {tableHeader}\n      <div\n        style={{\n          height: totalHeight,\n          position: 'relative',\n          marginTop: rowHeight, // Account for header\n        }}\n      >\n        {visibleRows}\n      </div>\n    </div>\n  )\n}\n\n// Virtualized Grid Component\nexport function VirtualizedGrid<T>({\n  items,\n  itemWidth,\n  itemHeight,\n  containerWidth,\n  containerHeight,\n  columnsCount,\n  renderItem,\n  overscan = 5,\n  className,\n  gap = 0,\n  getItemKey,\n}: VirtualizedGridProps<T>) {\n  const [scrollTop, setScrollTop] = useState(0)\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  // Calculate grid dimensions\n  const rowsCount = Math.ceil(items.length / columnsCount)\n  const totalHeight = rowsCount * (itemHeight + gap) - gap\n\n  // Calculate visible range\n  const { startRow, endRow } = useMemo(() => {\n    const visibleStartRow = Math.floor(scrollTop / (itemHeight + gap))\n    const visibleEndRow = Math.min(\n      rowsCount - 1,\n      Math.ceil((scrollTop + containerHeight) / (itemHeight + gap))\n    )\n\n    return {\n      startRow: Math.max(0, visibleStartRow - overscan),\n      endRow: Math.min(rowsCount - 1, visibleEndRow + overscan),\n    }\n  }, [scrollTop, itemHeight, gap, containerHeight, rowsCount, overscan])\n\n  // Handle scroll events\n  const handleScroll = useCallback((event: React.UIEvent<HTMLDivElement>) => {\n    const newScrollTop = event.currentTarget.scrollTop\n    setScrollTop(newScrollTop)\n  }, [])\n\n  // Render visible items\n  const visibleItems = useMemo(() => {\n    const itemsToRender = []\n    \n    for (let row = startRow; row <= endRow; row++) {\n      for (let col = 0; col < columnsCount; col++) {\n        const index = row * columnsCount + col\n        const item = items[index]\n        \n        if (!item) continue\n\n        const style: React.CSSProperties = {\n          position: 'absolute',\n          top: row * (itemHeight + gap),\n          left: col * (itemWidth + gap),\n          width: itemWidth,\n          height: itemHeight,\n        }\n\n        const key = getItemKey ? getItemKey(item, index) : index\n\n        itemsToRender.push(\n          <div key={key} style={style}>\n            {renderItem(item, index, style)}\n          </div>\n        )\n      }\n    }\n\n    return itemsToRender\n  }, [items, startRow, endRow, columnsCount, itemWidth, itemHeight, gap, renderItem, getItemKey])\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn('virtualized-grid', className)}\n      style={{\n        width: containerWidth,\n        height: containerHeight,\n        overflow: 'auto',\n        position: 'relative',\n      }}\n      onScroll={handleScroll}\n      role=\"grid\"\n      aria-label={`Virtualized grid with ${items.length} items`}\n    >\n      <div\n        style={{\n          height: totalHeight,\n          position: 'relative',\n        }}\n      >\n        {visibleItems}\n      </div>\n    </div>\n  )\n}\n\n// Hook for dynamic item sizing\nexport function useDynamicSizing<T>(\n  items: T[],\n  estimatedItemHeight: number,\n  measureItem: (item: T, index: number) => number\n) {\n  const [itemHeights, setItemHeights] = useState<Map<number, number>>(new Map())\n  const [totalHeight, setTotalHeight] = useState(items.length * estimatedItemHeight)\n\n  // Measure items as they become visible\n  const measureItemHeight = useCallback((index: number) => {\n    const item = items[index]\n    if (!item) return estimatedItemHeight\n\n    const height = measureItem(item, index)\n    \n    setItemHeights(prev => {\n      const newHeights = new Map(prev)\n      newHeights.set(index, height)\n      return newHeights\n    })\n\n    return height\n  }, [items, measureItem, estimatedItemHeight])\n\n  // Recalculate total height when item heights change\n  useEffect(() => {\n    let total = 0\n    for (let i = 0; i < items.length; i++) {\n      total += itemHeights.get(i) || estimatedItemHeight\n    }\n    setTotalHeight(total)\n  }, [items.length, itemHeights, estimatedItemHeight])\n\n  // Get offset for a specific item\n  const getItemOffset = useCallback((index: number) => {\n    let offset = 0\n    for (let i = 0; i < index; i++) {\n      offset += itemHeights.get(i) || estimatedItemHeight\n    }\n    return offset\n  }, [itemHeights, estimatedItemHeight])\n\n  return {\n    itemHeights,\n    totalHeight,\n    measureItemHeight,\n    getItemOffset,\n  }\n}\n\n// Performance monitoring for virtualized components\nexport function useVirtualizationPerformance(componentName: string) {\n  const renderCount = useRef(0)\n  const scrollEvents = useRef(0)\n  const lastScrollTime = useRef(0)\n\n  const trackScroll = useCallback(() => {\n    scrollEvents.current += 1\n    const now = performance.now()\n    \n    if (lastScrollTime.current > 0) {\n      const scrollDelta = now - lastScrollTime.current\n      \n      // Track scroll performance\n      if (scrollDelta < 16) { // Less than 16ms = good performance\n        console.log(`${componentName} smooth scroll: ${scrollDelta.toFixed(2)}ms`)\n      } else if (scrollDelta > 32) { // More than 32ms = poor performance\n        console.warn(`${componentName} janky scroll: ${scrollDelta.toFixed(2)}ms`)\n      }\n    }\n    \n    lastScrollTime.current = now\n  }, [componentName])\n\n  useEffect(() => {\n    renderCount.current += 1\n    \n    if (renderCount.current % 10 === 0) {\n      console.log(\n        `${componentName} performance: ${renderCount.current} renders, ` +\n        `${scrollEvents.current} scroll events`\n      )\n    }\n  })\n\n  return { trackScroll }\n}\n\n// Utility for calculating optimal item sizes\nexport function calculateOptimalItemSize(\n  containerSize: number,\n  itemCount: number,\n  minItemSize: number,\n  maxItemSize: number\n): number {\n  const idealSize = containerSize / itemCount\n  return Math.max(minItemSize, Math.min(maxItemSize, idealSize))\n}\n\n// Utility for estimating memory usage\nexport function estimateVirtualizationMemory(\n  totalItems: number,\n  visibleItems: number,\n  itemSizeBytes: number\n): {\n  totalMemory: number\n  virtualizedMemory: number\n  memorySaved: number\n  savingsPercentage: number\n} {\n  const totalMemory = totalItems * itemSizeBytes\n  const virtualizedMemory = visibleItems * itemSizeBytes\n  const memorySaved = totalMemory - virtualizedMemory\n  const savingsPercentage = (memorySaved / totalMemory) * 100\n\n  return {\n    totalMemory,\n    virtualizedMemory,\n    memorySaved,\n    savingsPercentage,\n  }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/__tests__/color-palette.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'DashboardThemeProvider' is defined but never used.",
        "line": 4,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { ColorPalette } from '../color-palette'\nimport { DashboardThemeProvider } from '../theme-provider'\n\n// Mock the theme provider context\nconst mockSetDashboardTheme = jest.fn()\nconst mockGetContrastRatio = jest.fn().mockReturnValue(4.5)\n\njest.mock('../theme-provider', () => ({\n  ...jest.requireActual('../theme-provider'),\n  useDashboardTheme: () => ({\n    dashboardTheme: {\n      colors: {\n        primary: '#3F51B5',\n        secondary: '#B19ADA',\n        accent: '#FF6B35',\n        background: '#FFFFFF',\n        surface: '#F8F9FA',\n        text: {\n          primary: '#1A1A1A',\n          secondary: '#6B7280',\n          disabled: '#9CA3AF'\n        },\n        status: {\n          success: '#10B981',\n          warning: '#F59E0B',\n          error: '#EF4444',\n          info: '#3B82F6'\n        },\n        chart: {\n          palette: [\n            '#3F51B5', '#B19ADA', '#FF6B35', '#10B981',\n            '#F59E0B', '#EF4444', '#3B82F6', '#8B5CF6',\n            '#EC4899', '#14B8A6'\n          ],\n          gradients: {\n            primary: 'linear-gradient(135deg, #3F51B5 0%, #B19ADA 100%)'\n          }\n        }\n      }\n    },\n    setDashboardTheme: mockSetDashboardTheme,\n    getContrastRatio: mockGetContrastRatio\n  })\n}))\n\ndescribe('ColorPalette', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('renders all color sections', () => {\n    render(<ColorPalette />)\n\n    expect(screen.getByText('Primary Colors')).toBeInTheDocument()\n    expect(screen.getByText('Background Colors')).toBeInTheDocument()\n    expect(screen.getByText('Text Colors')).toBeInTheDocument()\n    expect(screen.getByText('Status Colors')).toBeInTheDocument()\n    expect(screen.getByText('Chart Palette')).toBeInTheDocument()\n  })\n\n  it('displays color values correctly', () => {\n    render(<ColorPalette />)\n\n    expect(screen.getByText('#3F51B5')).toBeInTheDocument()\n    expect(screen.getByText('#B19ADA')).toBeInTheDocument()\n    expect(screen.getByText('#FF6B35')).toBeInTheDocument()\n    expect(screen.getByText('#FFFFFF')).toBeInTheDocument()\n  })\n\n  it('shows accessibility information when showLabels is true', () => {\n    render(<ColorPalette showLabels={true} />)\n\n    expect(screen.getByText('Accessibility Information')).toBeInTheDocument()\n    expect(screen.getByText(/Colors with contrast ratios 4.5:1 meet WCAG AA standards/)).toBeInTheDocument()\n  })\n\n  it('hides accessibility information when showLabels is false', () => {\n    render(<ColorPalette showLabels={false} />)\n\n    expect(screen.queryByText('Accessibility Information')).not.toBeInTheDocument()\n  })\n\n  it('displays contrast ratios for colors', () => {\n    render(<ColorPalette />)\n\n    // Should show contrast ratios (mocked to return 4.5)\n    const contrastRatios = screen.getAllByText('4.50:1')\n    expect(contrastRatios.length).toBeGreaterThan(0)\n  })\n\n  it('shows contrast warnings for poor contrast', () => {\n    // Mock poor contrast ratio\n    mockGetContrastRatio.mockReturnValue(2.0)\n\n    render(<ColorPalette />)\n\n    // Should show warning indicators (!) for poor contrast\n    const warningIndicators = screen.getAllByText('!')\n    expect(warningIndicators.length).toBeGreaterThan(0)\n  })\n\n  it('enables interactive mode when interactive is true', () => {\n    render(<ColorPalette interactive={true} />)\n\n    // Color swatches should be clickable\n    const colorSwatches = screen.getAllByRole('button')\n    expect(colorSwatches.length).toBeGreaterThan(0)\n\n    // Should show instruction about clicking\n    expect(screen.getByText(/Click on any color swatch to edit it/)).toBeInTheDocument()\n  })\n\n  it('calls onColorChange when color is changed in interactive mode', async () => {\n    const mockOnColorChange = jest.fn()\n    \n    render(\n      <ColorPalette \n        interactive={true} \n        onColorChange={mockOnColorChange}\n      />\n    )\n\n    // Find and click a color swatch\n    const primaryColorSwatch = screen.getByLabelText(/Primary color/)\n    fireEvent.click(primaryColorSwatch)\n\n    // Simulate color input change\n    const colorInput = screen.getByLabelText(/Edit Primary color/)\n    fireEvent.change(colorInput, { target: { value: '#FF0000' } })\n    fireEvent.blur(colorInput)\n\n    await waitFor(() => {\n      expect(mockSetDashboardTheme).toHaveBeenCalled()\n    })\n  })\n\n  it('handles keyboard navigation for interactive swatches', () => {\n    render(<ColorPalette interactive={true} />)\n\n    const primaryColorSwatch = screen.getByLabelText(/Primary color/)\n    \n    // Should be focusable\n    expect(primaryColorSwatch).toHaveAttribute('tabIndex', '0')\n    \n    // Should respond to Enter key\n    fireEvent.keyDown(primaryColorSwatch, { key: 'Enter' })\n    \n    // Color input should appear\n    expect(screen.getByLabelText(/Edit Primary color/)).toBeInTheDocument()\n  })\n\n  it('applies custom className', () => {\n    const { container } = render(<ColorPalette className=\"custom-class\" />)\n    \n    expect(container.firstChild).toHaveClass('custom-class')\n  })\n\n  it('renders chart palette colors correctly', () => {\n    render(<ColorPalette />)\n\n    // Should show first 10 chart colors\n    expect(screen.getByText('Chart 1')).toBeInTheDocument()\n    expect(screen.getByText('Chart 10')).toBeInTheDocument()\n    \n    // Should not show Chart 11 (only first 10 are displayed)\n    expect(screen.queryByText('Chart 11')).not.toBeInTheDocument()\n  })\n\n  it('handles color editing with keyboard shortcuts', async () => {\n    const mockOnColorChange = jest.fn()\n    \n    render(\n      <ColorPalette \n        interactive={true} \n        onColorChange={mockOnColorChange}\n      />\n    )\n\n    // Click to start editing\n    const primaryColorSwatch = screen.getByLabelText(/Primary color/)\n    fireEvent.click(primaryColorSwatch)\n\n    const colorInput = screen.getByLabelText(/Edit Primary color/)\n    fireEvent.change(colorInput, { target: { value: '#FF0000' } })\n\n    // Test Enter key to save\n    fireEvent.keyDown(colorInput, { key: 'Enter' })\n\n    await waitFor(() => {\n      expect(mockSetDashboardTheme).toHaveBeenCalled()\n    })\n  })\n\n  it('handles color editing cancellation with Escape key', async () => {\n    render(<ColorPalette interactive={true} />)\n\n    // Click to start editing\n    const primaryColorSwatch = screen.getByLabelText(/Primary color/)\n    fireEvent.click(primaryColorSwatch)\n\n    const colorInput = screen.getByLabelText(/Edit Primary color/)\n    fireEvent.change(colorInput, { target: { value: '#FF0000' } })\n\n    // Test Escape key to cancel\n    fireEvent.keyDown(colorInput, { key: 'Escape' })\n\n    // Should not call setDashboardTheme\n    expect(mockSetDashboardTheme).not.toHaveBeenCalled()\n  })\n\n  it('updates chart palette colors correctly', async () => {\n    const mockOnColorChange = jest.fn()\n    \n    render(\n      <ColorPalette \n        interactive={true} \n        onColorChange={mockOnColorChange}\n      />\n    )\n\n    // Find a chart color swatch\n    const chartColorSwatch = screen.getByLabelText(/Chart 1 color/)\n    fireEvent.click(chartColorSwatch)\n\n    const colorInput = screen.getByLabelText(/Edit Chart 1 color/)\n    fireEvent.change(colorInput, { target: { value: '#FF0000' } })\n    fireEvent.blur(colorInput)\n\n    await waitFor(() => {\n      expect(mockSetDashboardTheme).toHaveBeenCalledWith(\n        expect.objectContaining({\n          colors: expect.objectContaining({\n            chart: expect.objectContaining({\n              palette: expect.arrayContaining(['#FF0000'])\n            })\n          })\n        })\n      )\n    })\n  })\n\n  it('displays proper ARIA labels for accessibility', () => {\n    render(<ColorPalette />)\n\n    expect(screen.getByLabelText('Primary color: #3F51B5')).toBeInTheDocument()\n    expect(screen.getByLabelText('Secondary color: #B19ADA')).toBeInTheDocument()\n    expect(screen.getByLabelText('Success color: #10B981')).toBeInTheDocument()\n  })\n\n  it('shows color names and hex values', () => {\n    render(<ColorPalette />)\n\n    // Should show color names\n    expect(screen.getByText('Primary')).toBeInTheDocument()\n    expect(screen.getByText('Secondary')).toBeInTheDocument()\n    expect(screen.getByText('Success')).toBeInTheDocument()\n\n    // Should show hex values in uppercase\n    expect(screen.getByText('#3F51B5')).toBeInTheDocument()\n    expect(screen.getByText('#B19ADA')).toBeInTheDocument()\n    expect(screen.getByText('#10B981')).toBeInTheDocument()\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/__tests__/contrast-validator.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/__tests__/theme-customizer.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 70,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 70,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1705, 1708], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1705, 1708], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 80,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 80,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1972, 1975], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1972, 1975], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 90,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 90,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2256, 2259], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2256, 2259], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 191,
        "column": 99,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 191,
        "endColumn": 102,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5416, 5419], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5416, 5419], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 213,
        "column": 73,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 213,
        "endColumn": 76,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6233, 6236], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6233, 6236], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 318,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 318,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9739, 9742], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9739, 9742], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 349,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 349,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10730, 10733], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10730, 10733], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 381,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 381,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11744, 11747], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11744, 11747], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react'\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { ThemeCustomizer } from '../theme-customizer'\n\n// Mock the theme provider context\nconst mockSetTheme = jest.fn()\nconst mockSetDashboardTheme = jest.fn()\n\njest.mock('../theme-provider', () => ({\n  useDashboardTheme: () => ({\n    theme: 'light',\n    setTheme: mockSetTheme,\n    dashboardTheme: {\n      colors: {\n        primary: '#3F51B5',\n        secondary: '#B19ADA',\n        accent: '#FF6B35',\n        background: '#FFFFFF',\n        surface: '#F8F9FA',\n        text: {\n          primary: '#1A1A1A',\n          secondary: '#6B7280',\n          disabled: '#9CA3AF'\n        },\n        status: {\n          success: '#10B981',\n          warning: '#F59E0B',\n          error: '#EF4444',\n          info: '#3B82F6'\n        },\n        chart: {\n          palette: ['#3F51B5', '#B19ADA', '#FF6B35'],\n          gradients: {}\n        }\n      },\n      typography: {\n        fontFamily: {\n          sans: ['Inter'],\n          mono: ['Monaco']\n        },\n        fontSize: {\n          xs: '0.75rem',\n          sm: '0.875rem',\n          base: '1rem',\n          lg: '1.125rem',\n          xl: '1.25rem',\n          '2xl': '1.5rem',\n          '3xl': '2rem'\n        },\n        fontWeight: {\n          normal: 400,\n          medium: 500,\n          semibold: 600,\n          bold: 700\n        },\n        lineHeight: {\n          tight: 1.25,\n          normal: 1.5,\n          relaxed: 1.75\n        }\n      }\n    },\n    setDashboardTheme: mockSetDashboardTheme,\n    getContrastRatio: jest.fn().mockReturnValue(7.0)\n  })\n}))\n\n// Mock child components\njest.mock('../color-palette', () => ({\n  ColorPalette: ({ onColorChange }: any) => (\n    <div data-testid=\"color-palette\">\n      <button onClick={() => onColorChange?.('colors.primary', '#FF0000')}>\n        Change Color\n      </button>\n    </div>\n  )\n}))\n\njest.mock('../typography-scale', () => ({\n  TypographyScale: ({ onTypographyChange }: any) => (\n    <div data-testid=\"typography-scale\">\n      <button onClick={() => onTypographyChange?.('fontSize.base', '1.2rem')}>\n        Change Typography\n      </button>\n    </div>\n  )\n}))\n\njest.mock('../contrast-validator', () => ({\n  ContrastValidator: ({ onValidationComplete }: any) => {\n    React.useEffect(() => {\n      onValidationComplete?.([\n        { id: 'test1', isValid: true },\n        { id: 'test2', isValid: false }\n      ])\n    }, [onValidationComplete])\n    \n    return <div data-testid=\"contrast-validator\">Contrast Validator</div>\n  }\n}))\n\n// Mock URL.createObjectURL and related APIs\nglobal.URL.createObjectURL = jest.fn(() => 'mock-url')\nglobal.URL.revokeObjectURL = jest.fn()\n\n// Mock FileReader\nglobal.FileReader = jest.fn().mockImplementation(() => ({\n  readAsText: jest.fn(),\n  onload: null,\n  result: null\n}))\n\ndescribe('ThemeCustomizer', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('renders customizer title and description', () => {\n    render(<ThemeCustomizer />)\n\n    expect(screen.getByText('Theme Customizer')).toBeInTheDocument()\n    expect(screen.getByText(/Customize colors, typography, and validate accessibility compliance/)).toBeInTheDocument()\n  })\n\n  it('renders all tabs', () => {\n    render(<ThemeCustomizer />)\n\n    expect(screen.getByText('Colors')).toBeInTheDocument()\n    expect(screen.getByText('Typography')).toBeInTheDocument()\n    expect(screen.getByText('Validation')).toBeInTheDocument()\n  })\n\n  it('shows colors tab by default', () => {\n    render(<ThemeCustomizer />)\n\n    expect(screen.getByTestId('color-palette')).toBeInTheDocument()\n    expect(screen.queryByTestId('typography-scale')).not.toBeInTheDocument()\n  })\n\n  it('switches tabs when clicked', () => {\n    render(<ThemeCustomizer />)\n\n    fireEvent.click(screen.getByText('Typography'))\n\n    expect(screen.getByTestId('typography-scale')).toBeInTheDocument()\n    expect(screen.queryByTestId('color-palette')).not.toBeInTheDocument()\n  })\n\n  it('respects defaultTab prop', () => {\n    render(<ThemeCustomizer defaultTab=\"typography\" />)\n\n    expect(screen.getByTestId('typography-scale')).toBeInTheDocument()\n    expect(screen.queryByTestId('color-palette')).not.toBeInTheDocument()\n  })\n\n  it('renders theme mode selector', () => {\n    render(<ThemeCustomizer />)\n\n    const themeSelect = screen.getByDisplayValue('light')\n    expect(themeSelect).toBeInTheDocument()\n    \n    expect(screen.getByText('Light')).toBeInTheDocument()\n    expect(screen.getByText('Dark')).toBeInTheDocument()\n    expect(screen.getByText('System')).toBeInTheDocument()\n  })\n\n  it('changes theme when selector is used', () => {\n    render(<ThemeCustomizer />)\n\n    const themeSelect = screen.getByDisplayValue('light')\n    fireEvent.change(themeSelect, { target: { value: 'dark' } })\n\n    expect(mockSetTheme).toHaveBeenCalledWith('dark')\n  })\n\n  it('renders action buttons', () => {\n    render(<ThemeCustomizer />)\n\n    expect(screen.getByText('Export Theme')).toBeInTheDocument()\n    expect(screen.getByText('Import Theme')).toBeInTheDocument()\n    expect(screen.getByText('Reset to Defaults')).toBeInTheDocument()\n  })\n\n  it('exports theme when export button is clicked', () => {\n    // Mock document.createElement and related DOM methods\n    const mockAnchor = {\n      href: '',\n      download: '',\n      click: jest.fn()\n    }\n    const mockCreateElement = jest.spyOn(document, 'createElement').mockReturnValue(mockAnchor as any)\n    const mockAppendChild = jest.spyOn(document.body, 'appendChild').mockImplementation()\n    const mockRemoveChild = jest.spyOn(document.body, 'removeChild').mockImplementation()\n\n    render(<ThemeCustomizer />)\n\n    fireEvent.click(screen.getByText('Export Theme'))\n\n    expect(mockCreateElement).toHaveBeenCalledWith('a')\n    expect(mockAnchor.click).toHaveBeenCalled()\n    expect(mockAnchor.download).toBe('dashboard-theme.json')\n\n    mockCreateElement.mockRestore()\n    mockAppendChild.mockRestore()\n    mockRemoveChild.mockRestore()\n  })\n\n  it('calls onExport callback when theme is exported', () => {\n    const mockOnExport = jest.fn()\n    \n    // Mock DOM methods\n    const mockAnchor = { href: '', download: '', click: jest.fn() }\n    jest.spyOn(document, 'createElement').mockReturnValue(mockAnchor as any)\n    jest.spyOn(document.body, 'appendChild').mockImplementation()\n    jest.spyOn(document.body, 'removeChild').mockImplementation()\n\n    render(<ThemeCustomizer onExport={mockOnExport} />)\n\n    fireEvent.click(screen.getByText('Export Theme'))\n\n    expect(mockOnExport).toHaveBeenCalled()\n  })\n\n  it('triggers file input when import button is clicked', () => {\n    render(<ThemeCustomizer />)\n\n    const fileInput = screen.getByRole('button', { name: /import theme/i }).parentElement?.querySelector('input[type=\"file\"]')\n    const clickSpy = jest.spyOn(fileInput as HTMLElement, 'click').mockImplementation()\n\n    fireEvent.click(screen.getByText('Import Theme'))\n\n    expect(clickSpy).toHaveBeenCalled()\n  })\n\n  it('shows confirmation dialog when reset is clicked', () => {\n    const mockConfirm = jest.spyOn(window, 'confirm').mockReturnValue(false)\n    \n    render(<ThemeCustomizer />)\n\n    fireEvent.click(screen.getByText('Reset to Defaults'))\n\n    expect(mockConfirm).toHaveBeenCalledWith(\n      'Are you sure you want to reset all theme customizations? This cannot be undone.'\n    )\n\n    mockConfirm.mockRestore()\n  })\n\n  it('calls onThemeChange when theme is modified', () => {\n    const mockOnThemeChange = jest.fn()\n    \n    render(<ThemeCustomizer onThemeChange={mockOnThemeChange} />)\n\n    // Trigger a color change through the mocked ColorPalette\n    fireEvent.click(screen.getByText('Change Color'))\n\n    expect(mockSetDashboardTheme).toHaveBeenCalled()\n  })\n\n  it('shows validation issues badge on validation tab', async () => {\n    render(<ThemeCustomizer />)\n\n    // Wait for validation results to be set\n    await waitFor(() => {\n      const validationTab = screen.getByText('Validation').parentElement\n      expect(validationTab?.querySelector('.bg-red-100')).toBeInTheDocument()\n      expect(screen.getByText('1')).toBeInTheDocument() // 1 failed test\n    })\n  })\n\n  it('displays footer information', async () => {\n    render(<ThemeCustomizer />)\n\n    expect(screen.getByText('Current Theme: light')).toBeInTheDocument()\n    expect(screen.getByText('Changes are applied automatically')).toBeInTheDocument()\n\n    // Wait for validation results\n    await waitFor(() => {\n      expect(screen.getByText(/Accessibility: \\d+\\/\\d+ passed/)).toBeInTheDocument()\n    })\n  })\n\n  it('applies custom className', () => {\n    const { container } = render(<ThemeCustomizer className=\"custom-class\" />)\n    \n    expect(container.firstChild).toHaveClass('custom-class')\n  })\n\n  it('handles file import correctly', () => {\n    const mockOnImport = jest.fn()\n    const mockFileReader = {\n      readAsText: jest.fn(),\n      onload: null,\n      result: JSON.stringify({\n        colors: { primary: '#FF0000' },\n        typography: { fontSize: { base: '1rem' } }\n      })\n    }\n    \n    ;(global.FileReader as jest.Mock).mockImplementation(() => mockFileReader)\n\n    render(<ThemeCustomizer onImport={mockOnImport} />)\n\n    const fileInput = screen.getByRole('button', { name: /import theme/i }).parentElement?.querySelector('input[type=\"file\"]') as HTMLInputElement\n\n    const mockFile = new File(['{}'], 'theme.json', { type: 'application/json' })\n    Object.defineProperty(fileInput, 'files', {\n      value: [mockFile],\n      writable: false,\n    })\n\n    fireEvent.change(fileInput)\n\n    expect(mockFileReader.readAsText).toHaveBeenCalledWith(mockFile)\n\n    // Simulate file read completion\n    if (mockFileReader.onload) {\n      mockFileReader.onload({ target: { result: mockFileReader.result } } as any)\n    }\n\n    expect(mockSetDashboardTheme).toHaveBeenCalled()\n    expect(mockOnImport).toHaveBeenCalled()\n  })\n\n  it('handles invalid import file gracefully', () => {\n    const mockAlert = jest.spyOn(window, 'alert').mockImplementation()\n    const mockFileReader = {\n      readAsText: jest.fn(),\n      onload: null,\n      result: 'invalid json'\n    }\n    \n    ;(global.FileReader as jest.Mock).mockImplementation(() => mockFileReader)\n\n    render(<ThemeCustomizer />)\n\n    const fileInput = screen.getByRole('button', { name: /import theme/i }).parentElement?.querySelector('input[type=\"file\"]') as HTMLInputElement\n\n    const mockFile = new File(['invalid'], 'theme.json', { type: 'application/json' })\n    Object.defineProperty(fileInput, 'files', {\n      value: [mockFile],\n      writable: false,\n    })\n\n    fireEvent.change(fileInput)\n\n    // Simulate file read completion\n    if (mockFileReader.onload) {\n      mockFileReader.onload({ target: { result: mockFileReader.result } } as any)\n    }\n\n    expect(mockAlert).toHaveBeenCalledWith('Error parsing theme file')\n\n    mockAlert.mockRestore()\n  })\n\n  it('validates theme structure on import', () => {\n    const mockAlert = jest.spyOn(window, 'alert').mockImplementation()\n    const mockFileReader = {\n      readAsText: jest.fn(),\n      onload: null,\n      result: JSON.stringify({ invalidStructure: true })\n    }\n    \n    ;(global.FileReader as jest.Mock).mockImplementation(() => mockFileReader)\n\n    render(<ThemeCustomizer />)\n\n    const fileInput = screen.getByRole('button', { name: /import theme/i }).parentElement?.querySelector('input[type=\"file\"]') as HTMLInputElement\n\n    const mockFile = new File(['{}'], 'theme.json', { type: 'application/json' })\n    Object.defineProperty(fileInput, 'files', {\n      value: [mockFile],\n      writable: false,\n    })\n\n    fireEvent.change(fileInput)\n\n    // Simulate file read completion\n    if (mockFileReader.onload) {\n      mockFileReader.onload({ target: { result: mockFileReader.result } } as any)\n    }\n\n    expect(mockAlert).toHaveBeenCalledWith('Invalid theme file format')\n\n    mockAlert.mockRestore()\n  })\n})",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/__tests__/theme-provider.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/__tests__/typography-scale.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/color-palette.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 121,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 121,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3722, 3725], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3722, 3725], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 273,
        "column": 73,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 273,
        "endColumn": 76,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9657, 9660], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9657, 9660], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport * as React from 'react'\nimport { useDashboardTheme } from './theme-provider'\nimport { DashboardTheme } from '@/types/dashboard'\n\ninterface ColorPaletteProps {\n  className?: string\n  showLabels?: boolean\n  interactive?: boolean\n  onColorChange?: (colorKey: string, newColor: string) => void\n}\n\ninterface ColorSwatchProps {\n  color: string\n  label: string\n  interactive?: boolean\n  onColorChange?: (newColor: string) => void\n  contrastRatio?: number\n}\n\nfunction ColorSwatch({ color, label, interactive = false, onColorChange, contrastRatio }: ColorSwatchProps) {\n  const [isEditing, setIsEditing] = React.useState(false)\n  const [tempColor, setTempColor] = React.useState(color)\n  const inputRef = React.useRef<HTMLInputElement>(null)\n\n  const handleClick = () => {\n    if (interactive) {\n      setIsEditing(true)\n      setTimeout(() => inputRef.current?.focus(), 0)\n    }\n  }\n\n  const handleColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setTempColor(e.target.value)\n  }\n\n  const handleSubmit = () => {\n    if (onColorChange && tempColor !== color) {\n      onColorChange(tempColor)\n    }\n    setIsEditing(false)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      handleSubmit()\n    } else if (e.key === 'Escape') {\n      setTempColor(color)\n      setIsEditing(false)\n    }\n  }\n\n  const contrastWarning = contrastRatio && contrastRatio < 4.5\n\n  return (\n    <div className=\"flex flex-col items-center space-y-2\">\n      <div\n        className={`\n          relative w-16 h-16 rounded-lg border-2 border-gray-200 shadow-sm\n          ${interactive ? 'cursor-pointer hover:scale-105 transition-transform' : ''}\n          ${contrastWarning ? 'ring-2 ring-red-400' : ''}\n        `}\n        style={{ backgroundColor: color }}\n        onClick={handleClick}\n        role={interactive ? 'button' : undefined}\n        tabIndex={interactive ? 0 : undefined}\n        onKeyDown={interactive ? (e) => e.key === 'Enter' && handleClick() : undefined}\n        aria-label={`${label} color: ${color}`}\n      >\n        {isEditing && (\n          <input\n            ref={inputRef}\n            type=\"color\"\n            value={tempColor}\n            onChange={handleColorChange}\n            onBlur={handleSubmit}\n            onKeyDown={handleKeyDown}\n            className=\"absolute inset-0 w-full h-full opacity-0 cursor-pointer\"\n            aria-label={`Edit ${label} color`}\n          />\n        )}\n        {contrastWarning && (\n          <div className=\"absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full flex items-center justify-center\">\n            <span className=\"text-white text-xs font-bold\">!</span>\n          </div>\n        )}\n      </div>\n      <div className=\"text-center\">\n        <div className=\"text-sm font-medium text-gray-900 dark:text-gray-100\">\n          {label}\n        </div>\n        <div className=\"text-xs text-gray-500 dark:text-gray-400 font-mono\">\n          {color.toUpperCase()}\n        </div>\n        {contrastRatio && (\n          <div className={`text-xs ${contrastWarning ? 'text-red-600' : 'text-green-600'}`}>\n            {contrastRatio.toFixed(2)}:1\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n\nexport function ColorPalette({ \n  className = '', \n  showLabels = true, \n  interactive = false,\n  onColorChange \n}: ColorPaletteProps) {\n  const { dashboardTheme, setDashboardTheme, getContrastRatio } = useDashboardTheme()\n\n  const handleColorChange = (colorPath: string, newColor: string) => {\n    if (!onColorChange) return\n\n    const pathParts = colorPath.split('.')\n    const updatedTheme: Partial<DashboardTheme> = { ...dashboardTheme }\n    \n    // Navigate to the nested property and update it\n    let current: any = updatedTheme\n    for (let i = 0; i < pathParts.length - 1; i++) {\n      if (!current[pathParts[i]]) {\n        current[pathParts[i]] = {}\n      }\n      current = current[pathParts[i]]\n    }\n    current[pathParts[pathParts.length - 1]] = newColor\n\n    setDashboardTheme(updatedTheme)\n    onColorChange(colorPath, newColor)\n  }\n\n  const getContrastForColor = (color: string): number => {\n    return getContrastRatio(color, dashboardTheme.colors.background)\n  }\n\n  return (\n    <div className={`space-y-8 ${className}`}>\n      {/* Primary Colors */}\n      <div>\n        <h3 className=\"text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100\">\n          Primary Colors\n        </h3>\n        <div className=\"grid grid-cols-3 gap-4\">\n          <ColorSwatch\n            color={dashboardTheme.colors.primary}\n            label=\"Primary\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.primary', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.primary)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.secondary}\n            label=\"Secondary\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.secondary', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.secondary)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.accent}\n            label=\"Accent\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.accent', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.accent)}\n          />\n        </div>\n      </div>\n\n      {/* Background Colors */}\n      <div>\n        <h3 className=\"text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100\">\n          Background Colors\n        </h3>\n        <div className=\"grid grid-cols-2 gap-4\">\n          <ColorSwatch\n            color={dashboardTheme.colors.background}\n            label=\"Background\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.background', color)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.surface}\n            label=\"Surface\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.surface', color)}\n          />\n        </div>\n      </div>\n\n      {/* Text Colors */}\n      <div>\n        <h3 className=\"text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100\">\n          Text Colors\n        </h3>\n        <div className=\"grid grid-cols-3 gap-4\">\n          <ColorSwatch\n            color={dashboardTheme.colors.text.primary}\n            label=\"Primary Text\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.text.primary', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.text.primary)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.text.secondary}\n            label=\"Secondary Text\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.text.secondary', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.text.secondary)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.text.disabled}\n            label=\"Disabled Text\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.text.disabled', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.text.disabled)}\n          />\n        </div>\n      </div>\n\n      {/* Status Colors */}\n      <div>\n        <h3 className=\"text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100\">\n          Status Colors\n        </h3>\n        <div className=\"grid grid-cols-4 gap-4\">\n          <ColorSwatch\n            color={dashboardTheme.colors.status.success}\n            label=\"Success\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.status.success', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.status.success)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.status.warning}\n            label=\"Warning\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.status.warning', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.status.warning)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.status.error}\n            label=\"Error\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.status.error', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.status.error)}\n          />\n          <ColorSwatch\n            color={dashboardTheme.colors.status.info}\n            label=\"Info\"\n            interactive={interactive}\n            onColorChange={(color) => handleColorChange('colors.status.info', color)}\n            contrastRatio={getContrastForColor(dashboardTheme.colors.status.info)}\n          />\n        </div>\n      </div>\n\n      {/* Chart Colors */}\n      <div>\n        <h3 className=\"text-lg font-semibold mb-4 text-gray-900 dark:text-gray-100\">\n          Chart Palette\n        </h3>\n        <div className=\"grid grid-cols-5 gap-4\">\n          {dashboardTheme.colors.chart.palette.slice(0, 10).map((color, index) => (\n            <ColorSwatch\n              key={index}\n              color={color}\n              label={`Chart ${index + 1}`}\n              interactive={interactive}\n              onColorChange={(newColor) => {\n                const newPalette = [...dashboardTheme.colors.chart.palette]\n                newPalette[index] = newColor\n                handleColorChange('colors.chart.palette', newPalette as any)\n              }}\n              contrastRatio={getContrastForColor(color)}\n            />\n          ))}\n        </div>\n      </div>\n\n      {/* Accessibility Information */}\n      {showLabels && (\n        <div className=\"mt-8 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg\">\n          <h4 className=\"text-md font-semibold mb-2 text-gray-900 dark:text-gray-100\">\n            Accessibility Information\n          </h4>\n          <div className=\"text-sm text-gray-600 dark:text-gray-400 space-y-1\">\n            <p> Colors with contrast ratios 4.5:1 meet WCAG AA standards</p>\n            <p> Colors with contrast ratios 7:1 meet WCAG AAA standards</p>\n            <p> Red warning indicators show colors that don&apos;t meet AA standards</p>\n            {interactive && (\n              <p> Click on any color swatch to edit it</p>\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport default ColorPalette",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/contrast-validator.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'DashboardTheme' is defined but never used.",
        "line": 5,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport * as React from 'react'\nimport { useDashboardTheme } from './theme-provider'\nimport { DashboardTheme } from '@/types/dashboard'\n\ninterface ContrastValidatorProps {\n  className?: string\n  showDetails?: boolean\n  autoValidate?: boolean\n  onValidationComplete?: (results: ValidationResult[]) => void\n}\n\ninterface ValidationResult {\n  id: string\n  colorPair: {\n    foreground: string\n    background: string\n    foregroundName: string\n    backgroundName: string\n  }\n  contrastRatio: number\n  wcagLevel: 'AAA' | 'AA' | 'FAIL'\n  isValid: boolean\n  recommendation?: string\n}\n\ninterface ContrastTestPair {\n  id: string\n  foreground: string\n  background: string\n  foregroundName: string\n  backgroundName: string\n  requiredRatio: number\n  context: 'text' | 'ui' | 'graphical'\n}\n\n// WCAG 2.1 contrast requirements\nconst WCAG_REQUIREMENTS = {\n  AA_NORMAL: 4.5,\n  AA_LARGE: 3.0,\n  AAA_NORMAL: 7.0,\n  AAA_LARGE: 4.5,\n  UI_COMPONENTS: 3.0,\n  GRAPHICAL: 3.0\n}\n\nfunction getWCAGLevel(ratio: number, isLargeText: boolean = false): 'AAA' | 'AA' | 'FAIL' {\n  if (isLargeText) {\n    if (ratio >= WCAG_REQUIREMENTS.AAA_LARGE) return 'AAA'\n    if (ratio >= WCAG_REQUIREMENTS.AA_LARGE) return 'AA'\n  } else {\n    if (ratio >= WCAG_REQUIREMENTS.AAA_NORMAL) return 'AAA'\n    if (ratio >= WCAG_REQUIREMENTS.AA_NORMAL) return 'AA'\n  }\n  return 'FAIL'\n}\n\nfunction generateRecommendation(result: ValidationResult): string {\n  const { contrastRatio, wcagLevel } = result\n  \n  if (wcagLevel === 'FAIL') {\n    const needed = WCAG_REQUIREMENTS.AA_NORMAL\n    const improvement = ((needed / contrastRatio - 1) * 100).toFixed(0)\n    return `Increase contrast by approximately ${improvement}% to meet WCAG AA standards`\n  }\n  \n  if (wcagLevel === 'AA') {\n    const needed = WCAG_REQUIREMENTS.AAA_NORMAL\n    const improvement = ((needed / contrastRatio - 1) * 100).toFixed(0)\n    return `Consider increasing contrast by ${improvement}% to achieve WCAG AAA level`\n  }\n  \n  return 'Excellent contrast - meets WCAG AAA standards'\n}\n\nexport function ContrastValidator({\n  className = '',\n  showDetails = true,\n  autoValidate = true,\n  onValidationComplete\n}: ContrastValidatorProps) {\n  const { dashboardTheme, getContrastRatio } = useDashboardTheme()\n  const [validationResults, setValidationResults] = React.useState<ValidationResult[]>([])\n  const [isValidating, setIsValidating] = React.useState(false)\n\n  // Generate test pairs based on current theme\n  const generateTestPairs = React.useCallback((): ContrastTestPair[] => {\n    const { colors } = dashboardTheme\n    const pairs: ContrastTestPair[] = []\n\n    // Text colors against backgrounds\n    Object.entries(colors.text).forEach(([textKey, textColor]) => {\n      pairs.push({\n        id: `text-${textKey}-bg`,\n        foreground: textColor,\n        background: colors.background,\n        foregroundName: `Text ${textKey}`,\n        backgroundName: 'Background',\n        requiredRatio: WCAG_REQUIREMENTS.AA_NORMAL,\n        context: 'text'\n      })\n\n      pairs.push({\n        id: `text-${textKey}-surface`,\n        foreground: textColor,\n        background: colors.surface,\n        foregroundName: `Text ${textKey}`,\n        backgroundName: 'Surface',\n        requiredRatio: WCAG_REQUIREMENTS.AA_NORMAL,\n        context: 'text'\n      })\n    })\n\n    // Status colors against backgrounds\n    Object.entries(colors.status).forEach(([statusKey, statusColor]) => {\n      pairs.push({\n        id: `status-${statusKey}-bg`,\n        foreground: statusColor,\n        background: colors.background,\n        foregroundName: `Status ${statusKey}`,\n        backgroundName: 'Background',\n        requiredRatio: WCAG_REQUIREMENTS.UI_COMPONENTS,\n        context: 'ui'\n      })\n    })\n\n    // Primary colors against backgrounds\n    pairs.push({\n      id: 'primary-bg',\n      foreground: colors.primary,\n      background: colors.background,\n      foregroundName: 'Primary',\n      backgroundName: 'Background',\n      requiredRatio: WCAG_REQUIREMENTS.UI_COMPONENTS,\n      context: 'ui'\n    })\n\n    pairs.push({\n      id: 'secondary-bg',\n      foreground: colors.secondary,\n      background: colors.background,\n      foregroundName: 'Secondary',\n      backgroundName: 'Background',\n      requiredRatio: WCAG_REQUIREMENTS.UI_COMPONENTS,\n      context: 'ui'\n    })\n\n    pairs.push({\n      id: 'accent-bg',\n      foreground: colors.accent,\n      background: colors.background,\n      foregroundName: 'Accent',\n      backgroundName: 'Background',\n      requiredRatio: WCAG_REQUIREMENTS.UI_COMPONENTS,\n      context: 'ui'\n    })\n\n    return pairs\n  }, [dashboardTheme])\n\n  // Validate contrast ratios\n  const validateContrast = React.useCallback(async () => {\n    setIsValidating(true)\n    const testPairs = generateTestPairs()\n    const results: ValidationResult[] = []\n\n    for (const pair of testPairs) {\n      const ratio = getContrastRatio(pair.foreground, pair.background)\n      const wcagLevel = getWCAGLevel(ratio, false) // Assuming normal text size\n      const isValid = ratio >= pair.requiredRatio\n\n      const result: ValidationResult = {\n        id: pair.id,\n        colorPair: {\n          foreground: pair.foreground,\n          background: pair.background,\n          foregroundName: pair.foregroundName,\n          backgroundName: pair.backgroundName\n        },\n        contrastRatio: ratio,\n        wcagLevel,\n        isValid,\n        recommendation: generateRecommendation({\n          id: pair.id,\n          colorPair: {\n            foreground: pair.foreground,\n            background: pair.background,\n            foregroundName: pair.foregroundName,\n            backgroundName: pair.backgroundName\n          },\n          contrastRatio: ratio,\n          wcagLevel,\n          isValid\n        })\n      }\n\n      results.push(result)\n    }\n\n    setValidationResults(results)\n    setIsValidating(false)\n\n    if (onValidationComplete) {\n      onValidationComplete(results)\n    }\n  }, [generateTestPairs, getContrastRatio, onValidationComplete])\n\n  // Auto-validate when theme changes\n  React.useEffect(() => {\n    if (autoValidate) {\n      validateContrast()\n    }\n  }, [autoValidate, validateContrast])\n\n  const failedTests = validationResults.filter(result => !result.isValid)\n  const passedTests = validationResults.filter(result => result.isValid)\n  const aaaTests = validationResults.filter(result => result.wcagLevel === 'AAA')\n\n  return (\n    <div className={`space-y-6 ${className}`}>\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h3 className=\"text-lg font-semibold text-gray-900 dark:text-gray-100\">\n            Contrast Validation\n          </h3>\n          <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n            WCAG 2.1 accessibility compliance check\n          </p>\n        </div>\n        <button\n          onClick={validateContrast}\n          disabled={isValidating}\n          className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed\"\n        >\n          {isValidating ? 'Validating...' : 'Validate'}\n        </button>\n      </div>\n\n      {/* Summary */}\n      {validationResults.length > 0 && (\n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n          <div className=\"bg-green-50 dark:bg-green-900/20 p-4 rounded-lg\">\n            <div className=\"text-2xl font-bold text-green-600 dark:text-green-400\">\n              {passedTests.length}\n            </div>\n            <div className=\"text-sm text-green-800 dark:text-green-200\">\n              Passed Tests\n            </div>\n          </div>\n          \n          <div className=\"bg-red-50 dark:bg-red-900/20 p-4 rounded-lg\">\n            <div className=\"text-2xl font-bold text-red-600 dark:text-red-400\">\n              {failedTests.length}\n            </div>\n            <div className=\"text-sm text-red-800 dark:text-red-200\">\n              Failed Tests\n            </div>\n          </div>\n          \n          <div className=\"bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg\">\n            <div className=\"text-2xl font-bold text-purple-600 dark:text-purple-400\">\n              {aaaTests.length}\n            </div>\n            <div className=\"text-sm text-purple-800 dark:text-purple-200\">\n              AAA Level\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Detailed Results */}\n      {showDetails && validationResults.length > 0 && (\n        <div className=\"space-y-4\">\n          <h4 className=\"text-md font-semibold text-gray-900 dark:text-gray-100\">\n            Detailed Results\n          </h4>\n          \n          {/* Failed Tests First */}\n          {failedTests.length > 0 && (\n            <div className=\"space-y-3\">\n              <h5 className=\"text-sm font-medium text-red-600 dark:text-red-400\">\n                Failed Tests ({failedTests.length})\n              </h5>\n              {failedTests.map((result) => (\n                <div\n                  key={result.id}\n                  className=\"border border-red-200 dark:border-red-800 rounded-lg p-4 bg-red-50 dark:bg-red-900/10\"\n                >\n                  <div className=\"flex items-center justify-between mb-2\">\n                    <div className=\"flex items-center space-x-3\">\n                      <div className=\"flex items-center space-x-2\">\n                        <div\n                          className=\"w-4 h-4 rounded border\"\n                          style={{ backgroundColor: result.colorPair.foreground }}\n                        />\n                        <span className=\"text-sm font-medium\">\n                          {result.colorPair.foregroundName}\n                        </span>\n                        <span className=\"text-xs text-gray-500\">on</span>\n                        <div\n                          className=\"w-4 h-4 rounded border\"\n                          style={{ backgroundColor: result.colorPair.background }}\n                        />\n                        <span className=\"text-sm font-medium\">\n                          {result.colorPair.backgroundName}\n                        </span>\n                      </div>\n                    </div>\n                    <div className=\"text-right\">\n                      <div className=\"text-sm font-mono text-red-600 dark:text-red-400\">\n                        {result.contrastRatio.toFixed(2)}:1\n                      </div>\n                      <div className=\"text-xs text-red-500\">\n                        {result.wcagLevel}\n                      </div>\n                    </div>\n                  </div>\n                  <div className=\"text-xs text-red-700 dark:text-red-300\">\n                    {result.recommendation}\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n\n          {/* Passed Tests */}\n          {passedTests.length > 0 && (\n            <div className=\"space-y-3\">\n              <h5 className=\"text-sm font-medium text-green-600 dark:text-green-400\">\n                Passed Tests ({passedTests.length})\n              </h5>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n                {passedTests.map((result) => (\n                  <div\n                    key={result.id}\n                    className=\"border border-green-200 dark:border-green-800 rounded-lg p-3 bg-green-50 dark:bg-green-900/10\"\n                  >\n                    <div className=\"flex items-center justify-between\">\n                      <div className=\"flex items-center space-x-2\">\n                        <div\n                          className=\"w-3 h-3 rounded border\"\n                          style={{ backgroundColor: result.colorPair.foreground }}\n                        />\n                        <span className=\"text-xs\">\n                          {result.colorPair.foregroundName} / {result.colorPair.backgroundName}\n                        </span>\n                      </div>\n                      <div className=\"text-right\">\n                        <div className=\"text-xs font-mono text-green-600 dark:text-green-400\">\n                          {result.contrastRatio.toFixed(2)}:1\n                        </div>\n                        <div className=\"text-xs text-green-500\">\n                          {result.wcagLevel}\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* WCAG Guidelines */}\n      <div className=\"bg-gray-50 dark:bg-gray-800 rounded-lg p-4\">\n        <h4 className=\"text-sm font-semibold mb-3 text-gray-900 dark:text-gray-100\">\n          WCAG 2.1 Contrast Requirements\n        </h4>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 text-xs text-gray-600 dark:text-gray-400\">\n          <div>\n            <div className=\"font-medium mb-1\">Normal Text</div>\n            <div>AA: 4.5:1 minimum</div>\n            <div>AAA: 7:1 minimum</div>\n          </div>\n          <div>\n            <div className=\"font-medium mb-1\">Large Text (18pt+)</div>\n            <div>AA: 3:1 minimum</div>\n            <div>AAA: 4.5:1 minimum</div>\n          </div>\n          <div>\n            <div className=\"font-medium mb-1\">UI Components</div>\n            <div>AA: 3:1 minimum</div>\n          </div>\n          <div>\n            <div className=\"font-medium mb-1\">Graphical Objects</div>\n            <div>AA: 3:1 minimum</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default ContrastValidator",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/theme-customizer.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 34,
        "column": 68,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 34,
        "endColumn": 71,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1039, 1042], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1039, 1042], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleThemeChange' is assigned a value but never used.",
        "line": 37,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 37,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used.",
        "line": 91,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 91,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client'\n\nimport * as React from 'react'\nimport { useDashboardTheme } from './theme-provider'\nimport { ColorPalette } from './color-palette'\nimport { TypographyScale } from './typography-scale'\nimport { ContrastValidator } from './contrast-validator'\nimport { DashboardTheme } from '@/types/dashboard'\n\ninterface ThemeCustomizerProps {\n  className?: string\n  defaultTab?: 'colors' | 'typography' | 'validation'\n  onThemeChange?: (theme: Partial<DashboardTheme>) => void\n  onExport?: (theme: DashboardTheme) => void\n  onImport?: (theme: Partial<DashboardTheme>) => void\n}\n\ninterface TabProps {\n  id: string\n  label: string\n  icon: React.ReactNode\n  content: React.ReactNode\n}\n\nexport function ThemeCustomizer({\n  className = '',\n  defaultTab = 'colors',\n  onThemeChange,\n  onExport,\n  onImport\n}: ThemeCustomizerProps) {\n  const { theme, setTheme, dashboardTheme, setDashboardTheme } = useDashboardTheme()\n  const [activeTab, setActiveTab] = React.useState(defaultTab)\n  const [validationResults, setValidationResults] = React.useState<any[]>([])\n  const fileInputRef = React.useRef<HTMLInputElement>(null)\n\n  const handleThemeChange = React.useCallback((newTheme: Partial<DashboardTheme>) => {\n    setDashboardTheme(newTheme)\n    if (onThemeChange) {\n      onThemeChange(newTheme)\n    }\n  }, [setDashboardTheme, onThemeChange])\n\n  const handleExportTheme = () => {\n    const themeData = {\n      ...dashboardTheme,\n      metadata: {\n        name: 'Custom Dashboard Theme',\n        version: '1.0.0',\n        createdAt: new Date().toISOString(),\n        description: 'Exported from Dashboard Theme Customizer'\n      }\n    }\n\n    const blob = new Blob([JSON.stringify(themeData, null, 2)], {\n      type: 'application/json'\n    })\n    \n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = 'dashboard-theme.json'\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n\n    if (onExport) {\n      onExport(dashboardTheme)\n    }\n  }\n\n  const handleImportTheme = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0]\n    if (!file) return\n\n    const reader = new FileReader()\n    reader.onload = (e) => {\n      try {\n        const importedTheme = JSON.parse(e.target?.result as string)\n        \n        // Validate that it's a valid theme object\n        if (importedTheme.colors && importedTheme.typography) {\n          setDashboardTheme(importedTheme)\n          if (onImport) {\n            onImport(importedTheme)\n          }\n        } else {\n          alert('Invalid theme file format')\n        }\n      } catch (error) {\n        alert('Error parsing theme file')\n      }\n    }\n    reader.readAsText(file)\n  }\n\n  const resetToDefaults = () => {\n    if (confirm('Are you sure you want to reset all theme customizations? This cannot be undone.')) {\n      // Reset to default theme by reloading\n      window.location.reload()\n    }\n  }\n\n  const tabs: TabProps[] = [\n    {\n      id: 'colors',\n      label: 'Colors',\n      icon: (\n        <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5a2 2 0 00-2-2h-4a2 2 0 00-2 2v12a4 4 0 004 4h4a2 2 0 002-2V5z\" />\n        </svg>\n      ),\n      content: (\n        <ColorPalette\n          interactive={true}\n          onColorChange={(colorPath, newColor) => {\n            console.log(`Color changed: ${colorPath} = ${newColor}`)\n          }}\n        />\n      )\n    },\n    {\n      id: 'typography',\n      label: 'Typography',\n      icon: (\n        <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253\" />\n        </svg>\n      ),\n      content: (\n        <TypographyScale\n          interactive={true}\n          onTypographyChange={(key, value) => {\n            console.log(`Typography changed: ${key} = ${value}`)\n          }}\n        />\n      )\n    },\n    {\n      id: 'validation',\n      label: 'Validation',\n      icon: (\n        <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n        </svg>\n      ),\n      content: (\n        <ContrastValidator\n          onValidationComplete={setValidationResults}\n        />\n      )\n    }\n  ]\n\n  const failedValidations = validationResults.filter(result => !result.isValid).length\n  const hasValidationIssues = failedValidations > 0\n\n  return (\n    <div className={`bg-white dark:bg-gray-900 rounded-lg shadow-lg ${className}`}>\n      {/* Header */}\n      <div className=\"border-b border-gray-200 dark:border-gray-700 p-6\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <h2 className=\"text-xl font-semibold text-gray-900 dark:text-gray-100\">\n              Theme Customizer\n            </h2>\n            <p className=\"text-sm text-gray-600 dark:text-gray-400 mt-1\">\n              Customize colors, typography, and validate accessibility compliance\n            </p>\n          </div>\n          \n          {/* Theme Mode Toggle */}\n          <div className=\"flex items-center space-x-2\">\n            <label className=\"text-sm text-gray-700 dark:text-gray-300\">\n              Theme:\n            </label>\n            <select\n              value={theme}\n              onChange={(e) => setTheme(e.target.value as 'light' | 'dark' | 'system')}\n              className=\"px-3 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100\"\n            >\n              <option value=\"light\">Light</option>\n              <option value=\"dark\">Dark</option>\n              <option value=\"system\">System</option>\n            </select>\n          </div>\n        </div>\n\n        {/* Action Buttons */}\n        <div className=\"flex items-center space-x-3 mt-4\">\n          <button\n            onClick={handleExportTheme}\n            className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm\"\n          >\n            Export Theme\n          </button>\n          \n          <button\n            onClick={() => fileInputRef.current?.click()}\n            className=\"px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm\"\n          >\n            Import Theme\n          </button>\n          \n          <button\n            onClick={resetToDefaults}\n            className=\"px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 text-sm\"\n          >\n            Reset to Defaults\n          </button>\n\n          <input\n            ref={fileInputRef}\n            type=\"file\"\n            accept=\".json\"\n            onChange={handleImportTheme}\n            className=\"hidden\"\n          />\n        </div>\n      </div>\n\n      {/* Tabs */}\n      <div className=\"border-b border-gray-200 dark:border-gray-700\">\n        <nav className=\"flex space-x-8 px-6\" aria-label=\"Tabs\">\n          {tabs.map((tab) => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id)}\n              className={`\n                flex items-center space-x-2 py-4 px-1 border-b-2 font-medium text-sm\n                ${activeTab === tab.id\n                  ? 'border-blue-500 text-blue-600 dark:text-blue-400'\n                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300'\n                }\n              `}\n            >\n              {tab.icon}\n              <span>{tab.label}</span>\n              {tab.id === 'validation' && hasValidationIssues && (\n                <span className=\"bg-red-100 text-red-800 text-xs px-2 py-1 rounded-full\">\n                  {failedValidations}\n                </span>\n              )}\n            </button>\n          ))}\n        </nav>\n      </div>\n\n      {/* Tab Content */}\n      <div className=\"p-6\">\n        {tabs.find(tab => tab.id === activeTab)?.content}\n      </div>\n\n      {/* Footer */}\n      <div className=\"border-t border-gray-200 dark:border-gray-700 p-4 bg-gray-50 dark:bg-gray-800 rounded-b-lg\">\n        <div className=\"flex items-center justify-between text-sm text-gray-600 dark:text-gray-400\">\n          <div className=\"flex items-center space-x-4\">\n            <span>Current Theme: {theme}</span>\n            {validationResults.length > 0 && (\n              <span>\n                Accessibility: {validationResults.length - failedValidations}/{validationResults.length} passed\n              </span>\n            )}\n          </div>\n          <div className=\"text-xs\">\n            Changes are applied automatically\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default ThemeCustomizer",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/theme-provider.stories.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/theme-provider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/akashrathod/Desktop/cubcen/src/components/dashboard/theming/typography-scale.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
